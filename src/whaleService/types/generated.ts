import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: any;
  /**
   * Represents fractional signed whole numeric values.
   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
   */
  DecimalNumber: any;
  /**
   * Represents fractional signed whole numeric values.
   * Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
   */
  DecimalNumberAsDiv: any;
  /** An ISO 8601-encoded date */
  ISO8601Date: any;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
};

export type AdditionalEntityFields = {
  path?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** Account */
export type Account = {
  __typename?: 'Account';
  /** Account ID */
  id: Scalars['String'];
  /** Account number, the equivalent of a human-friendly public key */
  num: Scalars['Int'];
  /** Realm number  */
  realmId: Scalars['Int'];
  /** Shard number */
  shardId: Scalars['Int'];
};

/** Solana Action */
export type Action = {
  __typename?: 'Action';
  name: Scalars['String'];
  type: Scalars['String'];
};

/** Blockchain address */
export type Address = {
  __typename?: 'Address';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
};

/** Address selector */
export type AddressSelector = {
  /** In the list of Addresses */
  in?: Maybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: Maybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: Maybe<Scalars['String']>;
  /** Not in the list of Addresses */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Address selector */
export type AddressSelectorIn = {
  /** In the list of Addresses */
  in?: Maybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: Maybe<Scalars['String']>;
};

/** Blockchain account with address and type */
export type AddressWithAccount = {
  __typename?: 'AddressWithAccount';
  /** Account ID */
  account: Scalars['String'];
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Account type */
  type: Scalars['String'];
};

/** Algorand Blockchain */
export type Algorand = {
  __typename?: 'Algorand';
  /** Basic information about address ( or smart contract ) */
  address: Array<AlgorandAddressInfo>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<AlgorandArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<AlgorandBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<AlgorandCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<AlgorandSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<AlgorandTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<AlgorandTransfers>>;
};


/** Algorand Blockchain */
export type AlgorandAddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Algorand Blockchain */
export type AlgorandArgumentsArgs = {
  any?: Maybe<Array<AlgorandArgumentFilter>>;
  argindex?: Maybe<ArgumentIndexSelector>;
  argument?: Maybe<Array<ArgumentSelector>>;
  caller?: Maybe<Array<AddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  reference?: Maybe<Array<AddressSelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<AddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txType?: Maybe<TxTypeSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Algorand Blockchain */
export type AlgorandBlocksArgs = {
  any?: Maybe<Array<AlgorandBlockFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  currentProtocol?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  nextProtocol?: Maybe<StringIdSelector>;
  options?: Maybe<QueryOptions>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Algorand Blockchain */
export type AlgorandCoinpathArgs = {
  currency?: Maybe<Array<AlgorandCurrencySelector>>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Algorand Blockchain */
export type AlgorandSmartContractCallsArgs = {
  any?: Maybe<Array<AlgorandSmartContractCallFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
};


/** Algorand Blockchain */
export type AlgorandTransactionsArgs = {
  any?: Maybe<Array<AlgorandTransactionFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  txCurrency?: Maybe<Array<AlgorandCurrencySelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txSubtype?: Maybe<TxSubtypeSelector>;
  txType?: Maybe<TxTypeSelector>;
};


/** Algorand Blockchain */
export type AlgorandTransfersArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<AlgorandTransferFilter>>;
  currency?: Maybe<Array<AlgorandCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<Array<AddressSelector>>;
  sender?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<AlgorandTransferTypeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
};

/** Address detailed information for Algorand network */
export type AlgorandAddressInfo = {
  __typename?: 'AlgorandAddressInfo';
  /** Address */
  address?: Maybe<Address>;
  /** Current address balance */
  balance?: Maybe<Scalars['Float']>;
  /** Current pending rewards */
  pendingRewards?: Maybe<Scalars['Float']>;
  /** Current rewards */
  rewards?: Maybe<Scalars['Float']>;
  /** Current round */
  round?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<AlgorandSmartContract>;
  /** Current status */
  status?: Maybe<Scalars['String']>;
};

export type AlgorandArgumentFilter = {
  argindex?: Maybe<ArgumentIndexSelector>;
  argument?: Maybe<Array<ArgumentSelector>>;
  caller?: Maybe<Array<AddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  reference?: Maybe<Array<AddressSelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<AddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txType?: Maybe<TxTypeSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls */
export type AlgorandArguments = {
  __typename?: 'AlgorandArguments';
  any?: Maybe<Scalars['String']>;
  /** Sequential index of value in array ( multi-dimensional) */
  argindex: Scalars['Int'];
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  firstRound?: Maybe<Scalars['Int']>;
  genesisHash64?: Maybe<Scalars['String']>;
  genesisId?: Maybe<Scalars['String']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<AlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<TransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<Address>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<AlgorandTxType>;
  /** The Value of argument */
  value?: Maybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsAnyArgs = {
  of: AlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsCountArgs = {
  argindex?: Maybe<ArgumentIndexSelector>;
  argument?: Maybe<Array<ArgumentSelector>>;
  caller?: Maybe<Array<AddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  reference?: Maybe<Array<AddressSelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<AddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsCountBigIntArgs = {
  argindex?: Maybe<ArgumentIndexSelector>;
  argument?: Maybe<Array<ArgumentSelector>>;
  caller?: Maybe<Array<AddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  reference?: Maybe<Array<AddressSelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<AddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsMaximumArgs = {
  get?: Maybe<AlgorandArgumentsMeasureable>;
  of: AlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsMinimumArgs = {
  get?: Maybe<AlgorandArgumentsMeasureable>;
  of: AlgorandArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsSmartContractArgs = {
  smartContractAddress?: Maybe<Array<AddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsTransactionArgs = {
  txFrom?: Maybe<Array<AddressSelector>>;
  txHash?: Maybe<Array<HashSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsTxSenderArgs = {
  txSender?: Maybe<Array<AddressSelector>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsTxTypeArgs = {
  txType?: Maybe<Array<AlgorandTxType>>;
};


/** Arguments of Smart Contract Calls */
export type AlgorandArgumentsValueArgs = {
  value?: Maybe<Array<ArgumentValueSelector>>;
};

export enum AlgorandArgumentsMeasureable {
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender',
  /** Transaction type */
  TxType = 'tx_type'
}

export type AlgorandBlockFilter = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  currentProtocol?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  nextProtocol?: Maybe<StringIdSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};

/** Blocks in Algorand blockchain */
export type AlgorandBlocks = {
  __typename?: 'AlgorandBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  currentProtocol?: Maybe<Scalars['String']>;
  /** Calendar date */
  date?: Maybe<Date>;
  frac: Scalars['BigInt'];
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  nextProtocol?: Maybe<Scalars['String']>;
  nextProtocolApprovals?: Maybe<Scalars['BigInt']>;
  nextProtocolSwitchOn?: Maybe<Scalars['BigInt']>;
  nextProtocolVoteBefore?: Maybe<Scalars['BigInt']>;
  /** Previous block hash */
  previousBlockHash: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Address>;
  rate?: Maybe<Scalars['Float']>;
  reward?: Maybe<Scalars['Float']>;
  seed?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  txnRoot: Scalars['String'];
  upgradeApprove?: Maybe<Scalars['Int']>;
  upgradePropose?: Maybe<Scalars['String']>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksAnyArgs = {
  of: AlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksCountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  currentProtocol?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  nextProtocol?: Maybe<StringIdSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<AlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  currentProtocol?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  nextProtocol?: Maybe<StringIdSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<AlgorandBlocksUniq>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksHashArgs = {
  blockHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksMaximumArgs = {
  get?: Maybe<AlgorandBlocksMeasureable>;
  of: AlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksMinimumArgs = {
  get?: Maybe<AlgorandBlocksMeasureable>;
  of: AlgorandBlocksMeasureable;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksProposerArgs = {
  proposer?: Maybe<Array<AddressSelector>>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksRateArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currentProtocol?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  nextProtocol?: Maybe<StringIdSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksRewardArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currentProtocol?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nextProtocol?: Maybe<StringIdSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Algorand blockchain */
export type AlgorandBlocksTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};

export enum AlgorandBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Block Reward */
  BlockReward = 'block_reward',
  /** Date */
  Date = 'date',
  /** Next protocol approvals */
  NextProtocolApprovals = 'next_protocol_approvals',
  /** Block Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time'
}

export enum AlgorandBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique proposer count */
  Proposers = 'proposers'
}

export enum AlgorandCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender',
  /** Transaction type */
  TxType = 'tx_type'
}

/** Coinpath */
export type AlgorandCoinpath = {
  __typename?: 'AlgorandCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
};


/** Coinpath */
export type AlgorandCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type AlgorandCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type AlgorandCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type AlgorandCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/**
 * Currency selector in Algorand blockchain.
 * Currency is selected by asset ID. To select ALGO use ID=0
 */
export type AlgorandCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Currency is */
  is?: Maybe<Scalars['Int']>;
  /** Currency not */
  not?: Maybe<Scalars['Int']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export enum AlgorandNetwork {
  /** Algorand Mainnet (ALGO) */
  Algorand = 'algorand',
  /** Algorand Betanet */
  AlgorandBetanet = 'algorand_betanet',
  /** Algorand Testnet */
  AlgorandTestnet = 'algorand_testnet'
}

/** Algorand smart contract */
export type AlgorandSmartContract = {
  __typename?: 'AlgorandSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract byte code */
  bytecode?: Maybe<Scalars['String']>;
  /** Smart Contract Deassembled source code */
  source?: Maybe<Scalars['String']>;
};

export type AlgorandSmartContractCallFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
};

/** Smart Contract Calls */
export type AlgorandSmartContractCalls = {
  __typename?: 'AlgorandSmartContractCalls';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Fee used in transaction call */
  fee?: Maybe<Scalars['Float']>;
  firstRound?: Maybe<Scalars['Int']>;
  genesisHash64?: Maybe<Scalars['String']>;
  genesisId?: Maybe<Scalars['String']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<AlgorandSmartContract>;
  /** Transaction where call happened */
  transaction?: Maybe<TransactionHashIndex>;
  /** Transaction sender */
  txSender?: Maybe<Address>;
  /** Transaction type in which the transfer happened */
  txType?: Maybe<AlgorandTxType>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsAnyArgs = {
  of: AlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsMaximumArgs = {
  get?: Maybe<AlgorandCallsMeasureable>;
  of: AlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsMinimumArgs = {
  get?: Maybe<AlgorandCallsMeasureable>;
  of: AlgorandCallsMeasureable;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsSmartContractArgs = {
  smartContractAddress?: Maybe<Array<AddressSelector>>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsTransactionArgs = {
  txFrom?: Maybe<Array<AddressSelector>>;
  txHash?: Maybe<Array<HashSelector>>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsTxSenderArgs = {
  txSender?: Maybe<Array<AddressSelector>>;
};


/** Smart Contract Calls */
export type AlgorandSmartContractCallsTxTypeArgs = {
  txType?: Maybe<Array<AlgorandTxType>>;
};

export type AlgorandTransactionFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txCurrency?: Maybe<Array<AlgorandCurrencySelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txSubtype?: Maybe<TxSubtypeSelector>;
  txType?: Maybe<TxTypeSelector>;
};

/** Algorand transaction with attributes */
export type AlgorandTransactionWithAttributes = {
  __typename?: 'AlgorandTransactionWithAttributes';
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']>;
  /** Transaction fee */
  fee?: Maybe<Scalars['Float']>;
  firstRound?: Maybe<Scalars['Int']>;
  /** Transaction rewards ( from )  */
  fromrewards?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  lastRound?: Maybe<Scalars['Int']>;
  lease?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Transfer transaction sender */
  sender?: Maybe<Address>;
  /** Transaction sub type */
  subtype?: Maybe<AlgorandTxSubType>;
  /** Transaction type in which the transfer happened */
  type?: Maybe<AlgorandTxType>;
};

/** Transactions in Algorand blockchain */
export type AlgorandTransactions = {
  __typename?: 'AlgorandTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Asset related to transaction */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  fee?: Maybe<Scalars['Float']>;
  firstRound?: Maybe<Scalars['Int']>;
  genesisHash?: Maybe<Scalars['String']>;
  genesisId?: Maybe<Scalars['String']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  poolerror?: Maybe<Scalars['String']>;
  /** Transaction sender */
  sender?: Maybe<Address>;
  /** Transaction sub type */
  subtype?: Maybe<AlgorandTxSubType>;
  /** Transaction type */
  type?: Maybe<AlgorandTxType>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsAnyArgs = {
  of: AlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txCurrency?: Maybe<Array<AlgorandCurrencySelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txSubtype?: Maybe<TxSubtypeSelector>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<AlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txCurrency?: Maybe<Array<AlgorandCurrencySelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txSubtype?: Maybe<TxSubtypeSelector>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<AlgorandTransactionsUniq>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsCurrencyArgs = {
  txCurrency?: Maybe<Array<AlgorandCurrencySelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  time?: Maybe<DateTimeSelector>;
  txCurrency?: Maybe<Array<AlgorandCurrencySelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txSubtype?: Maybe<TxSubtypeSelector>;
  txType?: Maybe<TxTypeSelector>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsHashArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsIndexArgs = {
  txIndex?: Maybe<Array<TxIndexSelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsMaximumArgs = {
  get?: Maybe<AlgorandTransactionsMeasureable>;
  of: AlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsMinimumArgs = {
  get?: Maybe<AlgorandTransactionsMeasureable>;
  of: AlgorandTransactionsMeasureable;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsSenderArgs = {
  txSender?: Maybe<Array<AddressSelector>>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsSubtypeArgs = {
  txType?: Maybe<TxSubtypeSelector>;
};


/** Transactions in Algorand blockchain */
export type AlgorandTransactionsTypeArgs = {
  txType?: Maybe<TxTypeSelector>;
};

export enum AlgorandTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Fee value */
  Fee = 'fee',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender'
}

export enum AlgorandTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique TX senders count */
  Senders = 'senders'
}

export type AlgorandTransferFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<AlgorandCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<Array<AddressSelector>>;
  sender?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<AlgorandTransferTypeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
};

export enum AlgorandTransferType {
  /** Close */
  Close = 'close',
  /** Create Asset */
  Create = 'create',
  /** Asset Freeze */
  Freeze = 'freeze',
  /** Genesis Block */
  Genesis = 'genesis',
  /** Reward */
  Reward = 'reward',
  /** Send */
  Send = 'send',
  /** Asset Unfreeze */
  Unfreeze = 'unfreeze'
}

/** Select transfers by type */
export type AlgorandTransferTypeSelector = {
  /** Transfer Type in the list */
  in?: Maybe<Array<AlgorandTransferType>>;
  /** Transfer Type is */
  is?: Maybe<AlgorandTransferType>;
  /** Transfer Type not */
  not?: Maybe<AlgorandTransferType>;
  /** Transfer Type not in the list */
  notIn?: Maybe<Array<AlgorandTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfers = {
  __typename?: 'AlgorandTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  firstRound?: Maybe<Scalars['Int']>;
  lastRound?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transaction where transfer happened */
  transaction?: Maybe<AlgorandTransactionWithAttributes>;
  /** Transfer Type */
  transferType?: Maybe<AlgorandTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<AlgorandCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<Array<AddressSelector>>;
  sender?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<AlgorandTransferTypeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersAnyArgs = {
  of: AlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<AlgorandCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<Array<AddressSelector>>;
  sender?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<AlgorandTransferTypeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<AlgorandCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<Array<AddressSelector>>;
  sender?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<AlgorandTransferTypeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<AddressSelector>>;
  txType?: Maybe<TxTypeSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersCurrencyArgs = {
  currency?: Maybe<Array<AlgorandCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersMaximumArgs = {
  get?: Maybe<AlgorandTransfersMeasureable>;
  of: AlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersMinimumArgs = {
  get?: Maybe<AlgorandTransfersMeasureable>;
  of: AlgorandTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersReceiverArgs = {
  receiver?: Maybe<Array<AddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersSenderArgs = {
  sender?: Maybe<Array<AddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersTransactionArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type AlgorandTransfersTransferTypeArgs = {
  transferType?: Maybe<Array<AlgorandTransferType>>;
};

export enum AlgorandTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Currency Asset ID */
  AssetId = 'asset_id',
  /** Block */
  Block = 'block',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transfer type */
  TransferType = 'transfer_type',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** TX Sender */
  TxSender = 'tx_sender',
  /** Transaction type */
  TxType = 'tx_type'
}

export enum AlgorandTxSubType {
  /** Close */
  Close = 'close',
  /** Asset Configuration */
  Configure = 'configure',
  /** Create */
  Create = 'create',
  /** Asset Freeze */
  Freeze = 'freeze',
  /** Key Reg */
  Keyreg = 'keyreg',
  /** None */
  None = 'none',
  /** Send */
  Send = 'send',
  /** Asset Unfreeze */
  Unfreeze = 'unfreeze'
}

export enum AlgorandTxType {
  /** Asset Configuration */
  Acfg = 'acfg',
  /** Asset Freeze or Unfreeze */
  Afrz = 'afrz',
  /** Application Call */
  Appl = 'appl',
  /** Asset Transfer */
  Axfer = 'axfer',
  /** Genesis Block */
  Genesis = 'genesis',
  /** Key Reg */
  Keyreg = 'keyreg',
  /** Pay */
  Pay = 'pay'
}

export enum AmountAggregateFunction {
  /** Any value */
  Any = 'any',
  /** Last value */
  AnyLast = 'anyLast',
  /** Average */
  Average = 'average',
  /** Maximum */
  Maximum = 'maximum',
  /** Median */
  Median = 'median',
  /** Minimum */
  Minimum = 'minimum',
  /** Sum (total) */
  Sum = 'sum',
  /** Unique estimate fast */
  Unique = 'unique',
  /** Unique exact */
  UniqueExact = 'uniqueExact'
}

/** Select by amount */
export type AmountSelector = {
  /** Amount in range */
  between?: Maybe<Array<Scalars['Float']>>;
  /** Amount greater than */
  gt?: Maybe<Scalars['Float']>;
  /** Amount greater or equal than */
  gteq?: Maybe<Scalars['Float']>;
  /** Amount in the list */
  in?: Maybe<Array<Scalars['Float']>>;
  /** Amount is */
  is?: Maybe<Scalars['Float']>;
  /** Amount less than */
  lt?: Maybe<Scalars['Float']>;
  /** Amount less or equal than */
  lteq?: Maybe<Scalars['Float']>;
  /** Amount not */
  not?: Maybe<Scalars['Float']>;
  /** Amount not in the list */
  notIn?: Maybe<Array<Scalars['Float']>>;
};

/** Selector of index of argument in call */
export type ArgumentIndexSelector = {
  /** Tx index in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Tx index is */
  is?: Maybe<Scalars['Int']>;
  /** Tx index not */
  not?: Maybe<Scalars['Int']>;
  /** Tx index not in the list */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

/** Argument of Smart contract method or event */
export type ArgumentName = {
  __typename?: 'ArgumentName';
  /** Name */
  name: Scalars['String'];
  /** Type */
  type: Scalars['String'];
};

/** Argument name and value of smart contract call or event */
export type ArgumentNameValue = {
  __typename?: 'ArgumentNameValue';
  /** Argument name */
  argument: Scalars['String'];
  /** Argument data type */
  argumentType: Scalars['String'];
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  /** Value as String */
  value: Scalars['String'];
};

/** Selector of argument for smart contract method or event */
export type ArgumentSelector = {
  /** Argument in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Argument is */
  is?: Maybe<Scalars['String']>;
  /** Argument not */
  not?: Maybe<Scalars['String']>;
  /** Argument not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Selector of argument type for smart contract method or event */
export type ArgumentTypeSelector = {
  /** Argument type in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Argument type is */
  is?: Maybe<Scalars['String']>;
  /** Argument type not */
  not?: Maybe<Scalars['String']>;
  /** Argument type not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Argument value of smart contract call or event */
export type ArgumentValue = {
  __typename?: 'ArgumentValue';
  /** Value as Address */
  address?: Maybe<EthereumAddressInfo>;
  /** Value as String */
  value: Scalars['String'];
};

/** Selector of value of argument for smart contract method or event */
export type ArgumentValueSelector = {
  /** Value in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Value is */
  is?: Maybe<Scalars['String']>;
  /** Value not */
  not?: Maybe<Scalars['String']>;
  /** Value not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

export enum BaseCurrencyEnum {
  /** Bitcoin */
  Btc = 'BTC',
  /** Ethereum */
  Eth = 'ETH',
  /** Dollar */
  Usd = 'USD',
  /** Tether USDT */
  Usdt = 'USDT'
}

/** Select by ID with BigInt datatype */
export type BigIntIdSelector = {
  /** ID in range */
  between?: Maybe<Array<Scalars['BigInt']>>;
  /** ID greater than */
  gt?: Maybe<Scalars['BigInt']>;
  /** ID greater or equal than */
  gteq?: Maybe<Scalars['BigInt']>;
  /** ID in the list */
  in?: Maybe<Array<Scalars['BigInt']>>;
  /** ID is */
  is?: Maybe<Scalars['BigInt']>;
  /** ID less than */
  lt?: Maybe<Scalars['BigInt']>;
  /** ID less or equal than */
  lteq?: Maybe<Scalars['BigInt']>;
  /** ID not */
  not?: Maybe<Scalars['BigInt']>;
  /** ID not in the list */
  notIn?: Maybe<Array<Scalars['BigInt']>>;
};

/** Binance DEX */
export type Binance = {
  __typename?: 'Binance';
  /** Binance DEX Network Blocks */
  blocks?: Maybe<Array<BinanceBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BinanceCoinpath>>;
  /** Binance DEX Network Exchange Orders */
  orders?: Maybe<Array<BinanceOrders>>;
  /** Binance DEX Network Trades between currencies */
  trades?: Maybe<Array<BinanceTrades>>;
  /** Binance DEX Network Transactions */
  transactions?: Maybe<Array<BinanceTransactions>>;
  /** Binance DEX Network Currency Transfers */
  transfers?: Maybe<Array<BinanceTransfers>>;
};


/** Binance DEX */
export type BinanceBlocksArgs = {
  any?: Maybe<Array<BinanceBlockFilter>>;
  blockId?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  validatorFeeAddr?: Maybe<BinanceAddressSelector>;
  validatorMoniker?: Maybe<StringIdSelector>;
  validatorOperahraddress?: Maybe<BinanceAddressSelector>;
  validatorOperatorAddress?: Maybe<BinanceAddressSelector>;
};


/** Binance DEX */
export type BinanceCoinpathArgs = {
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<BinanceAddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<BinanceAddressSelector>;
  sender?: Maybe<BinanceAddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Binance DEX */
export type BinanceOrdersArgs = {
  any?: Maybe<Array<BinanceOrderFilter>>;
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  orderOwner?: Maybe<Array<BinanceAddressSelector>>;
  orderSide?: Maybe<Array<OrderSideSelector>>;
  orderStatus?: Maybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: Maybe<Array<OrderTimeInForceSelector>>;
  orderType?: Maybe<Array<OrderTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Binance DEX */
export type BinanceTradesArgs = {
  any?: Maybe<Array<BinanceTradeFilter>>;
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: Maybe<Array<OrderIdSelector>>;
  buyer?: Maybe<Array<BinanceAddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: Maybe<Array<OrderIdSelector>>;
  seller?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Binance DEX */
export type BinanceTransactionsArgs = {
  any?: Maybe<Array<BinanceTransactionFilter>>;
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  deposit?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  proposalId?: Maybe<StringIdSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCode?: Maybe<IntIdSelector>;
  transactionSource?: Maybe<IntIdSelector>;
  transactionType?: Maybe<BinanceTransactionTypeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Binance DEX */
export type BinanceTransfersArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<BinanceTransferFilter>>;
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  outputIndex?: Maybe<Array<OutputIndexSelector>>;
  receiver?: Maybe<Array<BinanceAddressSelector>>;
  sender?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  transferType?: Maybe<Array<BinanceTransferTypeSelector>>;
  txHash?: Maybe<HashSelector>;
};

/** Binance Address should start with bnb and contain 42 chars. */
export type BinanceAddressSelector = {
  /** In the list of Addresses */
  in?: Maybe<Scalars['String']>;
  /** Equal to Address */
  is?: Maybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: Maybe<Scalars['String']>;
  /** Not in the list of Addresses */
  notIn?: Maybe<Scalars['String']>;
};

/** Block */
export type BinanceBlock = {
  __typename?: 'BinanceBlock';
  any?: Maybe<Scalars['String']>;
  /** Block ID */
  blockId?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Validator consensus pubkey */
  validatorConsensusPubkey?: Maybe<Scalars['String']>;
  /** Validator fee address */
  validatorFeeAddr?: Maybe<Address>;
  /** Validator moniker */
  validatorMoniker?: Maybe<Scalars['String']>;
  /** Validator operator HR address */
  validatorOperaHrAddress?: Maybe<Address>;
  /** Validator operator address */
  validatorOperatorAddress?: Maybe<Address>;
};


/** Block */
export type BinanceBlockAnyArgs = {
  of: BinanceBlocksMeasureable;
};


/** Block */
export type BinanceBlockBlockIdArgs = {
  blockId?: Maybe<StringIdSelector>;
};


/** Block */
export type BinanceBlockCountArgs = {
  blockId?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<BinanceBlockUniq>;
  validatorFeeAddr?: Maybe<BinanceAddressSelector>;
  validatorMoniker?: Maybe<StringIdSelector>;
  validatorOperahraddress?: Maybe<BinanceAddressSelector>;
  validatorOperatorAddress?: Maybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlockCountBigIntArgs = {
  blockId?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<BinanceBlockUniq>;
  validatorFeeAddr?: Maybe<BinanceAddressSelector>;
  validatorMoniker?: Maybe<StringIdSelector>;
  validatorOperahraddress?: Maybe<BinanceAddressSelector>;
  validatorOperatorAddress?: Maybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlockHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Block */
export type BinanceBlockMaximumArgs = {
  get?: Maybe<BinanceBlocksMeasureable>;
  of: BinanceBlocksMeasureable;
};


/** Block */
export type BinanceBlockMinimumArgs = {
  get?: Maybe<BinanceBlocksMeasureable>;
  of: BinanceBlocksMeasureable;
};


/** Block */
export type BinanceBlockTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type BinanceBlockValidatorConsensusPubkeyArgs = {
  validatorConsensusPubkey?: Maybe<StringIdSelector>;
};


/** Block */
export type BinanceBlockValidatorFeeAddrArgs = {
  validatorFeeAddr?: Maybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlockValidatorMonikerArgs = {
  validatorMoniker?: Maybe<StringIdSelector>;
};


/** Block */
export type BinanceBlockValidatorOperaHrAddressArgs = {
  validatorOperaHrAddress?: Maybe<BinanceAddressSelector>;
};


/** Block */
export type BinanceBlockValidatorOperatorAddressArgs = {
  validatorOperatorAddress?: Maybe<BinanceAddressSelector>;
};

export type BinanceBlockFilter = {
  blockId?: Maybe<StringIdSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  validatorFeeAddr?: Maybe<BinanceAddressSelector>;
  validatorMoniker?: Maybe<StringIdSelector>;
  validatorOperahraddress?: Maybe<BinanceAddressSelector>;
  validatorOperatorAddress?: Maybe<BinanceAddressSelector>;
};

export enum BinanceBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Validator fee addresses */
  ValidatorFeeAddresses = 'validator_fee_addresses',
  /** Validator operators */
  ValidatorOperatorAddresses = 'validator_operator_addresses'
}

export enum BinanceBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator moniker */
  ValidatorMoniker = 'validator_moniker'
}

/** Coinpath */
export type BinanceCoinpath = {
  __typename?: 'BinanceCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
};


/** Coinpath */
export type BinanceCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type BinanceCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BinanceCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BinanceCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/**
 * Binance token selector by tokenId.
 * Native binance token has BNB symbol.
 * Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
 */
export type BinanceCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

export type BinanceOrderFilter = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  orderOwner?: Maybe<Array<BinanceAddressSelector>>;
  orderSide?: Maybe<Array<OrderSideSelector>>;
  orderStatus?: Maybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: Maybe<Array<OrderTimeInForceSelector>>;
  orderType?: Maybe<Array<OrderTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};

export enum BinanceOrderSide {
  /** Buy Side */
  Buy = 'buy',
  /** Sell Side */
  Sell = 'sell'
}

export enum BinanceOrderStatus {
  /** Ack */
  Ack = 'Ack',
  /** Canceled */
  Canceled = 'Canceled',
  /** Expired */
  Expired = 'Expired',
  /** Failed Blocking */
  FailedBlocking = 'FailedBlocking',
  /** Fully Fill */
  FullyFill = 'FullyFill',
  /** Ioc Expire */
  IocExpire = 'IocExpire',
  /** Ioc No Fill */
  IocNoFill = 'IocNoFill',
  /** Partial Fill */
  PartialFill = 'PartialFill'
}

export enum BinanceOrderTimeInForce {
  /** Good Till Expiry */
  Gte = 'GTE',
  /** Immediate Or Cancel */
  Ioc = 'IOC'
}

export enum BinanceOrderType {
  /** Limit Order */
  LimitOrder = 'LimitOrder'
}

/** Binance DEX Order */
export type BinanceOrders = {
  __typename?: 'BinanceOrders';
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  baseCurrency?: Maybe<Currency>;
  /** Block where order transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Order ID */
  orderId?: Maybe<Scalars['String']>;
  /** Order owner address */
  orderOwner?: Maybe<Address>;
  /** Order Side */
  orderSide?: Maybe<BinanceOrderSide>;
  /** Order Status */
  orderStatus?: Maybe<BinanceOrderStatus>;
  /** Order Time In Force */
  orderTimeInForce?: Maybe<BinanceOrderTimeInForce>;
  /** Order Type */
  orderType?: Maybe<BinanceOrderType>;
  price?: Maybe<Scalars['Float']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  quoteCurrency?: Maybe<Currency>;
  /** Transaction where order created */
  transaction?: Maybe<TransactionHash>;
};


/** Binance DEX Order */
export type BinanceOrdersAnyArgs = {
  of: BinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BinanceOrdersBaseAmountArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  orderOwner?: Maybe<Array<BinanceAddressSelector>>;
  orderSide?: Maybe<Array<OrderSideSelector>>;
  orderStatus?: Maybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: Maybe<Array<OrderTimeInForceSelector>>;
  orderType?: Maybe<Array<OrderTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Binance DEX Order */
export type BinanceOrdersBaseCurrencyArgs = {
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Binance DEX Order */
export type BinanceOrdersCountArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  orderOwner?: Maybe<Array<BinanceAddressSelector>>;
  orderSide?: Maybe<Array<OrderSideSelector>>;
  orderStatus?: Maybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: Maybe<Array<OrderTimeInForceSelector>>;
  orderType?: Maybe<Array<OrderTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<BinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BinanceOrdersCountBigIntArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  orderOwner?: Maybe<Array<BinanceAddressSelector>>;
  orderSide?: Maybe<Array<OrderSideSelector>>;
  orderStatus?: Maybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: Maybe<Array<OrderTimeInForceSelector>>;
  orderType?: Maybe<Array<OrderTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<BinanceOrdersUniq>;
};


/** Binance DEX Order */
export type BinanceOrdersMaximumArgs = {
  get?: Maybe<BinanceOrdersMeasureable>;
  of: BinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BinanceOrdersMinimumArgs = {
  get?: Maybe<BinanceOrdersMeasureable>;
  of: BinanceOrdersMeasureable;
};


/** Binance DEX Order */
export type BinanceOrdersOrderIdArgs = {
  orderId?: Maybe<Array<OrderIdSelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersOrderOwnerArgs = {
  owner?: Maybe<Array<BinanceAddressSelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersOrderSideArgs = {
  orderSide?: Maybe<Array<OrderSideSelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersOrderStatusArgs = {
  orderStatus?: Maybe<Array<OrderStatusSelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersOrderTimeInForceArgs = {
  orderTimeInForce?: Maybe<Array<OrderTimeInForceSelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersOrderTypeArgs = {
  orderType?: Maybe<Array<OrderTypeSelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersQuoteAmountArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  orderOwner?: Maybe<Array<BinanceAddressSelector>>;
  orderSide?: Maybe<Array<OrderSideSelector>>;
  orderStatus?: Maybe<Array<OrderStatusSelector>>;
  orderTimeInForce?: Maybe<Array<OrderTimeInForceSelector>>;
  orderType?: Maybe<Array<OrderTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Binance DEX Order */
export type BinanceOrdersQuoteCurrencyArgs = {
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Order */
export type BinanceOrdersTransactionArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};

export enum BinanceOrdersMeasureable {
  /** Base Amount */
  BaseAmount = 'base_amount',
  /** Base currency */
  BaseCurrency = 'base_currency',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Order ID */
  OrderId = 'order_id',
  /** Order owner */
  OrderOwner = 'order_owner',
  /** Order side */
  OrderSide = 'order_side',
  /** Order status */
  OrderStatus = 'order_status',
  /** Price */
  Price = 'price',
  /** Quote Amount */
  QuoteAmount = 'quote_amount',
  /** Quote currency */
  QuoteCurrency = 'quote_currency',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BinanceOrdersUniq {
  /** Unique base currencies */
  BaseCurrencies = 'base_currencies',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique order ID count */
  Orders = 'orders',
  /** Unique order owners */
  Owners = 'owners',
  /** Unique quote currencies */
  QuoteCurrencies = 'quote_currencies',
  /** Unique Transactions */
  Txs = 'txs'
}

export type BinanceTradeFilter = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: Maybe<Array<OrderIdSelector>>;
  buyer?: Maybe<Array<BinanceAddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: Maybe<Array<OrderIdSelector>>;
  seller?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  txHash?: Maybe<HashSelector>;
};

/** Binance DEX Trades */
export type BinanceTrades = {
  __typename?: 'BinanceTrades';
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  baseCurrency?: Maybe<Currency>;
  /** Block where trade transaction is included */
  block?: Maybe<Block>;
  /** Buy Order ID */
  buyOrderId?: Maybe<Scalars['String']>;
  /** Trade buyer address */
  buyer?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Float']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  quoteCurrency?: Maybe<Currency>;
  /** Sell Order ID */
  sellOrderId?: Maybe<Scalars['String']>;
  /** Trade seller address */
  seller?: Maybe<Address>;
  /** Trade ID */
  tradeId?: Maybe<Scalars['String']>;
  /** Transaction where trade happened */
  transaction?: Maybe<TransactionHashIndex>;
};


/** Binance DEX Trades */
export type BinanceTradesAnyArgs = {
  of: BinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BinanceTradesBaseAmountArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: Maybe<Array<OrderIdSelector>>;
  buyer?: Maybe<Array<BinanceAddressSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: Maybe<Array<OrderIdSelector>>;
  seller?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Binance DEX Trades */
export type BinanceTradesBaseCurrencyArgs = {
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BinanceTradesBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Binance DEX Trades */
export type BinanceTradesBuyOrderIdArgs = {
  buyOrderId?: Maybe<Array<OrderIdSelector>>;
};


/** Binance DEX Trades */
export type BinanceTradesBuyerArgs = {
  buyer?: Maybe<Array<BinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BinanceTradesCountArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: Maybe<Array<OrderIdSelector>>;
  buyer?: Maybe<Array<BinanceAddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: Maybe<Array<OrderIdSelector>>;
  seller?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<BinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BinanceTradesCountBigIntArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: Maybe<Array<OrderIdSelector>>;
  buyer?: Maybe<Array<BinanceAddressSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: Maybe<Array<OrderIdSelector>>;
  seller?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<BinanceTradesUniq>;
};


/** Binance DEX Trades */
export type BinanceTradesMaximumArgs = {
  get?: Maybe<BinanceTradesMeasureable>;
  of: BinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BinanceTradesMinimumArgs = {
  get?: Maybe<BinanceTradesMeasureable>;
  of: BinanceTradesMeasureable;
};


/** Binance DEX Trades */
export type BinanceTradesQuoteAmountArgs = {
  baseAmount?: Maybe<Array<AmountSelector>>;
  baseCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  buyOrderId?: Maybe<Array<OrderIdSelector>>;
  buyer?: Maybe<Array<BinanceAddressSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  price?: Maybe<Array<AmountSelector>>;
  quoteAmount?: Maybe<Array<AmountSelector>>;
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
  sellOrderId?: Maybe<Array<OrderIdSelector>>;
  seller?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Binance DEX Trades */
export type BinanceTradesQuoteCurrencyArgs = {
  quoteCurrency?: Maybe<Array<BinanceCurrencySelector>>;
};


/** Binance DEX Trades */
export type BinanceTradesSellOrderIdArgs = {
  sellOrderId?: Maybe<Array<OrderIdSelector>>;
};


/** Binance DEX Trades */
export type BinanceTradesSellerArgs = {
  seller?: Maybe<Array<BinanceAddressSelector>>;
};


/** Binance DEX Trades */
export type BinanceTradesTradeIdArgs = {
  tradeId?: Maybe<Array<TradeIdSelector>>;
};


/** Binance DEX Trades */
export type BinanceTradesTransactionArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};

export enum BinanceTradesMeasureable {
  /** Base Amount */
  BaseAmount = 'base_amount',
  /** Base currency */
  BaseCurrency = 'base_currency',
  /** Block */
  Block = 'block',
  /** Buy Order ID */
  BuyOrderId = 'buy_order_id',
  /** Buyer */
  Buyer = 'buyer',
  /** Date */
  Date = 'date',
  /** Price */
  Price = 'price',
  /** Quote Amount */
  QuoteAmount = 'quote_amount',
  /** Quote currency */
  QuoteCurrency = 'quote_currency',
  /** Sell Order ID */
  SellOrderId = 'sell_order_id',
  /** Seller */
  Seller = 'seller',
  /** Time */
  Time = 'time',
  /** Trade ID */
  TradeId = 'trade_id',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BinanceTradesUniq {
  /** Unique base currencies */
  BaseCurrencies = 'base_currencies',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy Orders */
  BuyOrders = 'buy_orders',
  /** Unique buyers count */
  Buyers = 'buyers',
  /** Unique date count */
  Dates = 'dates',
  /** Unique quote currencies */
  QuoteCurrencies = 'quote_currencies',
  /** Sell Orders */
  SellOrders = 'sell_orders',
  /** Unique sellers count */
  Sellers = 'sellers',
  /** Trades */
  Trades = 'trades',
  /** Unique Transactions */
  Txs = 'txs'
}

export type BinanceTransactionFilter = {
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  deposit?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  proposalId?: Maybe<StringIdSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCode?: Maybe<IntIdSelector>;
  transactionSource?: Maybe<IntIdSelector>;
  transactionType?: Maybe<BinanceTransactionTypeSelector>;
  txHash?: Maybe<HashSelector>;
};

export enum BinanceTransactionType {
  /** Bind */
  Bind = 'BIND',
  /** Submit evidence */
  BscSubmitEvidence = 'BSC_SUBMIT_EVIDENCE',
  /** Burn */
  Burn = 'BURN',
  /** Cancel Order */
  CancelOrder = 'CANCEL_ORDER',
  /** Cross chain claim */
  Claim = 'CLAIM',
  /** Hash Timer Locked Claim */
  ClaimHtl = 'CLAIM_HTL',
  /** Create sidechain validator */
  CreateSidechainValidator = 'CREATE_SIDECHAIN_VALIDATOR',
  /** Deposit */
  Deposit = 'DEPOSIT',
  /** Hash Timer Locked Deposit */
  DepositHtl = 'DEPOSIT_HTL',
  /** Edit sidechain validator */
  EditSidechainValidator = 'EDIT_SIDECHAIN_VALIDATOR',
  /** Freeze Token */
  FreezeToken = 'FREEZE_TOKEN',
  /** Hash Timer Locked Transfer */
  HtlTransfer = 'HTL_TRANSFER',
  /** Issue */
  Issue = 'ISSUE',
  /** Listing */
  Listing = 'LISTING',
  /** Mini Token Issue */
  MiniTokenIssue = 'MINI_TOKEN_ISSUE',
  /** Mini Token Listing */
  MiniTokenList = 'MINI_TOKEN_LIST',
  /** Mini Token Set URI */
  MiniTokenSetUri = 'MINI_TOKEN_SET_URI',
  /** Mint */
  Mint = 'MINT',
  /** New Order */
  NewOrder = 'NEW_ORDER',
  /** Hash Timer Locked  Refund */
  RefundHtl = 'REFUND_HTL',
  /** Delegate for sidechain */
  SidechainDelegate = 'SIDECHAIN_DELEGATE',
  /** ReDelegate for sidechain */
  SidechainRedelegate = 'SIDECHAIN_REDELEGATE',
  /** Unbond from sidechain */
  SidechainUnbond = 'SIDECHAIN_UNBOND',
  /** Unjail from sidechain */
  SidechainUnjail = 'SIDECHAIN_UNJAIL',
  /** Side chain deposit */
  SideDeposit = 'SIDE_DEPOSIT',
  /** Side chain submit poroposal */
  SideSubmitProposal = 'SIDE_SUBMIT_PROPOSAL',
  /** Side chain vote */
  SideVote = 'SIDE_VOTE',
  /** Submit Proposal */
  SubmitProposal = 'SUBMIT_PROPOSAL',
  /** Set Account Flag */
  SetAccountFlag = 'SetAccountFlag',
  /** Tiny Token Issue */
  TinyTokenIssue = 'TINY_TOKEN_ISSUE',
  /** Tiny Token Listing */
  TinyTokenList = 'TINY_TOKEN_LIST',
  /** Tiny Token Set URI */
  TinyTokenSetUri = 'TINY_TOKEN_SET_URI',
  /** Transfer */
  Transfer = 'TRANSFER',
  /** Cross chain transfer */
  TransferOut = 'TRANSFER_OUT',
  /** Time Lock */
  TimeLock = 'TimeLock',
  /** Time Relock */
  TimeRelock = 'TimeRelock',
  /** Time Unlock */
  TimeUnlock = 'TimeUnlock',
  /** UnBind */
  Unbind = 'UNBIND',
  /** Unfreeze Token */
  UnfreezeToken = 'UNFREEZE_TOKEN',
  /** Vote */
  Vote = 'VOTE'
}

/** Select by transaction type */
export type BinanceTransactionTypeSelector = {
  /** Transaction Type in the list */
  in?: Maybe<Array<BinanceTransactionType>>;
  /** Transaction Type is */
  is?: Maybe<BinanceTransactionType>;
  /** Transaction Type not */
  not?: Maybe<BinanceTransactionType>;
  /** Transaction Type not in the list */
  notIn?: Maybe<Array<BinanceTransactionType>>;
};

/** Transaction */
export type BinanceTransactions = {
  __typename?: 'BinanceTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency issued in transaction */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Deposit amount in transaction */
  deposit?: Maybe<Scalars['Float']>;
  /** Transaction Description */
  description?: Maybe<Scalars['String']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** TX index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  /** Transaction Log */
  log?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Transaction Memo */
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Proposal ID */
  proposalId?: Maybe<Scalars['Int']>;
  /** Transaction Type */
  transactionCode?: Maybe<Scalars['Int']>;
  /** Transaction Source */
  transactionSource?: Maybe<TransactionSource>;
  /** Transaction Type */
  transactionType?: Maybe<BinanceTransactionType>;
};


/** Transaction */
export type BinanceTransactionsAnyArgs = {
  of: BinanceTransactionsMeasureable;
};


/** Transaction */
export type BinanceTransactionsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction */
export type BinanceTransactionsCountArgs = {
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  deposit?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  proposalId?: Maybe<StringIdSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCode?: Maybe<IntIdSelector>;
  transactionSource?: Maybe<IntIdSelector>;
  transactionType?: Maybe<BinanceTransactionTypeSelector>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<BinanceTransactionsUniq>;
};


/** Transaction */
export type BinanceTransactionsCountBigIntArgs = {
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  deposit?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  proposalId?: Maybe<StringIdSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCode?: Maybe<IntIdSelector>;
  transactionSource?: Maybe<IntIdSelector>;
  transactionType?: Maybe<BinanceTransactionTypeSelector>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<BinanceTransactionsUniq>;
};


/** Transaction */
export type BinanceTransactionsCurrencyArgs = {
  currency?: Maybe<Array<BinanceCurrencySelector>>;
};


/** Transaction */
export type BinanceTransactionsDepositArgs = {
  deposit?: Maybe<Array<AmountSelector>>;
};


/** Transaction */
export type BinanceTransactionsHashArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Transaction */
export type BinanceTransactionsMaximumArgs = {
  get?: Maybe<BinanceTransactionsMeasureable>;
  of: BinanceTransactionsMeasureable;
};


/** Transaction */
export type BinanceTransactionsMinimumArgs = {
  get?: Maybe<BinanceTransactionsMeasureable>;
  of: BinanceTransactionsMeasureable;
};


/** Transaction */
export type BinanceTransactionsProposalIdArgs = {
  proposalId?: Maybe<Array<IntIdSelector>>;
};


/** Transaction */
export type BinanceTransactionsTransactionCodeArgs = {
  transactionCode?: Maybe<IntIdSelector>;
};


/** Transaction */
export type BinanceTransactionsTransactionSourceArgs = {
  transactionSource?: Maybe<IntIdSelector>;
};


/** Transaction */
export type BinanceTransactionsTransactionTypeArgs = {
  transactionType?: Maybe<Array<BinanceTransactionTypeSelector>>;
};

export enum BinanceTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Currency */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transaction Code */
  TransactionCode = 'transaction_code',
  /** Transaction Memo */
  TransactionMemo = 'transaction_memo',
  /** Transaction Source Code */
  TransactionSourceCode = 'transaction_source_code',
  /** Transaction Source Name */
  TransactionSourceName = 'transaction_source_name',
  /** Transaction Type */
  TransactionType = 'transaction_type',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum BinanceTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction source count */
  TransactionSources = 'transaction_sources'
}

export type BinanceTransferFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  outputIndex?: Maybe<Array<OutputIndexSelector>>;
  receiver?: Maybe<Array<BinanceAddressSelector>>;
  sender?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  transferType?: Maybe<Array<BinanceTransferTypeSelector>>;
  txHash?: Maybe<HashSelector>;
};

export enum BinanceTransferType {
  /** Bind */
  Bind = 'BIND',
  /** Reward for block */
  BlockReward = 'BLOCK_REWARD',
  /** Submit evidence */
  BscSubmitEvidence = 'BSC_SUBMIT_EVIDENCE',
  /** Burning amount */
  Burn = 'BURN',
  /** Cross chain claim */
  Claim = 'CLAIM',
  /** Claiming Hash Timer Locked Transfer */
  ClaimHtl = 'CLAIM_HTL',
  /** Create sidechain validator */
  CreateSidechainValidator = 'CREATE_SIDECHAIN_VALIDATOR',
  /** Deposit for Hash Timer Locked Transfer */
  DepositHtl = 'DEPOSIT_HTL',
  /** Fee for DEX orders */
  DexFee = 'DEX_FEE',
  /** Edit sidechain validator */
  EditSidechainValidator = 'EDIT_SIDECHAIN_VALIDATOR',
  /** Genesis declaration */
  GenesisDelegation = 'GENESIS_DELEGATION',
  /** Genesis supply declaration */
  GenesisSupply = 'GENESIS_SUPPLY',
  /** Hash Timer Locked Transfer */
  HtlTransfer = 'HTL_TRANSFER',
  /** Issue token */
  Issue = 'ISSUE',
  /** Mini Token Issue */
  MiniTokenIssue = 'MINI_TOKEN_ISSUE',
  /** Mint token */
  Mint = 'MINT',
  /** Delegate for sidechain */
  SidechainDelegate = 'SIDECHAIN_DELEGATE',
  /** ReDelegate for sidechain */
  SidechainRedelegate = 'SIDECHAIN_REDELEGATE',
  /** Unbond from sidechain */
  SidechainUnbond = 'SIDECHAIN_UNBOND',
  /** Side chain deposit */
  SideDeposit = 'SIDE_DEPOSIT',
  /** Side chain submit poroposal */
  SideSubmitProposal = 'SIDE_SUBMIT_PROPOSAL',
  /** Side chain vote */
  SideVote = 'SIDE_VOTE',
  /** Tiny Token Issue */
  TinyTokenIssue = 'TINY_TOKEN_ISSUE',
  /** Trade buy side */
  TradeBuy = 'TRADE_BUY',
  /** Trade sell side */
  TradeSell = 'TRADE_SELL',
  /** Transfer */
  Transfer = 'TRANSFER',
  /** Cross chain transfer */
  TransferOut = 'TRANSFER_OUT',
  /** Transaction fee */
  TxFee = 'TX_FEE',
  /** UnBind */
  Unbind = 'UNBIND'
}

/** Select transfer type(s) */
export type BinanceTransferTypeSelector = {
  /** Transfer type in the list */
  in?: Maybe<Array<BinanceTransferType>>;
  /** Transfer type is */
  is?: Maybe<BinanceTransferType>;
  /** Transfer type not */
  not?: Maybe<BinanceTransferType>;
  /** Transfer type not in the list */
  notIn?: Maybe<Array<BinanceTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfers = {
  __typename?: 'BinanceTransfers';
  /** Transfer amount */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  /** Transfer count */
  count?: Maybe<Scalars['Int']>;
  /** Transfer count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Order Id of trade where transfer happened */
  orderId?: Maybe<Scalars['String']>;
  /** Index of the output for the transfer, 0-based */
  outputIndex?: Maybe<Scalars['Int']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Id of trade where transfer happened */
  tradeId?: Maybe<Scalars['String']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<TransactionHashIndex>;
  /** Transfer type */
  transferType?: Maybe<BinanceTransferType>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  outputIndex?: Maybe<Array<OutputIndexSelector>>;
  receiver?: Maybe<Array<BinanceAddressSelector>>;
  sender?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  transferType?: Maybe<Array<BinanceTransferTypeSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersAnyArgs = {
  of: BinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  outputIndex?: Maybe<Array<OutputIndexSelector>>;
  receiver?: Maybe<Array<BinanceAddressSelector>>;
  sender?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  transferType?: Maybe<Array<BinanceTransferTypeSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<BinanceCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  orderId?: Maybe<Array<OrderIdSelector>>;
  outputIndex?: Maybe<Array<OutputIndexSelector>>;
  receiver?: Maybe<Array<BinanceAddressSelector>>;
  sender?: Maybe<Array<BinanceAddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeId?: Maybe<Array<TradeIdSelector>>;
  transferType?: Maybe<Array<BinanceTransferTypeSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersCurrencyArgs = {
  currency?: Maybe<Array<BinanceCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersMaximumArgs = {
  get?: Maybe<BinanceTransfersMeasureable>;
  of: BinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersMinimumArgs = {
  get?: Maybe<BinanceTransfersMeasureable>;
  of: BinanceTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersOrderIdArgs = {
  orderId?: Maybe<Array<OrderIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersOutputIndexArgs = {
  outputIndex?: Maybe<Array<OutputIndexSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersReceiverArgs = {
  receiver?: Maybe<Array<BinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersSenderArgs = {
  sender?: Maybe<Array<BinanceAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersTradeIdArgs = {
  tradeId?: Maybe<Array<TradeIdSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersTransactionArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type BinanceTransfersTransferTypeArgs = {
  transferType?: Maybe<Array<BinanceTransferTypeSelector>>;
};

export enum BinanceTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Bitcoin and other UTXO type blockchains */
export type Bitcoin = {
  __typename?: 'Bitcoin';
  /** Blockchain Blocks */
  blocks?: Maybe<Array<BitcoinBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<BitcoinCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<BitcoinTransactionInput>>;
  /** Blockchain Transaction OmniTransactions */
  omniTransactions?: Maybe<Array<BitcoinOmniTransactiosn>>;
  /** Blockchain Transaction OmniTransfers */
  omniTransfers?: Maybe<Array<BitcoinOmniTransfers>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<BitcoinTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<BitcoinTransaction>>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitcoinBlocksArgs = {
  any?: Maybe<Array<BitcoinBlockFilter>>;
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockStrippedSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  blockWeight?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  difficulty?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitcoinCoinpathArgs = {
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<BitcoinCoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitcoinInputsArgs = {
  any?: Maybe<Array<BitcoinInputFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
  inputValue?: Maybe<FloatSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitcoinOmniTransactionsArgs = {
  any?: Maybe<Array<BitcoinOmniTransactionsFilter>>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitcoinOmniTransfersArgs = {
  any?: Maybe<Array<BitcoinOmniTransfersFilter>>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitcoinOutputsArgs = {
  any?: Maybe<Array<BitcoinOutputFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<BitcoinOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputScriptType?: Maybe<BitcoinOutputScriptTypeSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Bitcoin and other UTXO type blockchains */
export type BitcoinTransactionsArgs = {
  any?: Maybe<Array<BitcoinTransactionFilter>>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  options?: Maybe<QueryOptions>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};

/** Block */
export type BitcoinBlock = {
  __typename?: 'BitcoinBlock';
  any?: Maybe<Scalars['String']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']>;
  /** Block stripped size */
  blockStrippedSize?: Maybe<Scalars['Int']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']>;
  /** Block weight */
  blockWeight?: Maybe<Scalars['Int']>;
  /** Block chainwork */
  chainwork?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['Float']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  /** Block median timestamp */
  medianTime?: Maybe<DateTime>;
  minimum?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']>;
};


/** Block */
export type BitcoinBlockAnyArgs = {
  of: BitcoinBlocksMeasureable;
};


/** Block */
export type BitcoinBlockBlockHashArgs = {
  blockHash?: Maybe<StringIdSelector>;
};


/** Block */
export type BitcoinBlockBlockSizeArgs = {
  blockSize?: Maybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlockBlockStrippedSizeArgs = {
  blockStrippedSize?: Maybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlockBlockVersionArgs = {
  blockVersion?: Maybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlockBlockWeightArgs = {
  blockWeight?: Maybe<IntegerSelector>;
};


/** Block */
export type BitcoinBlockCountArgs = {
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockStrippedSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  blockWeight?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  difficulty?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txCount?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinBlockUniq>;
};


/** Block */
export type BitcoinBlockCountBigIntArgs = {
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockStrippedSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  blockWeight?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  difficulty?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txCount?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinBlockUniq>;
};


/** Block */
export type BitcoinBlockDifficultyArgs = {
  difficulty?: Maybe<FloatSelector>;
};


/** Block */
export type BitcoinBlockHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Block */
export type BitcoinBlockMaximumArgs = {
  get?: Maybe<BitcoinBlocksMeasureable>;
  of: BitcoinBlocksMeasureable;
};


/** Block */
export type BitcoinBlockMinimumArgs = {
  get?: Maybe<BitcoinBlocksMeasureable>;
  of: BitcoinBlocksMeasureable;
};


/** Block */
export type BitcoinBlockTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type BitcoinBlockTransactionCountArgs = {
  transactionCount?: Maybe<IntegerSelector>;
};

export type BitcoinBlockFilter = {
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockStrippedSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  blockWeight?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  difficulty?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};

export enum BitcoinBlockUniq {
  /** Unique date count */
  Dates = 'dates'
}

export enum BitcoinBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Tx Count */
  TransactionCount = 'transaction_count'
}

/** Coinpath */
export type BitcoinCoinpath = {
  __typename?: 'BitcoinCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<BitcoinTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type BitcoinCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type BitcoinCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BitcoinCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type BitcoinCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

export enum BitcoinCoinpathMethod {
  /** Tracking money flow by amounts, ignoring coins (default) */
  Moneyflow = 'moneyflow',
  /** Tracking coins by UTXO transactions */
  Utxo = 'utxo'
}

/** Limits, Ordering, Constraints, Coinpath Options */
export type BitcoinCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: Maybe<Array<Scalars['String']>>;
  /** Method to use coinpath */
  coinpathMethod?: Maybe<BitcoinCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: Maybe<Scalars['Int']>;
  /** Ordering field(s) for descending */
  desc?: Maybe<Array<Scalars['String']>>;
  /** Flow direction */
  direction?: Maybe<FlowDirection>;
  /** Limit number of results */
  limit?: Maybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: Maybe<LimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: Maybe<Scalars['Int']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: Maybe<Scalars['Int']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: Maybe<Scalars['Float']>;
  /** Offset of results, starting from 0 */
  offset?: Maybe<Scalars['Int']>;
  /** Invalidating cache seed */
  seed?: Maybe<Scalars['Int']>;
};

export type BitcoinInputFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

export enum BitcoinInputScriptType {
  /** Input Script Coinbase Script */
  Coinbase = 'coinbase',
  /** Input Script Signature */
  ScriptSig = 'scriptSig',
  /** Input Script TX Witness Script */
  Txinwitness = 'txinwitness'
}

/** Selector of input script type */
export type BitcoinInputScriptTypeSelector = {
  /** In the list of Script Type */
  in?: Maybe<Array<BitcoinInputScriptType>>;
  /** Equal to Script Type */
  is?: Maybe<BitcoinInputScriptType>;
  /** Not Equal to Script Type */
  not?: Maybe<BitcoinInputScriptType>;
  /** Not in the list of Script Type */
  notIn?: Maybe<Array<BitcoinInputScriptType>>;
};

export enum BitcoinInputUniq {
  /** Unique addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum BitcoinInputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Input index */
  InputIndex = 'input_index',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

export enum BitcoinNetwork {
  /** Bitcoin Cash ( BCH ) */
  Bitcash = 'bitcash',
  /** Bitcoin ( BTC ) */
  Bitcoin = 'bitcoin',
  /** Bitcoin SV ( BSV ) */
  Bitcoinsv = 'bitcoinsv',
  /** Dash ( DASH ) */
  Dash = 'dash',
  /** Dogecoin ( DOGE ) */
  Dogecoin = 'dogecoin',
  /** Litecoin ( LTC ) */
  Litecoin = 'litecoin',
  /** ZCash ( ZCASH ) */
  Zcash = 'zcash'
}

export type BitcoinOmniTransactionsFilter = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};

export enum BitcoinOmniTransactionsMeasureablse {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transactions hash */
  TxHash = 'tx_hash',
  /** Transactions index */
  TxIndex = 'tx_index'
}

export enum BitcoinOmniTransactionsUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction sender */
  TxSender = 'tx_sender'
}

/** OmniTransactions */
export type BitcoinOmniTransactiosn = {
  __typename?: 'BitcoinOmniTransactiosn';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Hash of the block */
  blockHash: Scalars['String'];
  /** OmniTransaction s count */
  count?: Maybe<Scalars['Int']>;
  /** OmniTransaction s count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** OmniTransactions index in block, 0-based */
  index: Scalars['String'];
  /** Invalid Reason */
  invalidReason: Scalars['String'];
  /** Invalid Reason */
  json: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction Sender */
  txSender: Scalars['String'];
  /** Type */
  type: Scalars['String'];
  /** Type Int */
  typeInt: Scalars['Int'];
  /** Version */
  valid: Scalars['Int'];
  /** Version */
  version: Scalars['Int'];
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnAnyArgs = {
  of: BitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnCountArgs = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinOmniTransactionsUniq>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinOmniTransactionsUniq>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnFeeValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnHashArgs = {
  txHash?: Maybe<StringIdSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnIndexArgs = {
  txIndex?: Maybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnInvalidReasonArgs = {
  invalidReason?: Maybe<StringSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnJsonArgs = {
  json?: Maybe<StringSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnMaximumArgs = {
  get?: Maybe<BitcoinOmniTransactionsMeasureablse>;
  of: BitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnMinimumArgs = {
  get?: Maybe<BitcoinOmniTransactionsMeasureablse>;
  of: BitcoinOmniTransactionsMeasureablse;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnTxSenderArgs = {
  txSender?: Maybe<HashSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnTypeArgs = {
  type?: Maybe<StringSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnTypeIntArgs = {
  typeInt?: Maybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnValidArgs = {
  valid?: Maybe<IntegerSelector>;
};


/** OmniTransactions */
export type BitcoinOmniTransactiosnVersionArgs = {
  version?: Maybe<IntegerSelector>;
};

/** OmniTransfers */
export type BitcoinOmniTransfers = {
  __typename?: 'BitcoinOmniTransfers';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Hash of the block */
  blockHash: Scalars['String'];
  /** Transaction s count */
  count?: Maybe<Scalars['Int']>;
  /** Transaction s count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Direction */
  direction?: Maybe<Scalars['String']>;
  /** Divisible */
  divisible?: Maybe<Scalars['Int']>;
  /** Transactions total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transactions index in block, 0-based */
  index: Scalars['String'];
  /** Ismine */
  ismine?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer From */
  transferFrom: Scalars['String'];
  /** Transfer From */
  transferTo: Scalars['String'];
  /** Transaction Sender */
  txSender: Scalars['String'];
  /** Type */
  type: Scalars['String'];
  /** Type Int */
  typeInt: Scalars['Int'];
  /** value */
  value?: Maybe<Scalars['Float']>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersAnyArgs = {
  of: BitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitcoinOmniTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersCountArgs = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinOmniTransfersUniq>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinOmniTransfersUniq>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersDirectionArgs = {
  direction?: Maybe<StringSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersDivisibleArgs = {
  divisible?: Maybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersFeeValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersHashArgs = {
  txHash?: Maybe<StringIdSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersIndexArgs = {
  txIndex?: Maybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersIsmineArgs = {
  ismine?: Maybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersMaximumArgs = {
  get?: Maybe<BitcoinOmniTransfersMeasureablse>;
  of: BitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitcoinOmniTransfersMinimumArgs = {
  get?: Maybe<BitcoinOmniTransfersMeasureablse>;
  of: BitcoinOmniTransfersMeasureablse;
};


/** OmniTransfers */
export type BitcoinOmniTransfersTransferFromArgs = {
  transferFrom?: Maybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersTransferToArgs = {
  transferTo?: Maybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersTxSenderArgs = {
  txSender?: Maybe<HashSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersTypeArgs = {
  type?: Maybe<StringSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersTypeIntArgs = {
  typeInt?: Maybe<IntegerSelector>;
};


/** OmniTransfers */
export type BitcoinOmniTransfersValueArgs = {
  value?: Maybe<FloatSelector>;
};

export type BitcoinOmniTransfersFilter = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  invalidReason?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSender?: Maybe<HashSelector>;
  type?: Maybe<StringSelector>;
  typeId?: Maybe<IntegerSelector>;
  valid?: Maybe<IntegerSelector>;
  version?: Maybe<IntegerSelector>;
};

export enum BitcoinOmniTransfersMeasureablse {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transactions hash */
  TxHash = 'tx_hash',
  /** Transactions index */
  TxIndex = 'tx_index'
}

export enum BitcoinOmniTransfersUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction sender */
  TxSender = 'tx_sender'
}

export enum BitcoinOutputDirection {
  /** Change return */
  Change = 'change',
  /** Fee */
  Fee = 'fee',
  /** Genesis */
  Genesis = 'genesis',
  /** Likely Change return */
  LikelyChange = 'likely_change',
  /** Likely Not a change return */
  LikelyNotChange = 'likely_not_change',
  /** Mining */
  Mining = 'mining',
  /** Minting */
  Minting = 'minting',
  /** Not a change return */
  NotChange = 'not_change',
  /** Not defined */
  Unknown = 'unknown'
}

/** A guessed direction of output */
export type BitcoinOutputDirectionSelector = {
  /** In the list of direction */
  in?: Maybe<Array<BitcoinOutputDirection>>;
  /** Equal to direction */
  is?: Maybe<BitcoinOutputDirection>;
  /** Not Equal to direction */
  not?: Maybe<BitcoinOutputDirection>;
  /** Not in the list of direction */
  notIn?: Maybe<Array<BitcoinOutputDirection>>;
};

export type BitcoinOutputFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<BitcoinOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputScriptType?: Maybe<BitcoinOutputScriptTypeSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

export enum BitcoinOutputScriptType {
  /** Output Multisignature Wallet */
  Multisig = 'multisig',
  /** Non standard output script */
  Nonstandard = 'nonstandard',
  /** Output nulldata */
  Nulldata = 'nulldata',
  /** Output PubKey */
  Pubkey = 'pubkey',
  /** Output PubKey Hash */
  Pubkeyhash = 'pubkeyhash',
  /** Output Script Hash */
  Scripthash = 'scripthash',
  /** Output Witness Other */
  WitnessUnknown = 'witness_unknown',
  /** Output Witness Key Hash */
  WitnessV0Keyhash = 'witness_v0_keyhash',
  /** Output Witness Script Hash */
  WitnessV0Scripthash = 'witness_v0_scripthash'
}

/** Selector of output script type */
export type BitcoinOutputScriptTypeSelector = {
  /** In the list of Script Type */
  in?: Maybe<Array<BitcoinOutputScriptType>>;
  /** Equal to Script Type */
  is?: Maybe<BitcoinOutputScriptType>;
  /** Not Equal to Script Type */
  not?: Maybe<BitcoinOutputScriptType>;
  /** Not in the list of Script Type */
  notIn?: Maybe<Array<BitcoinOutputScriptType>>;
};

export enum BitcoinOutputUniq {
  /** Unique input addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum BitcoinOutputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Output index */
  OutputIndex = 'output_index',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

/** Transaction */
export type BitcoinTransaction = {
  __typename?: 'BitcoinTransaction';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  maximum?: Maybe<Scalars['String']>;
  /** Transaction total mined value */
  minedValue?: Maybe<Scalars['Float']>;
  /** Transaction total mined value */
  minedValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['DecimalNumber']>;
  /** Transaction is coinbase */
  txCoinbase?: Maybe<Scalars['Boolean']>;
  /** Transaction locktime */
  txLocktime?: Maybe<Scalars['BigInt']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']>;
  /** Transaction version */
  txVersion?: Maybe<Scalars['Int']>;
  /** Transaction vsize */
  txVsize?: Maybe<Scalars['Int']>;
  /** Transaction weight */
  txWeight?: Maybe<Scalars['Int']>;
};


/** Transaction */
export type BitcoinTransactionAnyArgs = {
  of: BitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitcoinTransactionBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction */
export type BitcoinTransactionCountArgs = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinTransactionUniq>;
};


/** Transaction */
export type BitcoinTransactionCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinTransactionUniq>;
};


/** Transaction */
export type BitcoinTransactionFeeValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionFeeValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionHashArgs = {
  txHash?: Maybe<StringIdSelector>;
};


/** Transaction */
export type BitcoinTransactionIndexArgs = {
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionInputCountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionInputCountBigIntArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionInputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionInputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionMaximumArgs = {
  get?: Maybe<BitcoinTransactionsMeasureable>;
  of: BitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitcoinTransactionMinedValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionMinedValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionMinimumArgs = {
  get?: Maybe<BitcoinTransactionsMeasureable>;
  of: BitcoinTransactionsMeasureable;
};


/** Transaction */
export type BitcoinTransactionOutputCountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionOutputCountBigIntArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionOutputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionOutputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionTxCoinbaseArgs = {
  txCoinbase?: Maybe<Scalars['Boolean']>;
};


/** Transaction */
export type BitcoinTransactionTxLocktimeArgs = {
  txLocktime?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionTxSizeArgs = {
  txSize?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionTxVersionArgs = {
  txVersion?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionTxVsizeArgs = {
  txVsize?: Maybe<IntegerSelector>;
};


/** Transaction */
export type BitcoinTransactionTxWeightArgs = {
  txWeight?: Maybe<IntegerSelector>;
};

export type BitcoinTransactionFilter = {
  date?: Maybe<DateSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  minedValue?: Maybe<FloatSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txCoinbase?: Maybe<Scalars['Boolean']>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txLocktime?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  txVersion?: Maybe<IntegerSelector>;
  txVsize?: Maybe<IntegerSelector>;
  txWeight?: Maybe<IntegerSelector>;
};

/** Blockchain transaction */
export type BitcoinTransactionHashIndexValues = {
  __typename?: 'BitcoinTransactionHashIndexValues';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  /** Transaction value in input */
  valueIn: Scalars['Float'];
  /** Transaction value in input */
  valueInDecimal: Scalars['DecimalNumber'];
  /** Transaction value in output */
  valueOut: Scalars['Float'];
  /** Transaction value in output */
  valueOutDecimal: Scalars['DecimalNumber'];
};

/** Transaction Input */
export type BitcoinTransactionInput = {
  __typename?: 'BitcoinTransactionInput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Input count */
  count?: Maybe<Scalars['Int']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Input address */
  inputAddress?: Maybe<Address>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']>;
  /** Input script */
  inputScript?: Maybe<Scalars['String']>;
  /** Input script type and attributes */
  inputScriptType?: Maybe<InputScript>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<TransactionHashIndex>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumber']>;
};


/** Transaction Input */
export type BitcoinTransactionInputAnyArgs = {
  of: BitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitcoinTransactionInputBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInputCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinInputUniq>;
};


/** Transaction Input */
export type BitcoinTransactionInputCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinInputUniq>;
};


/** Transaction Input */
export type BitcoinTransactionInputInputAddressArgs = {
  inputAddress?: Maybe<AddressSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInputInputIndexArgs = {
  inputIndex?: Maybe<IntegerSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInputInputScriptTypeArgs = {
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInputMaximumArgs = {
  get?: Maybe<BitcoinInputsMeasureable>;
  of: BitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitcoinTransactionInputMinimumArgs = {
  get?: Maybe<BitcoinInputsMeasureable>;
  of: BitcoinInputsMeasureable;
};


/** Transaction Input */
export type BitcoinTransactionInputOutputTransactionArgs = {
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<StringIdSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInputTransactionArgs = {
  txId?: Maybe<StringIdSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Input */
export type BitcoinTransactionInputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

/** Transaction Output */
export type BitcoinTransactionOutput = {
  __typename?: 'BitcoinTransactionOutput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Output count */
  count?: Maybe<Scalars['Int']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output address */
  outputAddress?: Maybe<Address>;
  /** Output guessed direction */
  outputDirection?: Maybe<BitcoinOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']>;
  /** Output script */
  outputScript?: Maybe<Scalars['String']>;
  /** Output script type and attributes */
  outputScriptType?: Maybe<OutputScript>;
  reqSigs?: Maybe<Scalars['Int']>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']>;
  /** Output value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumber']>;
};


/** Transaction Output */
export type BitcoinTransactionOutputAnyArgs = {
  of: BitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitcoinTransactionOutputBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutputCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<BitcoinOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputScriptType?: Maybe<BitcoinOutputScriptTypeSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinOutputUniq>;
};


/** Transaction Output */
export type BitcoinTransactionOutputCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<BitcoinOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputScriptType?: Maybe<BitcoinOutputScriptTypeSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<BitcoinOutputUniq>;
};


/** Transaction Output */
export type BitcoinTransactionOutputMaximumArgs = {
  get?: Maybe<BitcoinOutputsMeasureable>;
  of: BitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitcoinTransactionOutputMinimumArgs = {
  get?: Maybe<BitcoinOutputsMeasureable>;
  of: BitcoinOutputsMeasureable;
};


/** Transaction Output */
export type BitcoinTransactionOutputOutputAddressArgs = {
  outputAddress?: Maybe<AddressSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutputOutputDirectionArgs = {
  outputDirection?: Maybe<BitcoinOutputDirectionSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutputOutputIndexArgs = {
  outputIndex?: Maybe<IntegerSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutputOutputScriptTypeArgs = {
  inputScriptType?: Maybe<BitcoinOutputScriptTypeSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutputTransactionArgs = {
  txId?: Maybe<StringIdSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<BitcoinOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputScriptType?: Maybe<BitcoinOutputScriptTypeSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Output */
export type BitcoinTransactionOutputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputScriptType?: Maybe<BitcoinInputScriptTypeSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

export enum BitcoinTransactionUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export enum BitcoinTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Input count */
  InputCount = 'input_count',
  /** Transaction input value */
  InputValue = 'input_value',
  /** Output count */
  OutputCount = 'output_count',
  /** Transaction output value */
  OutputValue = 'output_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index',
  /** Transaction size */
  TxSize = 'tx_size'
}

/** Block */
export type Block = {
  __typename?: 'Block';
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

/** BlockExtended */
export type BlockExtended = {
  __typename?: 'BlockExtended';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

/** ConfluxBlock */
export type BlockInfo = {
  __typename?: 'BlockInfo';
  /** Block hash */
  hash?: Maybe<Scalars['String']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};

/** Select block by height ( sequence number) */
export type BlockSelector = {
  /** Block height in range */
  between?: Maybe<Array<Scalars['Int']>>;
  /** Block height greater than */
  gt?: Maybe<Scalars['Int']>;
  /** Block height greater or equal than */
  gteq?: Maybe<Scalars['Int']>;
  /** Block height in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Block height is */
  is?: Maybe<Scalars['Int']>;
  /** Block height less than */
  lt?: Maybe<Scalars['Int']>;
  /** Block height less or equal than */
  lteq?: Maybe<Scalars['Int']>;
  /** Block height not */
  not?: Maybe<Scalars['Int']>;
  /** Block height not in the list */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

/** Select block by height ( sequence number) */
export type BlockSelectorRange = {
  /** Block height in range */
  between?: Maybe<Array<Scalars['Int']>>;
  /** Block height greater or equal than */
  gteq?: Maybe<Scalars['Int']>;
  /** Block height less or equal than */
  lteq?: Maybe<Scalars['Int']>;
};

/** Blockchain network */
export type BlockchainNetwork = {
  __typename?: 'BlockchainNetwork';
  /** Network name */
  network: Network;
  /** Network protocol type */
  protocol: Protocol;
};

/** Select by boolean (sequence number) */
export type BooleanSelector = {
  /** Is */
  is?: Maybe<Scalars['Boolean']>;
  /** Is not */
  not?: Maybe<Scalars['Boolean']>;
};

/** Information about call */
export type CallElrond = {
  __typename?: 'CallElrond';
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Contract method invoked */
  smartContractAddress?: Maybe<Scalars['String']>;
  /** Smart contract name */
  smartContractName?: Maybe<Scalars['String']>;
  /** Smart contract signature */
  smartContractSignature?: Maybe<Scalars['String']>;
  /** Signature Hash */
  smartContractSignatureHash?: Maybe<Scalars['String']>;
};


/** Information about call */
export type CallElrondSmartContractAddressArgs = {
  smartContractAddress?: Maybe<HashSelector>;
};


/** Information about call */
export type CallElrondSmartContractNameArgs = {
  smartContractName?: Maybe<StringSelector>;
};


/** Information about call */
export type CallElrondSmartContractSignatureArgs = {
  smartContractSignature?: Maybe<StringSelector>;
};


/** Information about call */
export type CallElrondSmartContractSignatureHashArgs = {
  smartContractSignatureHash?: Maybe<HashSelector>;
};

/** Cardano */
export type Cardano = {
  __typename?: 'Cardano';
  /** Information about address */
  address: Array<CardanoAddressInfo>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<CardanoBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<CardanoCoinpath>>;
  /** Blockchain Transaction Inputs */
  inputs?: Maybe<Array<CardanoTransactionInput>>;
  /** Blockchain Tokens Mints */
  mints?: Maybe<Array<CardanoTransactionMint>>;
  /** Blockchain Transaction Outputs */
  outputs?: Maybe<Array<CardanoTransactionOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<CardanoTransaction>>;
};


/** Cardano */
export type CardanoAddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Cardano */
export type CardanoBlocksArgs = {
  any?: Maybe<Array<CardanoBlockFilter>>;
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  opCert?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  slot?: Maybe<IntegerSelector>;
  slotInEpoch?: Maybe<IntegerSelector>;
  slotLeaderHash?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  version?: Maybe<StringSelector>;
  vrfKey?: Maybe<StringSelector>;
};


/** Cardano */
export type CardanoCoinpathArgs = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CardanoCoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Cardano */
export type CardanoInputsArgs = {
  any?: Maybe<Array<CardanoInputFilter>>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Cardano */
export type CardanoMintsArgs = {
  any?: Maybe<Array<CardanoMintFilter>>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  value?: Maybe<FloatSelector>;
};


/** Cardano */
export type CardanoOutputsArgs = {
  any?: Maybe<Array<CardanoOutputFilter>>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<CardanoOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Cardano */
export type CardanoTransactionsArgs = {
  any?: Maybe<Array<CardanoTransactionFilter>>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};

/** Address balance information for Cardano network */
export type CardanoAddressBalance = {
  __typename?: 'CardanoAddressBalance';
  /** Currency */
  currency?: Maybe<Currency>;
  /** Currency value */
  value?: Maybe<Scalars['Float']>;
};

/** Address detailed information for Cardano network */
export type CardanoAddressInfo = {
  __typename?: 'CardanoAddressInfo';
  /** Address */
  address?: Maybe<Address>;
  /** Current address balances */
  balance?: Maybe<Array<CardanoAddressBalance>>;
  /** Current staking addressese info */
  staking?: Maybe<Array<CardanoStakingAddress>>;
};

/** Block */
export type CardanoBlock = {
  __typename?: 'CardanoBlock';
  any?: Maybe<Scalars['String']>;
  /** Block Hash */
  blockHash?: Maybe<Scalars['String']>;
  /** Block size */
  blockSize?: Maybe<Scalars['Int']>;
  /** Block version */
  blockVersion?: Maybe<Scalars['Int']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Epoch number */
  epoch?: Maybe<Scalars['Int']>;
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Op cert */
  opCert?: Maybe<Scalars['String']>;
  /** Slot number */
  slot?: Maybe<Scalars['Int']>;
  /** Slot in epoch number */
  slotInEpoch?: Maybe<Scalars['Int']>;
  /** Slot leader description */
  slotLeaderDescription?: Maybe<Scalars['String']>;
  /** Slot leader hash */
  slotLeaderHash?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction count in block */
  transactionCount?: Maybe<Scalars['Int']>;
  /** VRF Key */
  vrfKey?: Maybe<Scalars['String']>;
};


/** Block */
export type CardanoBlockAnyArgs = {
  of: CardanoBlocksMeasureable;
};


/** Block */
export type CardanoBlockBlockHashArgs = {
  blockHash?: Maybe<StringIdSelector>;
};


/** Block */
export type CardanoBlockBlockSizeArgs = {
  blockSize?: Maybe<IntegerSelector>;
};


/** Block */
export type CardanoBlockBlockVersionArgs = {
  blockVersion?: Maybe<IntegerSelector>;
};


/** Block */
export type CardanoBlockCountArgs = {
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockStrippedSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  blockWeight?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  difficulty?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txCount?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoBlockUniq>;
};


/** Block */
export type CardanoBlockCountBigIntArgs = {
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockStrippedSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  blockWeight?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  difficulty?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txCount?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoBlockUniq>;
};


/** Block */
export type CardanoBlockHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Block */
export type CardanoBlockMaximumArgs = {
  get?: Maybe<CardanoBlocksMeasureable>;
  of: CardanoBlocksMeasureable;
};


/** Block */
export type CardanoBlockMinimumArgs = {
  get?: Maybe<CardanoBlocksMeasureable>;
  of: CardanoBlocksMeasureable;
};


/** Block */
export type CardanoBlockTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type CardanoBlockTransactionCountArgs = {
  transactionCount?: Maybe<IntegerSelector>;
};

export type CardanoBlockFilter = {
  blockHash?: Maybe<StringIdSelector>;
  blockSize?: Maybe<IntegerSelector>;
  blockVersion?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  opCert?: Maybe<StringSelector>;
  slot?: Maybe<IntegerSelector>;
  slotInEpoch?: Maybe<IntegerSelector>;
  slotLeaderHash?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  version?: Maybe<StringSelector>;
  vrfKey?: Maybe<StringSelector>;
};

export enum CardanoBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique epoch */
  Epoch = 'epoch',
  /** Unique slot */
  Slot = 'slot',
  /** Unique slot leader */
  SlotLeader = 'slot_leader',
  /** Unique version */
  Version = 'version'
}

export enum CardanoBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Tx Count */
  TransactionCount = 'transaction_count'
}

/** Coinpath */
export type CardanoCoinpath = {
  __typename?: 'CardanoCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<CardanoTransactionHashIndexValues>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type CardanoCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type CardanoCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type CardanoCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type CardanoCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

export enum CardanoCoinpathMethod {
  /** Tracking money flow by amounts, ignoring coins (default) */
  Moneyflow = 'moneyflow',
  /** Tracking coins by UTXO transactions */
  Utxo = 'utxo'
}

/** Limits, Ordering, Constraints, Coinpath Options */
export type CardanoCoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: Maybe<Array<Scalars['String']>>;
  /** Method to use coinpath */
  coinpathMethod?: Maybe<CardanoCoinpathMethod>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: Maybe<Scalars['Int']>;
  /** Ordering field(s) for descending */
  desc?: Maybe<Array<Scalars['String']>>;
  /** Flow direction */
  direction?: Maybe<FlowDirection>;
  /** Limit number of results */
  limit?: Maybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: Maybe<LimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: Maybe<Scalars['Int']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: Maybe<Scalars['Int']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: Maybe<Scalars['Float']>;
  /** Offset of results, starting from 0 */
  offset?: Maybe<Scalars['Int']>;
  /** Invalidating cache seed */
  seed?: Maybe<Scalars['Int']>;
};

/**
 * Cardano token selector by tokenId.
 * Native binance token has ADA symbol, pass it as argument.
 * Otherwise pass asset fingerprint, starting from asset...
 */
export type CardanoCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

export type CardanoInputFilter = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

export enum CardanoInputSource {
  /** Input */
  Input = 'input',
  /** Withdrawal */
  Withdrawal = 'withdrawal'
}

export enum CardanoInputUniq {
  /** Unique addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique currencies count */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum CardanoInputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Input index */
  InputIndex = 'input_index',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

export type CardanoMintFilter = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  value?: Maybe<FloatSelector>;
};

export enum CardanoMintUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique currencies count */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum CardanoMintsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

export enum CardanoNetwork {
  /** Cardano ( ADA ) */
  Cardano = 'cardano'
}

export enum CardanoOutputDirection {
  /** Change return */
  Change = 'change',
  /** Fee */
  Fee = 'fee',
  /** Genesis */
  Genesis = 'genesis',
  /** Likely Change return */
  LikelyChange = 'likely_change',
  /** Likely Not a change return */
  LikelyNotChange = 'likely_not_change',
  /** Mining */
  Mining = 'mining',
  /** Minting */
  Minting = 'minting',
  /** Not a change return */
  NotChange = 'not_change',
  /** Not defined */
  Unknown = 'unknown'
}

/** A guessed direction of output */
export type CardanoOutputDirectionSelector = {
  /** In the list of direction */
  in?: Maybe<Array<CardanoOutputDirection>>;
  /** Equal to direction */
  is?: Maybe<CardanoOutputDirection>;
  /** Not Equal to direction */
  not?: Maybe<CardanoOutputDirection>;
  /** Not in the list of direction */
  notIn?: Maybe<Array<CardanoOutputDirection>>;
};

export type CardanoOutputFilter = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<CardanoOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

export enum CardanoOutputUniq {
  /** Unique input addresses count */
  Addresses = 'addresses',
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique currencies count */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transactions count */
  Transactions = 'transactions'
}

export enum CardanoOutputsMeasureable {
  /** Address */
  Address = 'address',
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Output index */
  OutputIndex = 'output_index',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index'
}

/** Address staking information for Cardano network */
export type CardanoStakingAddress = {
  __typename?: 'CardanoStakingAddress';
  /** Staking Address */
  address?: Maybe<Address>;
  /** Rewards value */
  rewardsAmount?: Maybe<Scalars['Float']>;
  /** Staked value */
  stakedAmount?: Maybe<Scalars['Float']>;
  /** Staked value including rewards */
  stakedAmountWithRewards?: Maybe<Scalars['Float']>;
  /** Withdrawn value */
  withdrawnAmount?: Maybe<Scalars['Float']>;
};

/** Transaction */
export type CardanoTransaction = {
  __typename?: 'CardanoTransaction';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Transaction  count */
  count?: Maybe<Scalars['Int']>;
  /** Transaction  count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Transaction total deposit value */
  depositValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  depositValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Transaction total fee value */
  feeValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  feeValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Included at timestamp */
  includedAt?: Maybe<DateTime>;
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  /** Transaction total input count */
  inputCount?: Maybe<Scalars['Int']>;
  /** Transaction total input count */
  inputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total input value */
  inputValue?: Maybe<Scalars['Float']>;
  /** Transaction total input value as decimal */
  inputValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Invalid before */
  invalidBefore?: Maybe<Scalars['String']>;
  /** Invalid hereafter */
  invalidHereafter?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction total mint count */
  mintCount?: Maybe<Scalars['Int']>;
  /** Transaction total mint count */
  mintCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total output count */
  outputCount?: Maybe<Scalars['Int']>;
  /** Transaction total output count */
  outputCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total output value */
  outputValue?: Maybe<Scalars['Float']>;
  /** Transaction total output value */
  outputValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
  /** Transaction size */
  txSize?: Maybe<Scalars['Int']>;
  /** Transaction total withdrawal count */
  withdrawalCount?: Maybe<Scalars['Int']>;
  /** Transaction total withdrawal count */
  withdrawalCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction total withdrawal value */
  withdrawalValue?: Maybe<Scalars['Float']>;
  /** Transaction total fee value */
  withdrawalValueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Transaction */
export type CardanoTransactionAnyArgs = {
  of: CardanoTransactionsMeasureable;
};


/** Transaction */
export type CardanoTransactionBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction */
export type CardanoTransactionCountArgs = {
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoTransactionUniq>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoTransactionUniq>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionDepositValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionDepositValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionFeeValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionFeeValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionHashArgs = {
  txHash?: Maybe<StringIdSelector>;
};


/** Transaction */
export type CardanoTransactionIndexArgs = {
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction */
export type CardanoTransactionInputCountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionInputCountBigIntArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionInputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionInputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionMaximumArgs = {
  get?: Maybe<CardanoTransactionsMeasureable>;
  of: CardanoTransactionsMeasureable;
};


/** Transaction */
export type CardanoTransactionMinimumArgs = {
  get?: Maybe<CardanoTransactionsMeasureable>;
  of: CardanoTransactionsMeasureable;
};


/** Transaction */
export type CardanoTransactionMintCountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionMintCountBigIntArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionOutputCountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionOutputCountBigIntArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionOutputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionOutputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionTxSizeArgs = {
  txSize?: Maybe<IntegerSelector>;
};


/** Transaction */
export type CardanoTransactionWithdrawalCountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionWithdrawalCountBigIntArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionWithdrawalValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};


/** Transaction */
export type CardanoTransactionWithdrawalValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};

export type CardanoTransactionFilter = {
  date?: Maybe<DateSelector>;
  depositValue?: Maybe<FloatSelector>;
  feeValue?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  inputAddress?: Maybe<AddressSelectorIn>;
  inputCount?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  mintCount?: Maybe<IntegerSelector>;
  outputAddress?: Maybe<AddressSelectorIn>;
  outputCount?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txSize?: Maybe<IntegerSelector>;
  withdrawalCount?: Maybe<IntegerSelector>;
  withdrawalValue?: Maybe<FloatSelector>;
};

/** Blockchain transaction */
export type CardanoTransactionHashIndexValues = {
  __typename?: 'CardanoTransactionHashIndexValues';
  depositValue: Scalars['Float'];
  /** Transaction deposit value as decimal */
  depositValueDecimal: Scalars['DecimalNumberAsDiv'];
  feeValue: Scalars['Float'];
  /** Transaction fee value as decimal */
  feeValueDecimal: Scalars['DecimalNumberAsDiv'];
  /** Hash hex representation */
  hash: Scalars['String'];
  includedAt: DateTime;
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
  invalidBefore: Scalars['String'];
  invalidHereafter: Scalars['String'];
  metadata: Scalars['String'];
  txSize: Scalars['Int'];
  /** Transaction value in input */
  valueIn: Scalars['Float'];
  /** Transaction value in input as decimal */
  valueInDecimal: Scalars['DecimalNumberAsDiv'];
  /** Transaction value in output */
  valueOut: Scalars['Float'];
  /** Transaction value in output as decimal */
  valueOutDecimal: Scalars['DecimalNumberAsDiv'];
  withdrawalValue: Scalars['Float'];
  /** Transaction withdraw value as decimal */
  withdrawalValueDecimal: Scalars['DecimalNumberAsDiv'];
};

/** Transaction Input */
export type CardanoTransactionInput = {
  __typename?: 'CardanoTransactionInput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Input count */
  count?: Maybe<Scalars['Int']>;
  /** Input count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the input */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Input address */
  inputAddress?: Maybe<Address>;
  /** Input index */
  inputIndex?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output Transaction for this input */
  outputTransaction?: Maybe<TransactionHashIndex>;
  /** Source of the input */
  source?: Maybe<CardanoInputSource>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Input value */
  value?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Transaction Input */
export type CardanoTransactionInputAnyArgs = {
  of: CardanoInputsMeasureable;
};


/** Transaction Input */
export type CardanoTransactionInputBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction Input */
export type CardanoTransactionInputCountArgs = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoInputUniq>;
};


/** Transaction Input */
export type CardanoTransactionInputCountBigIntArgs = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoInputUniq>;
};


/** Transaction Input */
export type CardanoTransactionInputInputAddressArgs = {
  inputAddress?: Maybe<AddressSelector>;
};


/** Transaction Input */
export type CardanoTransactionInputInputIndexArgs = {
  inputIndex?: Maybe<IntegerSelector>;
};


/** Transaction Input */
export type CardanoTransactionInputMaximumArgs = {
  get?: Maybe<CardanoInputsMeasureable>;
  of: CardanoInputsMeasureable;
};


/** Transaction Input */
export type CardanoTransactionInputMinimumArgs = {
  get?: Maybe<CardanoInputsMeasureable>;
  of: CardanoInputsMeasureable;
};


/** Transaction Input */
export type CardanoTransactionInputOutputTransactionArgs = {
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<StringIdSelector>;
};


/** Transaction Input */
export type CardanoTransactionInputTransactionArgs = {
  txId?: Maybe<StringIdSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Input */
export type CardanoTransactionInputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Input */
export type CardanoTransactionInputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

/** Transaction Mint */
export type CardanoTransactionMint = {
  __typename?: 'CardanoTransactionMint';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Mint count */
  count?: Maybe<Scalars['Int']>;
  /** Mint count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the mint */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Mint value */
  value?: Maybe<Scalars['Float']>;
};


/** Transaction Mint */
export type CardanoTransactionMintAnyArgs = {
  of: CardanoMintsMeasureable;
};


/** Transaction Mint */
export type CardanoTransactionMintBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMintCountArgs = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoMintUniq>;
  value?: Maybe<FloatSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMintCountBigIntArgs = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoMintUniq>;
  value?: Maybe<FloatSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMintMaximumArgs = {
  get?: Maybe<CardanoMintsMeasureable>;
  of: CardanoMintsMeasureable;
};


/** Transaction Mint */
export type CardanoTransactionMintMinimumArgs = {
  get?: Maybe<CardanoMintsMeasureable>;
  of: CardanoMintsMeasureable;
};


/** Transaction Mint */
export type CardanoTransactionMintTransactionArgs = {
  txId?: Maybe<StringIdSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Mint */
export type CardanoTransactionMintValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  value?: Maybe<FloatSelector>;
};

/** Transaction Output */
export type CardanoTransactionOutput = {
  __typename?: 'CardanoTransactionOutput';
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Output count */
  count?: Maybe<Scalars['Int']>;
  /** Output count */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the output */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Output address */
  outputAddress?: Maybe<Address>;
  /** Output guessed direction */
  outputDirection?: Maybe<CardanoOutputDirection>;
  /** Output index */
  outputIndex?: Maybe<Scalars['Int']>;
  /** Transaction ID Hash */
  transaction?: Maybe<TransactionHashIndex>;
  /** Output value */
  value?: Maybe<Scalars['Float']>;
  /** Input value as decimal */
  valueDecimal?: Maybe<Scalars['DecimalNumberAsDiv']>;
};


/** Transaction Output */
export type CardanoTransactionOutputAnyArgs = {
  of: CardanoOutputsMeasureable;
};


/** Transaction Output */
export type CardanoTransactionOutputBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutputCountArgs = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<CardanoOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoOutputUniq>;
};


/** Transaction Output */
export type CardanoTransactionOutputCountBigIntArgs = {
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<CardanoOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  uniq?: Maybe<CardanoOutputUniq>;
};


/** Transaction Output */
export type CardanoTransactionOutputMaximumArgs = {
  get?: Maybe<CardanoOutputsMeasureable>;
  of: CardanoOutputsMeasureable;
};


/** Transaction Output */
export type CardanoTransactionOutputMinimumArgs = {
  get?: Maybe<CardanoOutputsMeasureable>;
  of: CardanoOutputsMeasureable;
};


/** Transaction Output */
export type CardanoTransactionOutputOutputAddressArgs = {
  outputAddress?: Maybe<AddressSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutputOutputDirectionArgs = {
  outputDirection?: Maybe<CardanoOutputDirectionSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutputOutputIndexArgs = {
  outputIndex?: Maybe<IntegerSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutputTransactionArgs = {
  txId?: Maybe<StringIdSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutputValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  outputAddress?: Maybe<AddressSelector>;
  outputDirection?: Maybe<CardanoOutputDirectionSelector>;
  outputIndex?: Maybe<IntegerSelector>;
  outputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};


/** Transaction Output */
export type CardanoTransactionOutputValueDecimalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<CardanoCurrencySelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  inOutputIndex?: Maybe<IntegerSelector>;
  inOutputTxId?: Maybe<HashSelector>;
  inputAddress?: Maybe<AddressSelector>;
  inputIndex?: Maybe<IntegerSelector>;
  inputValue?: Maybe<FloatSelector>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
};

export enum CardanoTransactionUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export enum CardanoTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Transaction deposit value */
  DepositValue = 'deposit_value',
  /** Input count */
  InputCount = 'input_count',
  /** Transaction input value */
  InputValue = 'input_value',
  /** Transaction mint count */
  MintCount = 'mint_count',
  /** Output count */
  OutputCount = 'output_count',
  /** Transaction output value */
  OutputValue = 'output_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction index */
  TxIndex = 'tx_index',
  /** Transaction size */
  TxSize = 'tx_size',
  /** Transaction withdrawal count */
  WithdrawalCount = 'withdrawal_count',
  /** Transaction withdrawal value */
  WithdrawalValue = 'withdrawal_value'
}

/** Transaction attributes in coinpath */
export type CoinpathEntry = {
  __typename?: 'CoinpathEntry';
  /** Amount involved in the flow */
  amount: Scalars['Float'];
  /** Block of transaction */
  height: Scalars['Int'];
  /** Time of transaction in ISO 8601 format */
  timestamp: Scalars['ISO8601DateTime'];
  /** Hash of transaction */
  txHash: Scalars['String'];
  /** Amount transfered in transaction */
  txValue: Scalars['Float'];
};

export enum CoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Limits, Ordering, Constraints, Coinpath Options */
export type CoinpathOptions = {
  /** Ordering field(s) for ascending */
  asc?: Maybe<Array<Scalars['String']>>;
  /** Raise error if complexity ( currently measured in transaction count ) is higher than this option */
  complexityLimit?: Maybe<Scalars['Int']>;
  /** Ordering field(s) for descending */
  desc?: Maybe<Array<Scalars['String']>>;
  /** Flow direction */
  direction?: Maybe<FlowDirection>;
  /** Limit number of results */
  limit?: Maybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: Maybe<LimitByOption>;
  /** Do not expand addresses having count transactions more than this */
  maximumAddressTxCount?: Maybe<Scalars['Int']>;
  /** Maximum total transaction count returned */
  maximumTotalTxCount?: Maybe<Scalars['Int']>;
  /** Do not include transactions below this amount */
  minimumTxAmount?: Maybe<Scalars['Float']>;
  /** Offset of results, starting from 0 */
  offset?: Maybe<Scalars['Int']>;
  /** Invalidating cache seed */
  seed?: Maybe<Scalars['Int']>;
};

/** Conflux Chain */
export type Conflux = {
  __typename?: 'Conflux';
  /** Basic information about address ( or smart contract ) */
  address: Array<EthereumAddressInfoWithBalance>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<EthereumArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<ConfluxBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<EthereumCoinpath>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<EthereumDexTrades>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<EthereumSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<EthereumSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<ConfluxTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<EthereumTransfers>>;
};


/** Conflux Chain */
export type ConfluxAddressArgs = {
  address: Array<EthereumAddressSelectorIn>;
};


/** Conflux Chain */
export type ConfluxArgumentsArgs = {
  any?: Maybe<Array<EthereumArgumentFilter>>;
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Conflux Chain */
export type ConfluxBlocksArgs = {
  any?: Maybe<Array<ConfluxBlockFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  options?: Maybe<QueryOptions>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Conflux Chain */
export type ConfluxCoinpathArgs = {
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<EthereumAddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<EthereumAddressSelector>;
  sender?: Maybe<EthereumAddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Conflux Chain */
export type ConfluxDexTradesArgs = {
  any?: Maybe<Array<EthereumDexTradeFilter>>;
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  options?: Maybe<QueryOptions>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Conflux Chain */
export type ConfluxSmartContractCallsArgs = {
  any?: Maybe<Array<EthereumSmartContractCallFilter>>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: Maybe<MethodSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  success?: Maybe<Array<Scalars['Boolean']>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Conflux Chain */
export type ConfluxSmartContractEventsArgs = {
  any?: Maybe<Array<EthereumSmartContractEventFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Conflux Chain */
export type ConfluxTransactionsArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<ConfluxTransactionFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Conflux Chain */
export type ConfluxTransfersArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<EthereumTransferFilter>>;
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<Array<EthereumAddressSelector>>;
  sender?: Maybe<Array<EthereumAddressSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};

export type ConfluxBlockFilter = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};

/** Blocks in Conflux blockchain */
export type ConfluxBlocks = {
  __typename?: 'ConfluxBlocks';
  /** Block is adaptive */
  adaptive: Scalars['Boolean'];
  any?: Maybe<Scalars['String']>;
  /** Blame */
  blame: Scalars['Int'];
  /** Block index in epoch */
  blockPosition: Scalars['Int'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Epoch in blockchain */
  epoch: Scalars['Int'];
  /** Block hash */
  hash: Scalars['String'];
  /** Block height in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  /** Block miner */
  miner?: Maybe<EthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']>;
  /** Block nonce */
  nonce: Scalars['Int'];
  /** Parent block hash */
  parentHash: Scalars['String'];
  /** Block is pivot */
  pivot: Scalars['Boolean'];
  /** Power Quality */
  powerQuality: Scalars['BigInt'];
  refereeCount?: Maybe<Scalars['Int']>;
  refereeCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Reference Block hash */
  referenceBlockHash: Scalars['String'];
  size?: Maybe<Scalars['Int']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  totalDifficulty?: Maybe<Scalars['Float']>;
  transactionCount?: Maybe<Scalars['Int']>;
  transactionCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Hash of Transaction included in block */
  txHash: Scalars['String'];
  uncleCount?: Maybe<Scalars['Int']>;
  uncleCountBigInt?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksAnyArgs = {
  of: ConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksCountArgs = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
  uniq?: Maybe<EthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
  uniq?: Maybe<EthereumBlocksUniq>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksEpochArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksHashArgs = {
  blockHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksMaximumArgs = {
  get?: Maybe<ConfluxBlocksMeasureable>;
  of: ConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksMinerArgs = {
  miner?: Maybe<Array<EthereumAddressSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksMinimumArgs = {
  get?: Maybe<ConfluxBlocksMeasureable>;
  of: ConfluxBlocksMeasureable;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksRefereeCountArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksRefereeCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksReferenceBlockHashArgs = {
  referenceBlockHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksSizeArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksTotalDifficultyArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksTransactionCountArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksTransactionCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksTxHashArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksUncleCountArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Conflux blockchain */
export type ConfluxBlocksUncleCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<BlockSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  pivot?: Maybe<Scalars['Boolean']>;
  refereeCount?: Maybe<Array<IntegerSelector>>;
  referenceBlockHash?: Maybe<HashSelector>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};

export enum ConfluxBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Block Miner */
  Miner = 'miner',
  /** Block Referee Count */
  RefereeCount = 'referee_count',
  /** Time */
  Time = 'time',
  /** Block TX Count */
  TransactionCount = 'transaction_count'
}

export enum ConfluxNetwork {
  /** Conflux Oceanus */
  ConfluxOceanus = 'conflux_oceanus',
  /** Conflux Tethys */
  ConfluxTethys = 'conflux_tethys'
}

export type ConfluxTransactionFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};

/** Transactions in Conflux blockchain */
export type ConfluxTransactions = {
  __typename?: 'ConfluxTransactions';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BlockInfo>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Created smart contract */
  creates?: Maybe<EthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Error message if any */
  error?: Maybe<Scalars['String']>;
  gas?: Maybe<Scalars['Int']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Transaction sender */
  sender?: Maybe<EthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction receiver */
  to?: Maybe<EthereumAddressInfo>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsAnyArgs = {
  of: ConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
  uniq?: Maybe<EthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
  uniq?: Maybe<EthereumTransactionsUniq>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsCreatesArgs = {
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsGasArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsGasCurrencyArgs = {
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsGasPriceArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsGasValueArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsHashArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsIndexArgs = {
  txIndex?: Maybe<Array<TxIndexSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsMaximumArgs = {
  get?: Maybe<ConfluxTransactionsMeasureable>;
  of: ConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsMinimumArgs = {
  get?: Maybe<ConfluxTransactionsMeasureable>;
  of: ConfluxTransactionsMeasureable;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsSenderArgs = {
  txSender?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Conflux blockchain */
export type ConfluxTransactionsToArgs = {
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};

export enum ConfluxTransactionsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Gas value */
  GasValue = 'gas_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender'
}

export enum Continent {
  /** Africa */
  Africa = 'Africa',
  /** Antarctica */
  Antarctica = 'Antarctica',
  /** Asia */
  Asia = 'Asia',
  /** Europe */
  Europe = 'Europe',
  /** North America */
  NorthAmerica = 'North_America',
  /** Oceania */
  Oceania = 'Oceania',
  /** South America */
  SouthAmerica = 'South_America'
}

/** Continent selector */
export type ContinentSelector = {
  /** Country code in the list */
  in?: Maybe<Array<Continent>>;
  /** Country code is */
  is?: Maybe<Continent>;
  /** Country code not */
  not?: Maybe<Continent>;
  /** Country code not in the list */
  notIn?: Maybe<Array<Continent>>;
};

export enum CountryCode {
  /** Andorra */
  Ad = 'AD',
  /** United Arab Emirates */
  Ae = 'AE',
  /** Afghanistan */
  Af = 'AF',
  /** Antigua and Barbuda */
  Ag = 'AG',
  /** Anguilla */
  Ai = 'AI',
  /** Albania */
  Al = 'AL',
  /** Armenia */
  Am = 'AM',
  /** Netherlands Antilles */
  An = 'AN',
  /** Angola */
  Ao = 'AO',
  /** Antarctica */
  Aq = 'AQ',
  /** Argentina */
  Ar = 'AR',
  /** American Samoa */
  As = 'AS',
  /** Austria */
  At = 'AT',
  /** Australia */
  Au = 'AU',
  /** Aruba */
  Aw = 'AW',
  /** Azerbaijan */
  Az = 'AZ',
  /** Bosnia and Herzegovina */
  Ba = 'BA',
  /** Barbados */
  Bb = 'BB',
  /** Bangladesh */
  Bd = 'BD',
  /** Belgium */
  Be = 'BE',
  /** Burkina Faso */
  Bf = 'BF',
  /** Bulgaria */
  Bg = 'BG',
  /** Bahrain */
  Bh = 'BH',
  /** Burundi */
  Bi = 'BI',
  /** Benin */
  Bj = 'BJ',
  /** Saint Barthelemy */
  Bl = 'BL',
  /** Bermuda */
  Bm = 'BM',
  /** Brunei */
  Bn = 'BN',
  /** Bolivia */
  Bo = 'BO',
  /** Brazil */
  Br = 'BR',
  /** Bahamas */
  Bs = 'BS',
  /** Bhutan */
  Bt = 'BT',
  /** Botswana */
  Bw = 'BW',
  /** Belarus */
  By = 'BY',
  /** Belize */
  Bz = 'BZ',
  /** Canada */
  Ca = 'CA',
  /** Cocos Islands */
  Cc = 'CC',
  /** Democratic Republic of the Congo */
  Cd = 'CD',
  /** Central African Republic */
  Cf = 'CF',
  /** Republic of the Congo */
  Cg = 'CG',
  /** Switzerland */
  Ch = 'CH',
  /** Ivory Coast */
  Ci = 'CI',
  /** Cook Islands */
  Ck = 'CK',
  /** Chile */
  Cl = 'CL',
  /** Cameroon */
  Cm = 'CM',
  /** China */
  Cn = 'CN',
  /** Colombia */
  Co = 'CO',
  /** Costa Rica */
  Cr = 'CR',
  /** Cuba */
  Cu = 'CU',
  /** Cape Verde */
  Cv = 'CV',
  /** Curacao */
  Cw = 'CW',
  /** Christmas Island */
  Cx = 'CX',
  /** Cyprus */
  Cy = 'CY',
  /** Czech Republic */
  Cz = 'CZ',
  /** Germany */
  De = 'DE',
  /** Djibouti */
  Dj = 'DJ',
  /** Denmark */
  Dk = 'DK',
  /** Dominica */
  Dm = 'DM',
  /** Dominican Republic */
  Do = 'DO',
  /** Algeria */
  Dz = 'DZ',
  /** Ecuador */
  Ec = 'EC',
  /** Estonia */
  Ee = 'EE',
  /** Egypt */
  Eg = 'EG',
  /** Western Sahara */
  Eh = 'EH',
  /** Eritrea */
  Er = 'ER',
  /** Spain */
  Es = 'ES',
  /** Ethiopia */
  Et = 'ET',
  /** Finland */
  Fi = 'FI',
  /** Fiji */
  Fj = 'FJ',
  /** Falkland Islands */
  Fk = 'FK',
  /** Micronesia */
  Fm = 'FM',
  /** Faroe Islands */
  Fo = 'FO',
  /** France */
  Fr = 'FR',
  /** Gabon */
  Ga = 'GA',
  /** United Kingdom */
  Gb = 'GB',
  /** Grenada */
  Gd = 'GD',
  /** Georgia */
  Ge = 'GE',
  /** Guernsey */
  Gg = 'GG',
  /** Ghana */
  Gh = 'GH',
  /** Gibraltar */
  Gi = 'GI',
  /** Greenland */
  Gl = 'GL',
  /** Gambia */
  Gm = 'GM',
  /** Guinea */
  Gn = 'GN',
  /** Equatorial Guinea */
  Gq = 'GQ',
  /** Greece */
  Gr = 'GR',
  /** Guatemala */
  Gt = 'GT',
  /** Guam */
  Gu = 'GU',
  /** Guinea-Bissau */
  Gw = 'GW',
  /** Guyana */
  Gy = 'GY',
  /** Hong Kong */
  Hk = 'HK',
  /** Honduras */
  Hn = 'HN',
  /** Croatia */
  Hr = 'HR',
  /** Haiti */
  Ht = 'HT',
  /** Hungary */
  Hu = 'HU',
  /** Indonesia */
  Id = 'ID',
  /** Ireland */
  Ie = 'IE',
  /** Israel */
  Il = 'IL',
  /** Isle of Man */
  Im = 'IM',
  /** India */
  In = 'IN',
  /** British Indian Ocean Territory */
  Io = 'IO',
  /** Iraq */
  Iq = 'IQ',
  /** Iran */
  Ir = 'IR',
  /** Iceland */
  Is = 'IS',
  /** Italy */
  It = 'IT',
  /** Jersey */
  Je = 'JE',
  /** Jamaica */
  Jm = 'JM',
  /** Jordan */
  Jo = 'JO',
  /** Japan */
  Jp = 'JP',
  /** Kenya */
  Ke = 'KE',
  /** Kyrgyzstan */
  Kg = 'KG',
  /** Cambodia */
  Kh = 'KH',
  /** Kiribati */
  Ki = 'KI',
  /** Comoros */
  Km = 'KM',
  /** Saint Kitts and Nevis */
  Kn = 'KN',
  /** North Korea */
  Kp = 'KP',
  /** South Korea */
  Kr = 'KR',
  /** Kuwait */
  Kw = 'KW',
  /** Cayman Islands */
  Ky = 'KY',
  /** Kazakhstan */
  Kz = 'KZ',
  /** Laos */
  La = 'LA',
  /** Lebanon */
  Lb = 'LB',
  /** Saint Lucia */
  Lc = 'LC',
  /** Liechtenstein */
  Li = 'LI',
  /** Sri Lanka */
  Lk = 'LK',
  /** Liberia */
  Lr = 'LR',
  /** Lesotho */
  Ls = 'LS',
  /** Lithuania */
  Lt = 'LT',
  /** Luxembourg */
  Lu = 'LU',
  /** Latvia */
  Lv = 'LV',
  /** Libya */
  Ly = 'LY',
  /** Morocco */
  Ma = 'MA',
  /** Monaco */
  Mc = 'MC',
  /** Moldova */
  Md = 'MD',
  /** Montenegro */
  Me = 'ME',
  /** Saint Martin */
  Mf = 'MF',
  /** Madagascar */
  Mg = 'MG',
  /** Marshall Islands */
  Mh = 'MH',
  /** Macedonia */
  Mk = 'MK',
  /** Mali */
  Ml = 'ML',
  /** Myanmar */
  Mm = 'MM',
  /** Mongolia */
  Mn = 'MN',
  /** Macau */
  Mo = 'MO',
  /** Northern Mariana Islands */
  Mp = 'MP',
  /** Mauritania */
  Mr = 'MR',
  /** Montserrat */
  Ms = 'MS',
  /** Malta */
  Mt = 'MT',
  /** Mauritius */
  Mu = 'MU',
  /** Maldives */
  Mv = 'MV',
  /** Malawi */
  Mw = 'MW',
  /** Mexico */
  Mx = 'MX',
  /** Malaysia */
  My = 'MY',
  /** Mozambique */
  Mz = 'MZ',
  /** Namibia */
  Na = 'NA',
  /** New Caledonia */
  Nc = 'NC',
  /** Niger */
  Ne = 'NE',
  /** Nigeria */
  Ng = 'NG',
  /** Nicaragua */
  Ni = 'NI',
  /** Netherlands */
  Nl = 'NL',
  /** Norway */
  No = 'NO',
  /** Nepal */
  Np = 'NP',
  /** Nauru */
  Nr = 'NR',
  /** Niue */
  Nu = 'NU',
  /** New Zealand */
  Nz = 'NZ',
  /** Oman */
  Om = 'OM',
  /** Panama */
  Pa = 'PA',
  /** Peru */
  Pe = 'PE',
  /** French Polynesia */
  Pf = 'PF',
  /** Papua New Guinea */
  Pg = 'PG',
  /** Philippines */
  Ph = 'PH',
  /** Pakistan */
  Pk = 'PK',
  /** Poland */
  Pl = 'PL',
  /** Saint Pierre and Miquelon */
  Pm = 'PM',
  /** Pitcairn */
  Pn = 'PN',
  /** Puerto Rico */
  Pr = 'PR',
  /** Palestine */
  Ps = 'PS',
  /** Portugal */
  Pt = 'PT',
  /** Palau */
  Pw = 'PW',
  /** Paraguay */
  Py = 'PY',
  /** Qatar */
  Qa = 'QA',
  /** Reunion */
  Re = 'RE',
  /** Romania */
  Ro = 'RO',
  /** Serbia */
  Rs = 'RS',
  /** Russia */
  Ru = 'RU',
  /** Rwanda */
  Rw = 'RW',
  /** Saudi Arabia */
  Sa = 'SA',
  /** Solomon Islands */
  Sb = 'SB',
  /** Seychelles */
  Sc = 'SC',
  /** Sudan */
  Sd = 'SD',
  /** Sweden */
  Se = 'SE',
  /** Singapore */
  Sg = 'SG',
  /** Saint Helena */
  Sh = 'SH',
  /** Slovenia */
  Si = 'SI',
  /** Svalbard and Jan Mayen */
  Sj = 'SJ',
  /** Slovakia */
  Sk = 'SK',
  /** Sierra Leone */
  Sl = 'SL',
  /** San Marino */
  Sm = 'SM',
  /** Senegal */
  Sn = 'SN',
  /** Somalia */
  So = 'SO',
  /** Suriname */
  Sr = 'SR',
  /** South Sudan */
  Ss = 'SS',
  /** Sao Tome and Principe */
  St = 'ST',
  /** El Salvador */
  Sv = 'SV',
  /** Sint Maarten */
  Sx = 'SX',
  /** Syria */
  Sy = 'SY',
  /** Swaziland */
  Sz = 'SZ',
  /** Turks and Caicos Islands */
  Tc = 'TC',
  /** Chad */
  Td = 'TD',
  /** Togo */
  Tg = 'TG',
  /** Thailand */
  Th = 'TH',
  /** Tajikistan */
  Tj = 'TJ',
  /** Tokelau */
  Tk = 'TK',
  /** East Timor */
  Tl = 'TL',
  /** Turkmenistan */
  Tm = 'TM',
  /** Tunisia */
  Tn = 'TN',
  /** Tonga */
  To = 'TO',
  /** Turkey */
  Tr = 'TR',
  /** Trinidad and Tobago */
  Tt = 'TT',
  /** Tuvalu */
  Tv = 'TV',
  /** Taiwan */
  Tw = 'TW',
  /** Tanzania */
  Tz = 'TZ',
  /** Ukraine */
  Ua = 'UA',
  /** Uganda */
  Ug = 'UG',
  /** United States */
  Us = 'US',
  /** Uruguay */
  Uy = 'UY',
  /** Uzbekistan */
  Uz = 'UZ',
  /** Vatican */
  Va = 'VA',
  /** Saint Vincent and the Grenadines */
  Vc = 'VC',
  /** Venezuela */
  Ve = 'VE',
  /** British Virgin Islands */
  Vg = 'VG',
  /** U.S. Virgin Islands */
  Vi = 'VI',
  /** Vietnam */
  Vn = 'VN',
  /** Vanuatu */
  Vu = 'VU',
  /** Wallis and Futuna */
  Wf = 'WF',
  /** Samoa */
  Ws = 'WS',
  /** Kosovo */
  Xk = 'XK',
  /** Yemen */
  Ye = 'YE',
  /** Mayotte */
  Yt = 'YT',
  /** South Africa */
  Za = 'ZA',
  /** Zambia */
  Zm = 'ZM',
  /** Zimbabwe */
  Zw = 'ZW'
}

/** Country selector by 3 digit ISO code */
export type CountrySelector = {
  /** Country code in the list */
  in?: Maybe<Array<CountryCode>>;
  /** Country code is */
  is?: Maybe<CountryCode>;
  /** Country code not */
  not?: Maybe<CountryCode>;
  /** Country code not in the list */
  notIn?: Maybe<Array<CountryCode>>;
};

/** Country */
export type CovidCountry = {
  __typename?: 'CovidCountry';
  /** Area, km2 */
  areaKm2?: Maybe<Scalars['Float']>;
  /** Continent name */
  continent?: Maybe<Continent>;
  /** Gross Domestic Product */
  gdp?: Maybe<Scalars['Float']>;
  /** ISO 2 letter code */
  iso2?: Maybe<CountryCode>;
  /** ISO 3 letter code */
  iso3?: Maybe<Scalars['String']>;
  /** ISO numeric code */
  isoNumeric?: Maybe<Scalars['Int']>;
  /** Location latitude */
  latitude?: Maybe<Scalars['Float']>;
  /** Location longitude */
  longitude?: Maybe<Scalars['Float']>;
  /** Country name */
  name?: Maybe<Scalars['String']>;
  /** Population density in thousands per km2 */
  populationPerKm2?: Maybe<Scalars['Float']>;
  /** Population total in thousands */
  populationTotal?: Maybe<Scalars['Float']>;
};

/** Facts of Covid virus development */
export type CovidFact = {
  __typename?: 'CovidFact';
  /** Count of confirmed cases */
  confirmed?: Maybe<Scalars['Int']>;
  /** Country */
  country?: Maybe<CovidCountry>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Count of death cases */
  deaths?: Maybe<Scalars['Int']>;
  /** Location */
  location?: Maybe<CovidLocation>;
  /** Count of recovered cases */
  recovered?: Maybe<Scalars['Int']>;
};


/** Facts of Covid virus development */
export type CovidFactConfirmedArgs = {
  continent?: Maybe<ContinentSelector>;
  country?: Maybe<CountrySelector>;
  date?: Maybe<DateSelector>;
};


/** Facts of Covid virus development */
export type CovidFactCountryArgs = {
  continent?: Maybe<ContinentSelector>;
  country?: Maybe<CountrySelector>;
};


/** Facts of Covid virus development */
export type CovidFactDeathsArgs = {
  continent?: Maybe<ContinentSelector>;
  country?: Maybe<CountrySelector>;
  date?: Maybe<DateSelector>;
};


/** Facts of Covid virus development */
export type CovidFactRecoveredArgs = {
  continent?: Maybe<ContinentSelector>;
  country?: Maybe<CountrySelector>;
  date?: Maybe<DateSelector>;
};

/** Covid History */
export type CovidHistory = {
  __typename?: 'CovidHistory';
  /** COVID daily facts */
  facts?: Maybe<Array<CovidFact>>;
};


/** Covid History */
export type CovidHistoryFactsArgs = {
  continent?: Maybe<ContinentSelector>;
  country?: Maybe<CountrySelector>;
  date?: Maybe<DateSelector>;
  options?: Maybe<QueryOptions>;
};

/** Geo Location */
export type CovidLocation = {
  __typename?: 'CovidLocation';
  /** Admin center name */
  adminCenter?: Maybe<Scalars['String']>;
  /** FIPS code for USA */
  fipsCode?: Maybe<Scalars['Int']>;
  /** Location latitude */
  latitude?: Maybe<Scalars['Float']>;
  /** Location longitude */
  longitude?: Maybe<Scalars['Float']>;
  /** Location Country name */
  name?: Maybe<Scalars['String']>;
  /** Location Province / State name */
  province?: Maybe<Scalars['String']>;
};

/** Crypto currency ( token, coin, currency ) */
export type Currency = {
  __typename?: 'Currency';
  /** Token Smart Contract Address */
  address?: Maybe<Scalars['String']>;
  /** Decimals */
  decimals: Scalars['Int'];
  /** Currency name */
  name?: Maybe<Scalars['String']>;
  /** Currency symbol */
  symbol: Scalars['String'];
  /** Token ID */
  tokenId?: Maybe<Scalars['String']>;
  /** Token Type */
  tokenType?: Maybe<Scalars['String']>;
};

/** Currency selector */
export type CurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Date */
export type Date = {
  __typename?: 'Date';
  /** String date representation with default format as YYYY-MM-DD */
  date: Scalars['String'];
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int'];
  /** Month number (1-12) */
  month: Scalars['Int'];
  /**
   * Returns start of date interval ,
   * date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
   * starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
   */
  startOfInterval: Scalars['String'];
  /** Year number */
  year: Scalars['Int'];
};


/** Date */
export type DateDateArgs = {
  format?: Maybe<Scalars['String']>;
};


/** Date */
export type DateStartOfIntervalArgs = {
  format?: Maybe<Scalars['String']>;
  interval?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  unit: DateInterval;
};

export enum DateInterval {
  /** Day */
  Day = 'day',
  /** Month */
  Month = 'month',
  /** Week */
  Week = 'week',
  /** Year */
  Year = 'year'
}

/** Selecting the date in a range, list or just date */
export type DateSelector = {
  /** After date */
  after?: Maybe<Scalars['ISO8601DateTime']>;
  /** Before date */
  before?: Maybe<Scalars['ISO8601DateTime']>;
  /** Range of dates */
  between?: Maybe<Array<Scalars['ISO8601DateTime']>>;
  /** In dates */
  in?: Maybe<Array<Scalars['ISO8601DateTime']>>;
  /** Date equals */
  is?: Maybe<Scalars['ISO8601DateTime']>;
  /** Date not equals */
  not?: Maybe<Scalars['ISO8601DateTime']>;
  /** Not in dates */
  notIn?: Maybe<Array<Scalars['ISO8601DateTime']>>;
  /** Since date */
  since?: Maybe<Scalars['ISO8601DateTime']>;
  /** Till date */
  till?: Maybe<Scalars['ISO8601DateTime']>;
};

/** Date and Time */
export type DateTime = {
  __typename?: 'DateTime';
  /** Day of month (1-31) */
  dayOfMonth: Scalars['Int'];
  /** Day of week  (Monday is 1, and Sunday is 7) */
  dayOfWeek: Scalars['Int'];
  /** Hour (0-23) */
  hour: Scalars['Int'];
  /** ISO8601 date time such as '2020-03-02T13:30:41+00:00' */
  iso8601: Scalars['ISO8601DateTime'];
  /** Minute (0-59) */
  minute: Scalars['Int'];
  /** Month number (1-12) */
  month: Scalars['Int'];
  /** Second (0-59) */
  second: Scalars['Int'];
  /** String date representation with default format as YYYY-MM-DD */
  time: Scalars['String'];
  /** Unix timestamp */
  unixtime: Scalars['Int'];
  /** Year number */
  year: Scalars['Int'];
};


/** Date and Time */
export type DateTimeTimeArgs = {
  format?: Maybe<Scalars['String']>;
};

/** Selecting the time in a range, list or just time */
export type DateTimeSelector = {
  /** After time */
  after?: Maybe<Scalars['ISO8601DateTime']>;
  /** Before time */
  before?: Maybe<Scalars['ISO8601DateTime']>;
  /** Range of time */
  between?: Maybe<Array<Scalars['ISO8601DateTime']>>;
  /** In times */
  in?: Maybe<Array<Scalars['ISO8601DateTime']>>;
  /** Time equals */
  is?: Maybe<Scalars['ISO8601DateTime']>;
  /** Time not equals */
  not?: Maybe<Scalars['ISO8601DateTime']>;
  /** Not in times */
  notIn?: Maybe<Array<Scalars['ISO8601DateTime']>>;
  /** Since time */
  since?: Maybe<Scalars['ISO8601DateTime']>;
  /** Till time */
  till?: Maybe<Scalars['ISO8601DateTime']>;
};

export enum DiemNetwork {
  /** Diem Testnet */
  DiemTestnet = 'diem_testnet',
  /** Libra Testnet */
  LibraTestnet = 'libra_testnet'
}

/** Elrond Chain */
export type Elrond = {
  __typename?: 'Elrond';
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<ElrondArgument>>;
  /** Information about validators of the block */
  blockValidators?: Maybe<Array<ElrondBlockValidator>>;
  /** Information about blocks */
  blocks?: Maybe<Array<ElrondBlock>>;
  /** Information about calls */
  callResults?: Maybe<Array<ElrondCallResult>>;
  /** Information about calls */
  calls?: Maybe<Array<ElrondCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<ElrondCoinpath>>;
  /** Information about miniblocks */
  miniblocks?: Maybe<Array<ElrondMiniblock>>;
  /** Information about notarized block */
  notarizedBlock?: Maybe<Array<ElrondNotarizedBlock>>;
  /** Information about transactions */
  transactions?: Maybe<Array<ElrondTransaction>>;
  /** Information about transactions */
  transfers?: Maybe<Array<ElrondTransfer>>;
};


/** Elrond Chain */
export type ElrondArgumentsArgs = {
  any?: Maybe<Array<ElrondArgumentFilter>>;
  argumentIndex?: Maybe<IntegerSelector>;
  argumentValue?: Maybe<IntIdSelector>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  callDepth?: Maybe<IntegerSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  smartContractAddress?: Maybe<HashSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Elrond Chain */
export type ElrondBlockValidatorsArgs = {
  any?: Maybe<Array<ElrondBlockValidatorFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  validator?: Maybe<HashSelector>;
};


/** Elrond Chain */
export type ElrondBlocksArgs = {
  any?: Maybe<Array<ElrondBlockFilter>>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  nonce?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<IntegerSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Elrond Chain */
export type ElrondCallResultsArgs = {
  any?: Maybe<Array<ElrondCallResultFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  callResultData?: Maybe<StringSelector>;
  callResultDataOperation?: Maybe<StringSelector>;
  callResultGasLimit?: Maybe<FloatSelector>;
  callResultGasPrice?: Maybe<FloatSelector>;
  callResultHash?: Maybe<HashSelector>;
  callResultIndex?: Maybe<IntegerSelector>;
  callResultNonce?: Maybe<IntegerSelector>;
  callResultReceiver?: Maybe<HashSelector>;
  callResultRelayedValue?: Maybe<FloatSelector>;
  callResultSender?: Maybe<HashSelector>;
  callResultType?: Maybe<StringSelector>;
  callResultValue?: Maybe<FloatSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  originTxHash?: Maybe<HashSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  previousTxHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  relayed?: Maybe<StringSelector>;
  returnMessage?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Elrond Chain */
export type ElrondCallsArgs = {
  any?: Maybe<Array<ElrondCallFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  callDepth?: Maybe<StringSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  smartContractAddress?: Maybe<HashSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Elrond Chain */
export type ElrondCoinpathArgs = {
  currency?: Maybe<CurrencySelector>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Elrond Chain */
export type ElrondMiniblocksArgs = {
  any?: Maybe<Array<ElrondMiniblockFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  miniblockHash?: Maybe<HashSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  receiverBlockHash?: Maybe<HashSelector>;
  receiverShard?: Maybe<BigIntIdSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  type?: Maybe<StringSelector>;
};


/** Elrond Chain */
export type ElrondNotarizedBlockArgs = {
  any?: Maybe<Array<ElrondNotarizedBlockFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  notarizedBlockHash?: Maybe<HashSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Elrond Chain */
export type ElrondTransactionsArgs = {
  any?: Maybe<Array<ElrondTransactionFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  fee?: Maybe<FloatSelector>;
  gasLimit?: Maybe<FloatSelector>;
  gasPrice?: Maybe<FloatSelector>;
  gasUsed?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txNonce?: Maybe<IntegerSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  txValue?: Maybe<FloatSelector>;
  type?: Maybe<StringSelector>;
};


/** Elrond Chain */
export type ElrondTransfersArgs = {
  any?: Maybe<Array<ElrondTransferFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  currency?: Maybe<CurrencySelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  metadata?: Maybe<StringSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nftNonce?: Maybe<IntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  transferReason?: Maybe<TransferReasonSelector>;
  transferReceiver?: Maybe<AddressSelector>;
  transferSender?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};

/** Blockchain address hash */
export type ElrondAddressHash = {
  __typename?: 'ElrondAddressHash';
  /** String hex address representation */
  hex: Scalars['String'];
};

/** Arguments of Smart Contract Calls and Events */
export type ElrondArgument = {
  __typename?: 'ElrondArgument';
  any?: Maybe<Scalars['String']>;
  /** Information about arguments call */
  call?: Maybe<CallElrond>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Index of the argument */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about arguments miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Information about arguments block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about arguments transaction */
  transaction?: Maybe<TransactionElrond>;
  /** Value of the argument */
  value?: Maybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentAnyArgs = {
  of: ElrondArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentCallArgs = {
  callDepth?: Maybe<IntegerSelector>;
  smartContractAddress?: Maybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentCountArgs = {
  uniq?: Maybe<ElrondArgumentUniq>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentCountBigIntArgs = {
  uniq?: Maybe<ElrondArgumentUniq>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentIndexArgs = {
  argumentIndex?: Maybe<IntIdSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentMaximumArgs = {
  get?: Maybe<ElrondArgumentsMeasureable>;
  of: ElrondArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentMiniblockArgs = {
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentMinimumArgs = {
  get?: Maybe<ElrondArgumentsMeasureable>;
  of: ElrondArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentSenderBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentTransactionArgs = {
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  index?: Maybe<IntegerSelector>;
  nonce?: Maybe<IntegerSelector>;
  signature?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type ElrondArgumentValueArgs = {
  argumentValue?: Maybe<StringSelector>;
};

export type ElrondArgumentFilter = {
  argumentIndex?: Maybe<IntegerSelector>;
  argumentValue?: Maybe<IntIdSelector>;
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  callDepth?: Maybe<IntegerSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  smartContractAddress?: Maybe<HashSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};

export enum ElrondArgumentUniq {
  /** Unique number of arguments */
  ArgumentIndex = 'argument_index',
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Transaction Hash */
  Signature = 'signature',
  /** Unique time */
  Times = 'times'
}

export enum ElrondArgumentsMeasureable {
  /** Argument Index */
  ArgumentIndex = 'argument_index',
  /** Argument Value */
  ArgumentValue = 'argument_value',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Smart Contract call path */
  CallDepth = 'call_depth',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Smart Contract Address */
  SmartContractAddress = 'smart_contract_address',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Transaction Signature */
  TxSignature = 'tx_signature',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

/** Blocks in Elrond  blockchain */
export type ElrondBlock = {
  __typename?: 'ElrondBlock';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Epoch */
  epoch?: Maybe<Scalars['Int']>;
  /** Hash of the the block */
  hash?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  proposer?: Maybe<ElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']>;
  /** Round */
  round?: Maybe<Scalars['BigInt']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']>;
  /** Size */
  size?: Maybe<Scalars['Int']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockAnyArgs = {
  of: ElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockCountArgs = {
  uniq?: Maybe<ElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockCountBigIntArgs = {
  uniq?: Maybe<ElrondBlockUniq>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockEpochArgs = {
  epoch?: Maybe<IntegerSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockHashArgs = {
  hash?: Maybe<HashSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockMaximumArgs = {
  get?: Maybe<ElrondBlocksMeasureable>;
  of: ElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockMinimumArgs = {
  get?: Maybe<ElrondBlocksMeasureable>;
  of: ElrondBlocksMeasureable;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockNonceArgs = {
  nonce?: Maybe<IntegerSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockPreviousBlockHashArgs = {
  previousBlockHash?: Maybe<HashSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockProposerArgs = {
  proposer?: Maybe<HashSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockPublicKeyBitmapArgs = {
  publicKeyBitmap?: Maybe<StringSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockRoundArgs = {
  round?: Maybe<IntegerSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockShardArgs = {
  shard?: Maybe<BigIntIdSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockSizeArgs = {
  size?: Maybe<IntegerSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockSizeTxsArgs = {
  sizeTxs?: Maybe<IntegerSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockStateRootHashArgs = {
  stateRootHash?: Maybe<HashSelector>;
};


/** Blocks in Elrond  blockchain */
export type ElrondBlockTransactionCountArgs = {
  transactionCount?: Maybe<IntegerSelector>;
};

/** Information about block */
export type ElrondBlockDimension = {
  __typename?: 'ElrondBlockDimension';
  /** Epoch */
  epoch?: Maybe<Scalars['Int']>;
  /** Hash of the block */
  hash?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  /** Block Height */
  nonce?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Proposer block hash */
  proposer?: Maybe<ElrondAddressHash>;
  /** Public Key Bitmap */
  publicKeyBitmap?: Maybe<Scalars['String']>;
  /** Round */
  round?: Maybe<Scalars['BigInt']>;
  /** Shard number of block */
  shard?: Maybe<Scalars['String']>;
  /** Size */
  size?: Maybe<Scalars['Int']>;
  /** Size Tx */
  sizeTxs?: Maybe<Scalars['Int']>;
  /** State root hash */
  stateRootHash?: Maybe<Scalars['String']>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['BigInt']>;
};


/** Information about block */
export type ElrondBlockDimensionEpochArgs = {
  epoch?: Maybe<IntegerSelector>;
};


/** Information about block */
export type ElrondBlockDimensionHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** Information about block */
export type ElrondBlockDimensionHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Information about block */
export type ElrondBlockDimensionNonceArgs = {
  blockNonce?: Maybe<IntegerSelector>;
};


/** Information about block */
export type ElrondBlockDimensionPreviousBlockHashArgs = {
  previousBlockHash?: Maybe<HashSelector>;
};


/** Information about block */
export type ElrondBlockDimensionProposerArgs = {
  proposer?: Maybe<HashSelector>;
};


/** Information about block */
export type ElrondBlockDimensionPublicKeyBitmapArgs = {
  publicKeyBitmap?: Maybe<StringSelector>;
};


/** Information about block */
export type ElrondBlockDimensionRoundArgs = {
  round?: Maybe<IntegerSelector>;
};


/** Information about block */
export type ElrondBlockDimensionShardArgs = {
  shard?: Maybe<IntIdSelector>;
};


/** Information about block */
export type ElrondBlockDimensionSizeArgs = {
  size?: Maybe<IntegerSelector>;
};


/** Information about block */
export type ElrondBlockDimensionSizeTxsArgs = {
  sizeTxs?: Maybe<IntegerSelector>;
};


/** Information about block */
export type ElrondBlockDimensionStateRootHashArgs = {
  stateRootHash?: Maybe<HashSelector>;
};


/** Information about block */
export type ElrondBlockDimensionTransactionCountArgs = {
  transactionCount?: Maybe<IntegerSelector>;
};

export type ElrondBlockFilter = {
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  nonce?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<IntegerSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};

export enum ElrondBlockUniq {
  /** Unique Number of Shards in the blockchains */
  BlockShard = 'block_shard',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidator = {
  __typename?: 'ElrondBlockValidator';
  any?: Maybe<Scalars['String']>;
  /** Information about blocks notarized block */
  block?: Maybe<ElrondBlockDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Hash of validator */
  validator?: Maybe<ElrondAddressHash>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidatorAnyArgs = {
  of: ElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidatorBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidatorCountArgs = {
  uniq?: Maybe<ElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidatorCountBigIntArgs = {
  uniq?: Maybe<ElrondBlockValidatorUniq>;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidatorMaximumArgs = {
  get?: Maybe<ElrondBlockValidatorsMeasureable>;
  of: ElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidatorMinimumArgs = {
  get?: Maybe<ElrondBlockValidatorsMeasureable>;
  of: ElrondBlockValidatorsMeasureable;
};


/** BlockValidators in Elrond  blockchain */
export type ElrondBlockValidatorValidatorArgs = {
  validator?: Maybe<HashSelector>;
};

export type ElrondBlockValidatorFilter = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  validator?: Maybe<HashSelector>;
};

export enum ElrondBlockValidatorUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times',
  /** Unique number of validators */
  Validators = 'validators'
}

export enum ElrondBlockValidatorsMeasureable {
  /** Date */
  Date = 'date',
  /** Block epoch */
  Epoch = 'epoch',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Block nonce */
  Nonce = 'nonce',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Block proposer */
  Proposer = 'proposer',
  /** Block public key bitmap */
  PublicKeyBitmap = 'public_key_bitmap',
  /** Block round */
  Round = 'round',
  /** Shard number of block */
  Shard = 'shard',
  /** Block size */
  Size = 'size',
  /** Block size txs */
  SizeTxs = 'size_txs',
  /** State root hash */
  StateRootHash = 'state_root_hash',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count',
  /** Hash of the validator */
  Validator = 'validator'
}

export enum ElrondBlocksMeasureable {
  /** Date */
  Date = 'date',
  /** Block epoch */
  Epoch = 'epoch',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Block nonce */
  Nonce = 'nonce',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Block proposer */
  Proposer = 'proposer',
  /** Block public key bitmap */
  PublicKeyBitmap = 'public_key_bitmap',
  /** Block round */
  Round = 'round',
  /** Shard number of block */
  Shard = 'shard',
  /** Block size */
  Size = 'size',
  /** Block size txs */
  SizeTxs = 'size_txs',
  /** State root hash */
  StateRootHash = 'state_root_hash',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count'
}

/** Calls in Elrond blockchain */
export type ElrondCall = {
  __typename?: 'ElrondCall';
  any?: Maybe<Scalars['String']>;
  /**
   * Depth of the call. Empty string for external call, then counted
   * as 0...N, and the next layer is added through '-'. For example 0-3-9.
   */
  callDepth?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Information about calls block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** Contract method invoked */
  smartContractAddress?: Maybe<Address>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<TransactionElrond>;
};


/** Calls in Elrond blockchain */
export type ElrondCallAnyArgs = {
  of: ElrondCallsMeasureable;
};


/** Calls in Elrond blockchain */
export type ElrondCallCallDepthArgs = {
  callDepth?: Maybe<StringSelector>;
};


/** Calls in Elrond blockchain */
export type ElrondCallCountArgs = {
  uniq?: Maybe<ElrondCallsUni>;
};


/** Calls in Elrond blockchain */
export type ElrondCallCountBigIntArgs = {
  uniq?: Maybe<ElrondCallsUni>;
};


/** Calls in Elrond blockchain */
export type ElrondCallMaximumArgs = {
  get?: Maybe<ElrondCallsMeasureable>;
  of: ElrondCallsMeasureable;
};


/** Calls in Elrond blockchain */
export type ElrondCallMiniblockArgs = {
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Calls in Elrond blockchain */
export type ElrondCallMinimumArgs = {
  get?: Maybe<ElrondCallsMeasureable>;
  of: ElrondCallsMeasureable;
};


/** Calls in Elrond blockchain */
export type ElrondCallSenderBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Calls in Elrond blockchain */
export type ElrondCallSmartContractAddressArgs = {
  smartContractAddress?: Maybe<HashSelector>;
};


/** Calls in Elrond blockchain */
export type ElrondCallSmartContractMethodArgs = {
  smartContractMethod?: Maybe<MethodSelector>;
};


/** Calls in Elrond blockchain */
export type ElrondCallTransactionArgs = {
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  index?: Maybe<IntegerSelector>;
  nonce?: Maybe<IntegerSelector>;
  signature?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
};

export type ElrondCallFilter = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  callDepth?: Maybe<StringSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  smartContractAddress?: Maybe<HashSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};

/** CallResults in Elrond blockchain */
export type ElrondCallResult = {
  __typename?: 'ElrondCallResult';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Call result data */
  data?: Maybe<Scalars['String']>;
  /** Call result data operation */
  dataOperation?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Call result gas limit */
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** Call result gas price */
  gasPrice?: Maybe<Scalars['BigInt']>;
  /** Hash of the call result */
  hash?: Maybe<Scalars['String']>;
  /** Call result index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about calls miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Nonce of the call result */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Hash of the origin transaction */
  originTxHash?: Maybe<Scalars['String']>;
  /** Hash of the previous transaction */
  previousTxHash?: Maybe<Scalars['String']>;
  /** Call result receiver */
  receiver?: Maybe<Address>;
  /** Call result relayed */
  relayed?: Maybe<Scalars['String']>;
  relayedValue?: Maybe<Scalars['Float']>;
  /** Call result return message */
  returnMessage?: Maybe<Scalars['String']>;
  /** Call result sender */
  sender?: Maybe<Address>;
  /** Information about calls block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about calls transaction */
  transaction?: Maybe<TransactionElrond>;
  /** Call result type */
  type?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['Float']>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultAnyArgs = {
  of: ElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultCountArgs = {
  uniq?: Maybe<ElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultCountBigIntArgs = {
  uniq?: Maybe<ElrondCallResultUniq>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultDataArgs = {
  callResultData?: Maybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultDataOperationArgs = {
  callResultDataOperation?: Maybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultGasLimitArgs = {
  callResultGasLimit?: Maybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultGasPriceArgs = {
  callResultGasPrice?: Maybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultHashArgs = {
  callResultHash?: Maybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultIndexArgs = {
  callResultIndex?: Maybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultMaximumArgs = {
  get?: Maybe<ElrondCallResultsMeasureable>;
  of: ElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultMiniblockArgs = {
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultMinimumArgs = {
  get?: Maybe<ElrondCallResultsMeasureable>;
  of: ElrondCallResultsMeasureable;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultNonceArgs = {
  callResultNonce?: Maybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultOriginTxHashArgs = {
  originTxHash?: Maybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultPreviousTxHashArgs = {
  previousTxHash?: Maybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultReceiverArgs = {
  callResultReceiver?: Maybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultRelayedArgs = {
  relayed?: Maybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultRelayedValueArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  callResultData?: Maybe<StringSelector>;
  callResultDataOperation?: Maybe<StringSelector>;
  callResultGasLimit?: Maybe<FloatSelector>;
  callResultGasPrice?: Maybe<FloatSelector>;
  callResultHash?: Maybe<HashSelector>;
  callResultIndex?: Maybe<IntegerSelector>;
  callResultNonce?: Maybe<IntegerSelector>;
  callResultReceiver?: Maybe<HashSelector>;
  callResultRelayedValue?: Maybe<FloatSelector>;
  callResultSender?: Maybe<HashSelector>;
  callResultType?: Maybe<StringSelector>;
  callResultValue?: Maybe<FloatSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  originTxHash?: Maybe<HashSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  previousTxHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  relayed?: Maybe<StringSelector>;
  returnMessage?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultReturnMessageArgs = {
  returnMessage?: Maybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultSenderArgs = {
  callResultSender?: Maybe<HashSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultSenderBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultTransactionArgs = {
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  index?: Maybe<IntegerSelector>;
  nonce?: Maybe<IntegerSelector>;
  signature?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultTypeArgs = {
  callResultType?: Maybe<StringSelector>;
};


/** CallResults in Elrond blockchain */
export type ElrondCallResultValueArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  callResultData?: Maybe<StringSelector>;
  callResultDataOperation?: Maybe<StringSelector>;
  callResultGasLimit?: Maybe<FloatSelector>;
  callResultGasPrice?: Maybe<FloatSelector>;
  callResultHash?: Maybe<HashSelector>;
  callResultIndex?: Maybe<IntegerSelector>;
  callResultNonce?: Maybe<IntegerSelector>;
  callResultReceiver?: Maybe<HashSelector>;
  callResultRelayedValue?: Maybe<FloatSelector>;
  callResultSender?: Maybe<HashSelector>;
  callResultType?: Maybe<StringSelector>;
  callResultValue?: Maybe<FloatSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  originTxHash?: Maybe<HashSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  previousTxHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  relayed?: Maybe<StringSelector>;
  returnMessage?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};

export type ElrondCallResultFilter = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  callResultData?: Maybe<StringSelector>;
  callResultDataOperation?: Maybe<StringSelector>;
  callResultGasLimit?: Maybe<FloatSelector>;
  callResultGasPrice?: Maybe<FloatSelector>;
  callResultHash?: Maybe<HashSelector>;
  callResultIndex?: Maybe<IntegerSelector>;
  callResultNonce?: Maybe<IntegerSelector>;
  callResultReceiver?: Maybe<HashSelector>;
  callResultRelayedValue?: Maybe<FloatSelector>;
  callResultSender?: Maybe<HashSelector>;
  callResultType?: Maybe<StringSelector>;
  callResultValue?: Maybe<FloatSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  originTxHash?: Maybe<HashSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  previousTxHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  relayed?: Maybe<StringSelector>;
  returnMessage?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};

export enum ElrondCallResultUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of call results */
  Index = 'index',
  /** Unique time */
  Times = 'times'
}

export enum ElrondCallResultsMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Data of the call result */
  CallResultData = 'call_result_data',
  /** Hash of the call result */
  CallResultHash = 'call_result_hash',
  /** Index of the call result */
  CallResultIndex = 'call_result_index',
  /** Receiver of the call result */
  CallResultReceiver = 'call_result_receiver',
  /** Sender of the call result */
  CallResultSender = 'call_result_sender',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Previous transaction hash of the call result */
  PreviousTxHash = 'previous_tx_hash',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

export enum ElrondCallsMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

export enum ElrondCallsUni {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique Number of smart contract methods */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique Number of smart contract */
  SmartContracts = 'smart_contracts',
  /** Unique time */
  Times = 'times'
}

/** Elrond Coinpath */
export type ElrondCoinpath = {
  __typename?: 'ElrondCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<ElrondTransactionValueDimension>;
};


/** Elrond Coinpath */
export type ElrondCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Elrond Coinpath */
export type ElrondCoinpathAnyArgs = {
  of: ElrondCoinpathMeasureable;
};


/** Elrond Coinpath */
export type ElrondCoinpathMaximumArgs = {
  get?: Maybe<ElrondCoinpathMeasureable>;
  of: ElrondCoinpathMeasureable;
};


/** Elrond Coinpath */
export type ElrondCoinpathMinimumArgs = {
  get?: Maybe<ElrondCoinpathMeasureable>;
  of: ElrondCoinpathMeasureable;
};

export enum ElrondCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Version */
  TxHash = 'tx_hash'
}

/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblock = {
  __typename?: 'ElrondMiniblock';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']>;
  /** Information about miniblocks block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockAnyArgs = {
  of: ElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockCountArgs = {
  uniq?: Maybe<ElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockCountBigIntArgs = {
  uniq?: Maybe<ElrondMiniblockUniq>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockHashArgs = {
  miniblockHash?: Maybe<HashSelector>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockMaximumArgs = {
  get?: Maybe<ElrondMiniblocksMeasureable>;
  of: ElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockMinimumArgs = {
  get?: Maybe<ElrondMiniblocksMeasureable>;
  of: ElrondMiniblocksMeasureable;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockReceiverBlockHashArgs = {
  receiverBlockHash?: Maybe<HashSelector>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockReceiverShardArgs = {
  receiverShard?: Maybe<BigIntIdSelector>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockSenderBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Miniblocks in Elrond  blockchain */
export type ElrondMiniblockTypeArgs = {
  type?: Maybe<StringSelector>;
};

export type ElrondMiniblockFilter = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  miniblockHash?: Maybe<HashSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  receiverBlockHash?: Maybe<HashSelector>;
  receiverShard?: Maybe<BigIntIdSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  type?: Maybe<StringSelector>;
};

export enum ElrondMiniblockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

export enum ElrondMiniblocksMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Hash of the miniblock */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Hash of the miniblocks receiver block */
  ReceiverBlockHash = 'receiver_block_hash',
  /** Miniblock receiver shard */
  ReceiverShard = 'receiver_shard',
  /** Time */
  Time = 'time',
  /** Count of transactions */
  TransactionCount = 'transaction_count',
  /** Type of miniblock */
  Type = 'type'
}

export enum ElrondNetwork {
  /** Elrond mainnet */
  Elrond = 'elrond'
}

/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlock = {
  __typename?: 'ElrondNotarizedBlock';
  any?: Maybe<Scalars['String']>;
  /** Information about blocks notarized block */
  block?: Maybe<ElrondBlockDimension>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Hash of the notarized block */
  notarizedBlockHash?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlockAnyArgs = {
  of: ElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlockBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlockCountArgs = {
  uniq?: Maybe<ElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlockCountBigIntArgs = {
  uniq?: Maybe<ElrondNotarizedBlockUniq>;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlockMaximumArgs = {
  get?: Maybe<ElrondNotarizedBlocksMeasureable>;
  of: ElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlockMinimumArgs = {
  get?: Maybe<ElrondNotarizedBlocksMeasureable>;
  of: ElrondNotarizedBlocksMeasureable;
};


/** NotarizedBlocks in Elrond blockchain */
export type ElrondNotarizedBlockNotarizedBlockHashArgs = {
  notarizedBlockHash?: Maybe<HashSelector>;
};

export type ElrondNotarizedBlockFilter = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  notarizedBlockHash?: Maybe<HashSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};

export enum ElrondNotarizedBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique hash of notarized block */
  NotarizedBlockHash = 'notarized_block_hash',
  /** Unique time */
  Times = 'times'
}

export enum ElrondNotarizedBlocksMeasureable {
  /** Date */
  Date = 'date',
  /** Block epoch */
  Epoch = 'epoch',
  /** Hash of the the block */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Block nonce */
  Nonce = 'nonce',
  /** Notarized block hash */
  NotarizedBlockHash = 'notarized_block_hash',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Block proposer */
  Proposer = 'proposer',
  /** Block public key bitmap */
  PublicKeyBitmap = 'public_key_bitmap',
  /** Block round */
  Round = 'round',
  /** Shard number of block */
  Shard = 'shard',
  /** Block size */
  Size = 'size',
  /** Block size txs */
  SizeTxs = 'size_txs',
  /** State root hash */
  StateRootHash = 'state_root_hash',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count'
}

/** Transactions in Elrond blockchain */
export type ElrondTransaction = {
  __typename?: 'ElrondTransaction';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** Data operation */
  dataOperation?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  fee?: Maybe<Scalars['Float']>;
  /** Number of gas limit */
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** Number of gas price */
  gasPrice?: Maybe<Scalars['BigInt']>;
  /** Number of gas used */
  gasUsed?: Maybe<Scalars['BigInt']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Information about transactions miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** TX  receiver */
  receiver?: Maybe<Address>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BigInt']>;
  /** Hash of the sender */
  sender?: Maybe<Address>;
  /** Information about transactions block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BigInt']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Tx Status */
  status?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  value?: Maybe<Scalars['Float']>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionAnyArgs = {
  of: ElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionCountArgs = {
  uniq?: Maybe<ElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionCountBigIntArgs = {
  uniq?: Maybe<ElrondTransactionUniq>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionDataArgs = {
  data?: Maybe<StringSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionDataOperationArgs = {
  dataOperation?: Maybe<StringSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionFeeArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  fee?: Maybe<FloatSelector>;
  gasLimit?: Maybe<FloatSelector>;
  gasPrice?: Maybe<FloatSelector>;
  gasUsed?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txNonce?: Maybe<IntegerSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  txValue?: Maybe<FloatSelector>;
  type?: Maybe<StringSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionGasLimitArgs = {
  gasLimit?: Maybe<IntegerSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionGasPriceArgs = {
  gasPrice?: Maybe<IntegerSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionGasUsedArgs = {
  gasUsed?: Maybe<IntegerSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionIndexArgs = {
  txIndex?: Maybe<IntegerSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionMaximumArgs = {
  get?: Maybe<ElrondTransactionsMeasureable>;
  of: ElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionMiniblockArgs = {
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionMinimumArgs = {
  get?: Maybe<ElrondTransactionsMeasureable>;
  of: ElrondTransactionsMeasureable;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionNonceArgs = {
  txNonce?: Maybe<IntegerSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionReceiverArgs = {
  txReceiver?: Maybe<HashSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionReceiverShardArgs = {
  txReceiverShard?: Maybe<BigIntIdSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionSenderArgs = {
  txSender?: Maybe<HashSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionSenderBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionSenderShardArgs = {
  txSenderShard?: Maybe<BigIntIdSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionSignatureArgs = {
  signature?: Maybe<HashSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionStatusArgs = {
  status?: Maybe<StringSelector>;
};


/** Transactions in Elrond blockchain */
export type ElrondTransactionValueArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  fee?: Maybe<FloatSelector>;
  gasLimit?: Maybe<FloatSelector>;
  gasPrice?: Maybe<FloatSelector>;
  gasUsed?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txNonce?: Maybe<IntegerSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  txValue?: Maybe<FloatSelector>;
  type?: Maybe<StringSelector>;
};

export type ElrondTransactionFilter = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  fee?: Maybe<FloatSelector>;
  gasLimit?: Maybe<FloatSelector>;
  gasPrice?: Maybe<FloatSelector>;
  gasUsed?: Maybe<FloatSelector>;
  height?: Maybe<BlockSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<IntegerSelector>;
  txNonce?: Maybe<IntegerSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  txValue?: Maybe<FloatSelector>;
  type?: Maybe<StringSelector>;
};

export enum ElrondTransactionUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

/** Blockchain transaction with value */
export type ElrondTransactionValueDimension = {
  __typename?: 'ElrondTransactionValueDimension';
  /** Transaction hash */
  hash: Scalars['String'];
  /** Transaction value */
  value: Scalars['Float'];
};

export enum ElrondTransactionsMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Transaction hash */
  Hash = 'hash',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Type of miniblock */
  Type = 'type',
  /** Value */
  Value = 'value'
}

/** Transfers of Smart Contract Calls and Events */
export type ElrondTransfer = {
  __typename?: 'ElrondTransfer';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']>;
  /** Information about arguments miniblock */
  miniblock?: Maybe<MiniblockElrond>;
  minimum?: Maybe<Scalars['String']>;
  /** NFT nonce */
  nftNonce?: Maybe<Scalars['String']>;
  /** How the money was transferred */
  reason?: Maybe<Scalars['String']>;
  /** Receiver account address */
  receiver?: Maybe<Address>;
  /** Sender account address */
  sender?: Maybe<Address>;
  /** Information about arguments block */
  senderBlock?: Maybe<ElrondBlockDimension>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Information about arguments transaction */
  transaction?: Maybe<TransactionElrond>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferAmountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<CurrencySelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  metadata?: Maybe<StringSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nftNonce?: Maybe<IntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  transferReason?: Maybe<TransferReasonSelector>;
  transferReceiver?: Maybe<AddressSelector>;
  transferSender?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferAnyArgs = {
  of: ElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferCountArgs = {
  uniq?: Maybe<ElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  currency?: Maybe<CurrencySelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  metadata?: Maybe<StringSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nftNonce?: Maybe<IntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  transferReason?: Maybe<TransferReasonSelector>;
  transferReceiver?: Maybe<AddressSelector>;
  transferSender?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
  uniq?: Maybe<ElrondTransferUniq>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferCurrencyArgs = {
  currency?: Maybe<CurrencySelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferMaximumArgs = {
  get?: Maybe<ElrondTransfersMeasureable>;
  of: ElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferMetadataArgs = {
  metadata?: Maybe<StringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferMiniblockArgs = {
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferMinimumArgs = {
  get?: Maybe<ElrondTransfersMeasureable>;
  of: ElrondTransfersMeasureable;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferNftNonceArgs = {
  nftNonce?: Maybe<IntIdSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferReasonArgs = {
  transferReason?: Maybe<TransferReasonSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferReceiverArgs = {
  transferReceiver?: Maybe<AddressSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferSenderArgs = {
  transferSender?: Maybe<AddressSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferSenderBlockArgs = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Transfers of Smart Contract Calls and Events */
export type ElrondTransferTransactionArgs = {
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  index?: Maybe<IntegerSelector>;
  nonce?: Maybe<IntegerSelector>;
  signature?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
};

export type ElrondTransferFilter = {
  blockHash?: Maybe<HashSelector>;
  blockNonce?: Maybe<IntegerSelector>;
  currency?: Maybe<CurrencySelector>;
  data?: Maybe<StringSelector>;
  dataOperation?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  epoch?: Maybe<IntegerSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  metadata?: Maybe<StringSelector>;
  miniblockHash?: Maybe<HashSelector>;
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
  miniblockReceiverShard?: Maybe<BigIntIdSelector>;
  nftNonce?: Maybe<IntIdSelector>;
  nonce?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  proposer?: Maybe<HashSelector>;
  publicKeyBitmap?: Maybe<StringSelector>;
  round?: Maybe<IntegerSelector>;
  shard?: Maybe<BigIntIdSelector>;
  signature?: Maybe<HashSelector>;
  size?: Maybe<IntegerSelector>;
  sizeTxs?: Maybe<IntegerSelector>;
  stateRootHash?: Maybe<HashSelector>;
  status?: Maybe<StringSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<IntegerSelector>;
  transferReason?: Maybe<TransferReasonSelector>;
  transferReceiver?: Maybe<AddressSelector>;
  transferSender?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txReceiver?: Maybe<HashSelector>;
  txReceiverShard?: Maybe<BigIntIdSelector>;
  txSender?: Maybe<HashSelector>;
  txSenderShard?: Maybe<BigIntIdSelector>;
  type?: Maybe<StringSelector>;
};

export enum ElrondTransferUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Transaction Hash */
  Signature = 'signature',
  /** Unique time */
  Times = 'times'
}

export enum ElrondTransfersMeasureable {
  /** Transfer Amount */
  Amount = 'amount',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Data */
  Data = 'data',
  /** Date */
  Date = 'date',
  /** Gas Limit */
  GasLimit = 'gas_limit',
  /** Gas Price */
  GasPrice = 'gas_price',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Number of block in the blockhains */
  Height = 'height',
  /** Hash of the miniblock */
  MiniblockHash = 'miniblock_hash',
  /** Hash of the miniblocks receiver block */
  MiniblockReceiverBlockHash = 'miniblock_receiver_block_hash',
  /** Miniblock receiver shard */
  MiniblockReceiverShard = 'miniblock_receiver_shard',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** The block hash of this block`s parent */
  TransactionCount = 'transaction_count',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Receiver hash */
  TxReceiver = 'tx_receiver',
  /** Shard number of the receiver */
  TxReceiverShard = 'tx_receiver_shard',
  /** Sender hash */
  TxSender = 'tx_sender',
  /** Shard number of the sender */
  TxSenderShard = 'tx_sender_shard',
  /** Value */
  TxValue = 'tx_value',
  /** Type of miniblock */
  Type = 'type'
}

/** Entity */
export type Entity = {
  __typename?: 'Entity';
  /** Entity ID */
  id: Scalars['String'];
  /** Entity number */
  num: Scalars['Int'];
  /** Entity realm ID */
  realmId: Scalars['Int'];
  /** Entity shard ID */
  shardId: Scalars['Int'];
  /** Entity Type */
  type: Scalars['String'];
};


/** Entity */
export type EntityIdArgs = {
  entityId?: Maybe<Scalars['String']>;
};

/** Selector of entity ID for NFT  tokens */
export type EntitySelector = {
  /** EntityID in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** EntityID is */
  is?: Maybe<Scalars['String']>;
  /** EntityID not */
  not?: Maybe<Scalars['String']>;
  /** EntityID not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

export enum EntityTypeEnum {
  /** account */
  Account = 'account',
  /** contract */
  Contract = 'contract',
  /** file */
  File = 'file',
  /** schedule */
  Schedule = 'schedule',
  /** token */
  Token = 'token',
  /** topic */
  Topic = 'topic'
}

/** Select by entity type */
export type EntityTypeSelector = {
  /** Type in the list */
  in?: Maybe<Array<EntityTypeEnum>>;
  /** Type is */
  is?: Maybe<EntityTypeEnum>;
  /** Type not */
  not?: Maybe<EntityTypeEnum>;
  /** Type not in the list */
  notIn?: Maybe<Array<EntityTypeEnum>>;
};

/** EOS Chain */
export type Eos = {
  __typename?: 'Eos';
  /** Basic information about address ( or smart contract ) */
  address: Array<EosAddressInfo>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<EosBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<EosCoinpath>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<EosSmartContractCalls>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<EosTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<EosTransfers>>;
};


/** EOS Chain */
export type EosAddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** EOS Chain */
export type EosBlocksArgs = {
  any?: Maybe<Array<EosBlockFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  proposer?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** EOS Chain */
export type EosCoinpathArgs = {
  currency?: Maybe<EosCurrencySelector>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** EOS Chain */
export type EosSmartContractCallsArgs = {
  any?: Maybe<Array<EosSmartContractCallFilter>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  scheduled?: Maybe<Scalars['Boolean']>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** EOS Chain */
export type EosTransactionsArgs = {
  any?: Maybe<Array<EosTransactionFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  scheduled?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** EOS Chain */
export type EosTransfersArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<EosTransferFilter>>;
  currency?: Maybe<EosCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** Address detailed information for EOS network */
export type EosAddressInfo = {
  __typename?: 'EosAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EosSmartContractInfo>;
};

export type EosBlockFilter = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  proposer?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};

/** Blocks in EOS blockchain */
export type EosBlocks = {
  __typename?: 'EosBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block producer */
  producer?: Maybe<Address>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
};


/** Blocks in EOS blockchain */
export type EosBlocksAnyArgs = {
  of: EosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type EosBlocksCountArgs = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  proposer?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<EosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type EosBlocksCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  proposer?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<EosBlocksUniq>;
};


/** Blocks in EOS blockchain */
export type EosBlocksHashArgs = {
  blockHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in EOS blockchain */
export type EosBlocksHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in EOS blockchain */
export type EosBlocksMaximumArgs = {
  get?: Maybe<EosBlocksMeasureable>;
  of: EosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type EosBlocksMinimumArgs = {
  get?: Maybe<EosBlocksMeasureable>;
  of: EosBlocksMeasureable;
};


/** Blocks in EOS blockchain */
export type EosBlocksProducerArgs = {
  producer?: Maybe<AddressSelector>;
};


/** Blocks in EOS blockchain */
export type EosBlocksTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};

export enum EosBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Block Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time'
}

export enum EosBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique proposer count */
  Proposers = 'proposers'
}

export enum EosCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Sender */
  TxSender = 'tx_sender',
  /** Action To */
  TxTo = 'tx_to'
}

/** Coinpath */
export type EosCoinpath = {
  __typename?: 'EosCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<EosAddressInfo>;
  /** Sender address */
  sender?: Maybe<EosAddressInfo>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
};


/** Coinpath */
export type EosCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type EosCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EosCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EosCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/**
 * Currency selector in EOS blockchain.
 * Token identified by address of contract ( eosio.token for main EOS token )
 */
export type EosCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

export enum EosNetwork {
  /** EOS mainnet */
  Eos = 'eos'
}

/** Eos smart contract */
export type EosSmartContract = {
  __typename?: 'EosSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<Currency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EosSmartContractCallFilter = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** Smart Contract Calls */
export type EosSmartContractCalls = {
  __typename?: 'EosSmartContractCalls';
  /** Actors */
  actors?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Console */
  console?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Error Code */
  errorCode?: Maybe<Scalars['Int']>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Permissions */
  permissions?: Maybe<Scalars['String']>;
  /** Receivers */
  receivers?: Maybe<Scalars['String']>;
  /** True if call scheduled */
  scheduled?: Maybe<Scalars['Boolean']>;
  /** Smart contract being called */
  smartContract?: Maybe<EosSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsAnyArgs = {
  of: EosCallsMeasureable;
};


/** Smart Contract Calls */
export type EosSmartContractCallsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsCountArgs = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsErrorCodeArgs = {
  errorCode?: Maybe<IntIdSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsMaximumArgs = {
  get?: Maybe<EosCallsMeasureable>;
  of: EosCallsMeasureable;
};


/** Smart Contract Calls */
export type EosSmartContractCallsMinimumArgs = {
  get?: Maybe<EosCallsMeasureable>;
  of: EosCallsMeasureable;
};


/** Smart Contract Calls */
export type EosSmartContractCallsScheduledArgs = {
  scheduled?: Maybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsSmartContractArgs = {
  smartContractAddress?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: Maybe<MethodSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsSuccessArgs = {
  success?: Maybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsTxFromArgs = {
  txFrom?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Smart Contract Calls */
export type EosSmartContractCallsTxToArgs = {
  txTo?: Maybe<AddressSelector>;
};

/** Blockchain smart contract */
export type EosSmartContractInfo = {
  __typename?: 'EosSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<Currency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EosTransactionFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};

/** Transactions in EOS blockchain */
export type EosTransactions = {
  __typename?: 'EosTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  cpuUsageUs?: Maybe<Scalars['Int']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsageWords?: Maybe<Scalars['Int']>;
  /** Success */
  scheduled?: Maybe<Scalars['Boolean']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsAnyArgs = {
  of: EosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type EosTransactionsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  uniq?: Maybe<EosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  uniq?: Maybe<EosTransactionsUniq>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsCpuUsageUsArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsHashArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsIndexArgs = {
  txIndex?: Maybe<Array<TxIndexSelector>>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsMaximumArgs = {
  get?: Maybe<EosTransactionsMeasureable>;
  of: EosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type EosTransactionsMinimumArgs = {
  get?: Maybe<EosTransactionsMeasureable>;
  of: EosTransactionsMeasureable;
};


/** Transactions in EOS blockchain */
export type EosTransactionsNetUsageWordsArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  scheduled?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsScheduledArgs = {
  scheduled?: Maybe<Scalars['Boolean']>;
};


/** Transactions in EOS blockchain */
export type EosTransactionsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};

export enum EosTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** CPU Usage */
  CpuUsageUs = 'cpu_usage_us',
  /** Date */
  Date = 'date',
  /** Net Usage */
  NetUsageWords = 'net_usage_words',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum EosTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export type EosTransferFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<EosCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfers = {
  __typename?: 'EosTransfers';
  /** Actors */
  actors?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  maximum?: Maybe<Scalars['String']>;
  /** Memo */
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<EosCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersAnyArgs = {
  of: EosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<EosCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<EosCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersCurrencyArgs = {
  currency?: Maybe<EosCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersEntityIdArgs = {
  entityId?: Maybe<EntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersMaximumArgs = {
  get?: Maybe<EosTransfersMeasureable>;
  of: EosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersMinimumArgs = {
  get?: Maybe<EosTransfersMeasureable>;
  of: EosTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersReceiverArgs = {
  receiver?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersSenderArgs = {
  sender?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersTxFromArgs = {
  txFrom?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EosTransfersTxToArgs = {
  txTo?: Maybe<AddressSelector>;
};

export enum EosTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Ethereum Chain */
export type Ethereum = {
  __typename?: 'Ethereum';
  /** Basic information about address ( or smart contract ) */
  address: Array<EthereumAddressInfoWithBalance>;
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<EthereumArguments>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<EthereumBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<EthereumCoinpath>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<EthereumDexTrades>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<EthereumSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<EthereumSmartContractEvent>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<EthereumTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<EthereumTransfers>>;
};


/** Ethereum Chain */
export type EthereumAddressArgs = {
  address: Array<EthereumAddressSelectorIn>;
};


/** Ethereum Chain */
export type EthereumArgumentsArgs = {
  any?: Maybe<Array<EthereumArgumentFilter>>;
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Ethereum Chain */
export type EthereumBlocksArgs = {
  any?: Maybe<Array<EthereumBlockFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  options?: Maybe<QueryOptions>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Ethereum Chain */
export type EthereumCoinpathArgs = {
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<EthereumAddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<EthereumAddressSelector>;
  sender?: Maybe<EthereumAddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Ethereum Chain */
export type EthereumDexTradesArgs = {
  any?: Maybe<Array<EthereumDexTradeFilter>>;
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  options?: Maybe<QueryOptions>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Ethereum Chain */
export type EthereumSmartContractCallsArgs = {
  any?: Maybe<Array<EthereumSmartContractCallFilter>>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: Maybe<MethodSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  success?: Maybe<Array<Scalars['Boolean']>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Ethereum Chain */
export type EthereumSmartContractEventsArgs = {
  any?: Maybe<Array<EthereumSmartContractEventFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Ethereum Chain */
export type EthereumTransactionsArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<EthereumTransactionFilter>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Ethereum Chain */
export type EthereumTransfersArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<EthereumTransferFilter>>;
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<Array<EthereumAddressSelector>>;
  sender?: Maybe<Array<EthereumAddressSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};

/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2 = {
  __typename?: 'Ethereum2';
  /** Attestations in block */
  attestations?: Maybe<Array<Ethereum2Attestation>>;
  /** Attester Slashings */
  attesterSlashings?: Maybe<Array<Ethereum2AttesterSlashing>>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<Ethereum2Blocks>>;
  /** Attestations of blocks */
  deposits?: Maybe<Array<Ethereum2Deposit>>;
  /** Proposer Slashings */
  proposerSlashings?: Maybe<Array<Ethereum2ProposerSlashing>>;
  /** Voluntary Exits */
  voluntaryExits?: Maybe<Array<Ethereum2VoluntaryExit>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2AttestationsArgs = {
  any?: Maybe<Array<Ethereum2Filter>>;
  attestationEpoch?: Maybe<Array<IntegerSelector>>;
  attestationSlot?: Maybe<Array<IntegerSelector>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  committeeIndex?: Maybe<Array<IntegerSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2AttesterSlashingsArgs = {
  any?: Maybe<Array<Ethereum2Filter>>;
  attestationEpoch?: Maybe<Array<IntegerSelector>>;
  attestationSlot?: Maybe<Array<IntegerSelector>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2BlocksArgs = {
  any?: Maybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2DepositsArgs = {
  any?: Maybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2ProposerSlashingsArgs = {
  any?: Maybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  slashingEpoch?: Maybe<Array<IntegerSelector>>;
  slashingProposerIndex?: Maybe<Array<IntegerSelector>>;
  slashingSlot?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Ethereum v 2.0 Baecon Chain */
export type Ethereum2VoluntaryExitsArgs = {
  any?: Maybe<Array<Ethereum2Filter>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
  voluntaryExitEpoch?: Maybe<Array<IntegerSelector>>;
};

/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2Attestation = {
  __typename?: 'Ethereum2Attestation';
  aggregationBits: Scalars['String'];
  any?: Maybe<Scalars['String']>;
  attestation: Ethereum2AttestationInfo;
  /** Attestation Index (0 based ) in block */
  attestationIndex: Scalars['Int'];
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  /** Committee index for attestation */
  committeeIndex: Scalars['Int'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
  /** Sequential index of validator in committee ( 0-based) */
  validatorInCommitteeIndex: Scalars['Int'];
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationAnyArgs = {
  of: Ethereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationBlockRootArgs = {
  blockRootHash?: Maybe<Array<HashSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationCountArgs = {
  attestationEpoch?: Maybe<Array<IntegerSelector>>;
  attestationSlot?: Maybe<Array<IntegerSelector>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  committeeIndex?: Maybe<Array<IntegerSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2AttestationsUniq>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationCountBigIntArgs = {
  attestationEpoch?: Maybe<Array<IntegerSelector>>;
  attestationSlot?: Maybe<Array<IntegerSelector>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  committeeIndex?: Maybe<Array<IntegerSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2AttestationsUniq>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationMaximumArgs = {
  get?: Maybe<Ethereum2AttestationsMeasureable>;
  of: Ethereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationMinimumArgs = {
  get?: Maybe<Ethereum2AttestationsMeasureable>;
  of: Ethereum2AttestationsMeasureable;
};


/** Attestations in Ethereum v2.0 blockchain */
export type Ethereum2AttestationProposerArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
};

/** AttestationFieldInfo for Ethereum v 2.0 network */
export type Ethereum2AttestationFieldInfo = {
  __typename?: 'Ethereum2AttestationFieldInfo';
  epoch: Scalars['Int'];
  /** Root Hash */
  root: Scalars['String'];
};

/** AttestationInfo for Ethereum v 2.0 network */
export type Ethereum2AttestationInfo = {
  __typename?: 'Ethereum2AttestationInfo';
  beaconBlockRoot: Scalars['String'];
  epoch: Scalars['Int'];
  signature: Scalars['String'];
  slot: Scalars['Int'];
  source: Ethereum2AttestationFieldInfo;
  target: Ethereum2AttestationFieldInfo;
};

export enum Ethereum2AttestationsMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Committee Index */
  Committee = 'committee',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum Ethereum2AttestationsUniq {
  /** Unique attestation epochs */
  AttestationEpochs = 'attestation_epochs',
  /** Unique attestation slots */
  AttestationSlots = 'attestation_slots',
  /** Unique attestations */
  Attestations = 'attestations',
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique commitees */
  Committees = 'committees',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashing = {
  __typename?: 'Ethereum2AttesterSlashing';
  any?: Maybe<Scalars['String']>;
  attestation: Ethereum2AttestationInfo;
  /** Attestation slashing sequential number */
  attestationOrder: Scalars['Int'];
  /** Attester Slashing Index (0 based ) in block */
  attesterSlashingIndex: Scalars['Int'];
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
  /** Validator index in slashing sequential numbern */
  validatorInAttestationIndex: Scalars['Int'];
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingAnyArgs = {
  of: Ethereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingBlockRootArgs = {
  blockRootHash?: Maybe<Array<HashSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingCountArgs = {
  attestationEpoch?: Maybe<Array<IntegerSelector>>;
  attestationSlot?: Maybe<Array<IntegerSelector>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2AttesterSlashingsUniq>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingCountBigIntArgs = {
  attestationEpoch?: Maybe<Array<IntegerSelector>>;
  attestationSlot?: Maybe<Array<IntegerSelector>>;
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2AttesterSlashingsUniq>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingMaximumArgs = {
  get?: Maybe<Ethereum2AttesterSlashingMeasureable>;
  of: Ethereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingMinimumArgs = {
  get?: Maybe<Ethereum2AttesterSlashingMeasureable>;
  of: Ethereum2AttesterSlashingMeasureable;
};


/** Attester Slashing in Ethereum v2.0 blockchain */
export type Ethereum2AttesterSlashingProposerArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
};

export enum Ethereum2AttesterSlashingMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum Ethereum2AttesterSlashingsUniq {
  /** Unique slashing epochs */
  AttestationEpochs = 'attestation_epochs',
  /** Unique slashing slots */
  AttestationSlots = 'attestation_slots',
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2Blocks = {
  __typename?: 'Ethereum2Blocks';
  any?: Maybe<Scalars['String']>;
  attestationsCount?: Maybe<Scalars['Int']>;
  attestationsCountBigInt?: Maybe<Scalars['BigInt']>;
  attesterSlashingsCount?: Maybe<Scalars['Int']>;
  attesterSlashingsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  depositsCount?: Maybe<Scalars['Int']>;
  depositsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  /** Graffiti */
  graffiti: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  proposerSlashingsCount?: Maybe<Scalars['Int']>;
  proposerSlashingsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Randao Reveal */
  randaoReveal: Scalars['String'];
  /** Block signature */
  signature: Scalars['String'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  voluntaryExitsCount?: Maybe<Scalars['Int']>;
  voluntaryExitsCountBigInt?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksAnyArgs = {
  of: Ethereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksAttestationsCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksAttestationsCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksAttesterSlashingsCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksAttesterSlashingsCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksBlockRootArgs = {
  blockRootHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2BlocksUniq>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksDepositsCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksDepositsCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksMaximumArgs = {
  get?: Maybe<Ethereum2BlocksMeasureable>;
  of: Ethereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksMinimumArgs = {
  get?: Maybe<Ethereum2BlocksMeasureable>;
  of: Ethereum2BlocksMeasureable;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksProposerArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksProposerSlashingsCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksProposerSlashingsCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksVoluntaryExitsCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum v2.0 blockchain */
export type Ethereum2BlocksVoluntaryExitsCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};

export enum Ethereum2BlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block Miner */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time'
}

export enum Ethereum2BlocksUniq {
  /** Unique proposers */
  BlockProposers = 'block_proposers',
  /** Unique date count */
  Dates = 'dates'
}

/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2Deposit = {
  __typename?: 'Ethereum2Deposit';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Deposit Index (0 based ) in block */
  depositIndex: Scalars['Int'];
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  proof: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  signature: Scalars['String'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositAmountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositAnyArgs = {
  of: Ethereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositBlockRootArgs = {
  blockRootHash?: Maybe<Array<HashSelector>>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2DepositsUniq>;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositMaximumArgs = {
  get?: Maybe<Ethereum2DepositsMeasureable>;
  of: Ethereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositMinimumArgs = {
  get?: Maybe<Ethereum2DepositsMeasureable>;
  of: Ethereum2DepositsMeasureable;
};


/** Deposit in Ethereum v2.0 blockchain */
export type Ethereum2DepositProposerArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
};

export enum Ethereum2DepositsMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum Ethereum2DepositsUniq {
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Eth1 attributes for Ethereum v 2.0 network */
export type Ethereum2Eth1Info = {
  __typename?: 'Ethereum2Eth1Info';
  /** Block Eth1 block hash */
  blockHash: Scalars['String'];
  /** Block Eth1 deposit count */
  depositCount: Scalars['Int'];
  /** Block Eth1 deposit root hash */
  depositRoot: Scalars['String'];
};

export type Ethereum2Filter = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};

export enum Ethereum2Network {
  /** Beacon Chain Ethereum 2.0 */
  Eth2 = 'eth2',
  /** Medalla Ethereum 2.0 Beacon Testnet */
  Medalla = 'medalla'
}

/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashing = {
  __typename?: 'Ethereum2ProposerSlashing';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  /** Header slashing sequential numbern */
  headerOrder: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Proposer Slashing Index (0 based ) in block */
  proposerSlashingIndex: Scalars['Int'];
  slashing: Ethereum2SlashingInfo;
  /** Block state root hash */
  stateRoot: Scalars['String'];
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingAnyArgs = {
  of: Ethereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingBlockRootArgs = {
  blockRootHash?: Maybe<Array<HashSelector>>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  slashingEpoch?: Maybe<Array<IntegerSelector>>;
  slashingProposerIndex?: Maybe<Array<IntegerSelector>>;
  slashingSlot?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  slashingEpoch?: Maybe<Array<IntegerSelector>>;
  slashingProposerIndex?: Maybe<Array<IntegerSelector>>;
  slashingSlot?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2ProposerSlashingsUniq>;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingMaximumArgs = {
  get?: Maybe<Ethereum2ProposerSlashingMeasureable>;
  of: Ethereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingMinimumArgs = {
  get?: Maybe<Ethereum2ProposerSlashingMeasureable>;
  of: Ethereum2ProposerSlashingMeasureable;
};


/** Proposer Slashing in Ethereum v2.0 blockchain */
export type Ethereum2ProposerSlashingProposerArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
};

export enum Ethereum2ProposerSlashingMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Slashed Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time'
}

export enum Ethereum2ProposerSlashingsUniq {
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique slashing epochs */
  SlashingEpochs = 'slashing_epochs',
  /** Unique slashing proposers */
  SlashingProposers = 'slashing_proposers',
  /** Unique slashing slots */
  SlashingSlots = 'slashing_slots'
}

/** SlashingInfo for Ethereum v 2.0 network */
export type Ethereum2SlashingInfo = {
  __typename?: 'Ethereum2SlashingInfo';
  /** Block body hash */
  bodyRoot: Scalars['String'];
  epoch: Scalars['Int'];
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  signature: Scalars['String'];
  slot: Scalars['Int'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
};

/** Validator attributes for Ethereum v 2.0 network */
export type Ethereum2ValidatorInfo = {
  __typename?: 'Ethereum2ValidatorInfo';
  /** Validator Index as Integer */
  index: Scalars['Int'];
  /** Validator Pub Key */
  pubkey: Scalars['String'];
  /** Validator Withdrawal */
  withdrawalCredentials: Scalars['String'];
};

/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExit = {
  __typename?: 'Ethereum2VoluntaryExit';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Block root hash */
  blockRoot: Scalars['String'];
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block Eth1 information */
  eth1: Ethereum2Eth1Info;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Block parent hash */
  parentRoot: Scalars['String'];
  /** Block proposer */
  proposer?: Maybe<Ethereum2ValidatorInfo>;
  /** Signature */
  signature: Scalars['String'];
  /** Block state root hash */
  stateRoot: Scalars['String'];
  /** Validator */
  validator: Ethereum2ValidatorInfo;
  voluntaryExitEpoch: Scalars['Int'];
  /** Voluntary Exit Index (0 based ) in block */
  voluntaryExitIndex: Scalars['Int'];
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitAnyArgs = {
  of: Ethereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitBlockRootArgs = {
  blockRootHash?: Maybe<Array<HashSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitCountArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2VoluntaryExitsUniq>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
  voluntaryExitEpoch?: Maybe<Array<IntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitCountBigIntArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
  blockRootHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<Ethereum2VoluntaryExitsUniq>;
  validatorIndex?: Maybe<Array<IntegerSelector>>;
  voluntaryExitEpoch?: Maybe<Array<IntegerSelector>>;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitMaximumArgs = {
  get?: Maybe<Ethereum2VoluntaryExitsMeasureable>;
  of: Ethereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitMinimumArgs = {
  get?: Maybe<Ethereum2VoluntaryExitsMeasureable>;
  of: Ethereum2VoluntaryExitsMeasureable;
};


/** Voluntary Exit in Ethereum v2.0 blockchain */
export type Ethereum2VoluntaryExitProposerArgs = {
  blockProposerIndex?: Maybe<Array<IntegerSelector>>;
};

export enum Ethereum2VoluntaryExitsMeasureable {
  /** Block */
  Block = 'block',
  /** Block Proposer */
  BlockProposer = 'block_proposer',
  /** Block hash */
  BlockRootHash = 'block_root_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Validator index */
  Validator = 'validator'
}

export enum Ethereum2VoluntaryExitsUniq {
  /** Unique block proposers */
  BlockProposers = 'block_proposers',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique validators */
  Validators = 'validators'
}

/** Address detailed information for Ethereum network */
export type EthereumAddressInfo = {
  __typename?: 'EthereumAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EthereumSmartContractInfo>;
};

/** Blockchain address */
export type EthereumAddressInfoWithBalance = {
  __typename?: 'EthereumAddressInfoWithBalance';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** DEPRECATED Current address balance */
  balance?: Maybe<Scalars['Float']>;
  /** DEPRECATED Balances by currencies for the address */
  balances?: Maybe<Array<EthereumBalance>>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<EthereumSmartContractInfoWithAttributes>;
};


/** Blockchain address */
export type EthereumAddressInfoWithBalanceBalancesArgs = {
  currency?: Maybe<EthereumCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelectorRange>;
  time?: Maybe<DateTimeSelector>;
};

/**
 * Address should start from 0x and contain hex digits.
 * If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type EthereumAddressSelector = {
  /** In the list of Addresses */
  in?: Maybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: Maybe<Scalars['String']>;
  /** Not Equal to Address */
  not?: Maybe<Scalars['String']>;
  /** Not in the list of Addresses */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/**
 * Address should start from 0x and contain hex digits.
 * If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type EthereumAddressSelectorIn = {
  /** In the list of Addresses */
  in?: Maybe<Array<Scalars['String']>>;
  /** Equal to Address */
  is?: Maybe<Scalars['String']>;
};

export type EthereumArgumentFilter = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};

/** Arguments of Smart Contract Calls and Events */
export type EthereumArguments = {
  __typename?: 'EthereumArguments';
  any?: Maybe<Scalars['String']>;
  /** Method or event argument */
  argument?: Maybe<ArgumentName>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<EthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Sequential index of value in array ( multi-dimensional) */
  index: Scalars['String'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Float']>;
  /** Address value of method or event argument */
  reference?: Maybe<EthereumAddressInfo>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract method or event */
  smartContractSignature?: Maybe<Signature>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<EthereumTransactionInfo>;
  /** The Value of method or event argument */
  value?: Maybe<ArgumentValue>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsAnyArgs = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  as?: Maybe<EthereumArgumentsConvertable>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  of: EthereumArgumentsMeasureable;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsArgumentArgs = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsCallerArgs = {
  caller?: Maybe<Array<EthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsCountArgs = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<SmartContractArgumentsUniq>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsCountBigIntArgs = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<SmartContractArgumentsUniq>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsMaximumArgs = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  as?: Maybe<EthereumArgumentsConvertable>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  get?: Maybe<EthereumArgumentsMeasureable>;
  height?: Maybe<BlockSelector>;
  of: EthereumArgumentsMeasureable;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsMinimumArgs = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  as?: Maybe<EthereumArgumentsConvertable>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  get?: Maybe<EthereumArgumentsMeasureable>;
  height?: Maybe<BlockSelector>;
  of: EthereumArgumentsMeasureable;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsNumberArgs = {
  argument?: Maybe<Array<ArgumentSelector>>;
  argumentType?: Maybe<Array<ArgumentTypeSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  reference?: Maybe<Array<EthereumAddressSelector>>;
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  value?: Maybe<Array<ArgumentValueSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsReferenceArgs = {
  reference?: Maybe<Array<EthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsSmartContractArgs = {
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsSmartContractSignatureArgs = {
  signatureType?: Maybe<SignatureTypeSelector>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsSuccessArgs = {
  success?: Maybe<Array<Scalars['Boolean']>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsTransactionArgs = {
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<Array<HashSelector>>;
};


/** Arguments of Smart Contract Calls and Events */
export type EthereumArgumentsValueArgs = {
  value?: Maybe<Array<ArgumentValueSelector>>;
};

export enum EthereumArgumentsConvertable {
  /** Token name */
  TokenName = 'token_name',
  /** Token symbol */
  TokenSymbol = 'token_symbol'
}

export enum EthereumArgumentsMeasureable {
  /** Argument */
  Argument = 'argument',
  /** Argument index */
  ArgumentIndex = 'argument_index',
  /** Argument type */
  ArgumentType = 'argument_type',
  /** Argument value */
  ArgumentValue = 'argument_value',
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract Method Signature */
  SignatureType = 'signature_type',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Balance in a currency */
export type EthereumBalance = {
  __typename?: 'EthereumBalance';
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** History of balance changes by currencies for the address */
  history?: Maybe<Array<EthereumBalanceChange>>;
  value?: Maybe<Scalars['Float']>;
};


/** Balance in a currency */
export type EthereumBalanceHistoryArgs = {
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  height?: Maybe<BlockSelectorRange>;
};

/** Change of balance in a currency */
export type EthereumBalanceChange = {
  __typename?: 'EthereumBalanceChange';
  /** Block number (height) in blockchain */
  block: Scalars['Int'];
  /** Block timestamp */
  timestamp?: Maybe<Scalars['ISO8601DateTime']>;
  /** Transfer amount ( positive inbound, negative outbound) */
  transferAmount?: Maybe<Scalars['Float']>;
  value?: Maybe<Scalars['Float']>;
};

export type EthereumBlockFilter = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};

/** Blocks in Ethereum blockchain */
export type EthereumBlocks = {
  __typename?: 'EthereumBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  difficulty?: Maybe<Scalars['Float']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  /** Block miner */
  miner?: Maybe<EthereumAddressInfo>;
  minimum?: Maybe<Scalars['String']>;
  /** Block nonce */
  nonce: Scalars['Int'];
  /** Parent block hash */
  parentHash: Scalars['String'];
  reward?: Maybe<Scalars['Float']>;
  /** Currency of reward */
  rewardCurrency?: Maybe<Currency>;
  size?: Maybe<Scalars['Int']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  totalDifficulty?: Maybe<Scalars['Float']>;
  transactionCount?: Maybe<Scalars['Int']>;
  transactionCountBigInt?: Maybe<Scalars['BigInt']>;
  uncleCount?: Maybe<Scalars['Int']>;
  uncleCountBigInt?: Maybe<Scalars['BigInt']>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksAnyArgs = {
  of: EthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksCountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
  uniq?: Maybe<EthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
  uniq?: Maybe<EthereumBlocksUniq>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksDifficultyArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksHashArgs = {
  blockHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksMaximumArgs = {
  get?: Maybe<EthereumBlocksMeasureable>;
  of: EthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksMinerArgs = {
  miner?: Maybe<Array<EthereumAddressSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksMinimumArgs = {
  get?: Maybe<EthereumBlocksMeasureable>;
  of: EthereumBlocksMeasureable;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksRewardArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksSizeArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksTotalDifficultyArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksTransactionCountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksTransactionCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksUncleCountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};


/** Blocks in Ethereum blockchain */
export type EthereumBlocksUncleCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockReward?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<EthereumAddressSelector>>;
  size?: Maybe<Array<IntegerSelector>>;
  time?: Maybe<DateTimeSelector>;
  transactionCount?: Maybe<Array<IntegerSelector>>;
  uncleCount?: Maybe<Array<IntegerSelector>>;
};

export enum EthereumBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Block Reward */
  BlockReward = 'block_reward',
  /** Date */
  Date = 'date',
  /** Block Miner */
  Miner = 'miner',
  /** Time */
  Time = 'time'
}

export enum EthereumBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique miner count */
  Miners = 'miners'
}

export enum EthereumCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Caller */
  Caller = 'caller',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Coinpath */
export type EthereumCoinpath = {
  __typename?: 'EthereumCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<EthereumAddressInfo>;
  /** Sender address */
  sender?: Maybe<EthereumAddressInfo>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type EthereumCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type EthereumCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EthereumCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type EthereumCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/**
 * Currency selector in Ethereum blockchain.
 * Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
 * You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
 * Ethereum Smart contract address should start from 0x and contain 40 hex digits.
 * If digits are case sensitive, address is checked against checksum according to EIP-55.
 */
export type EthereumCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Ethereum DEX attributes */
export type EthereumDex = {
  __typename?: 'EthereumDex';
  /** Address for DEX exchange identification */
  address: Address;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']>;
};

export type EthereumDexTradeFilter = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};

/** Trades on DEX smart contracts */
export type EthereumDexTrades = {
  __typename?: 'EthereumDexTrades';
  /** Trader (maker or taker) */
  address?: Maybe<EthereumAddressInfo>;
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  /** Base currency */
  baseCurrency?: Maybe<Currency>;
  /** Block in the blockchain */
  block?: Maybe<BlockExtended>;
  buyAmount?: Maybe<Scalars['Float']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<Currency>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<EthereumDex>;
  gas?: Maybe<Scalars['Float']>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Trade 'maker' side */
  maker?: Maybe<EthereumAddressInfo>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Float']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  /** Quote currency */
  quoteCurrency?: Maybe<Currency>;
  quotePrice?: Maybe<Scalars['Float']>;
  sellAmount?: Maybe<Scalars['Float']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<Currency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<TradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<EthereumAddressInfo>;
  /** Time interval */
  timeInterval?: Maybe<TimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<EthereumTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesAddressArgs = {
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesAnyArgs = {
  of: EthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesBaseAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesBaseCurrencyArgs = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesBuyAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesBuyCurrencyArgs = {
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesCountArgs = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
  uniq?: Maybe<EthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesCountBigIntArgs = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
  uniq?: Maybe<EthereumDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesExchangeArgs = {
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesGasArgs = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesGasPriceArgs = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesGasValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesMakerArgs = {
  maker?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesMaximumArgs = {
  get?: Maybe<EthereumDexTradesMeasureable>;
  of: EthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesMinimumArgs = {
  get?: Maybe<EthereumDexTradesMeasureable>;
  of: EthereumDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesPriceArgs = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  calculate?: Maybe<PriceAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesProtocolArgs = {
  protocol?: Maybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesQuoteAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesQuoteCurrencyArgs = {
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesQuotePriceArgs = {
  baseCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  calculate?: Maybe<PriceAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<EthereumAddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<EthereumAddressSelector>>;
  makerOrTaker?: Maybe<Array<EthereumAddressSelector>>;
  makerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  taker?: Maybe<Array<EthereumAddressSelector>>;
  takerSmartContractType?: Maybe<Array<SmartContractTypeSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesSellAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesSellCurrencyArgs = {
  sellCurrency?: Maybe<Array<EthereumCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesSmartContractArgs = {
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesTakerArgs = {
  taker?: Maybe<Array<EthereumAddressSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesTradeAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in: BaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesTradeIndexArgs = {
  tradeIndex?: Maybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type EthereumDexTradesTransactionArgs = {
  txHash?: Maybe<Array<HashSelector>>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
};

export enum EthereumDexTradesMeasureable {
  /** Block */
  Block = 'block',
  /** Buy Amount */
  BuyAmount = 'buy_amount',
  /** Buy Token address */
  BuyCurrencyAddress = 'buy_currency_address',
  /** Buy Currency symbol */
  BuyCurrencySymbol = 'buy_currency_symbol',
  /** Date */
  Date = 'date',
  /** Maker */
  Maker = 'maker',
  /** Price */
  Price = 'price',
  /** Quote Price */
  QuotePrice = 'quote_price',
  /** Sell Amount */
  SellAmount = 'sell_amount',
  /** Sell Token address */
  SellCurrencyAddress = 'sell_currency_address',
  /** Sell Currency symbol */
  SellCurrencySymbol = 'sell_currency_symbol',
  /** Taker */
  Taker = 'taker',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum EthereumDexTradesUniq {
  /** Unique makers & takers count */
  Address = 'address',
  /** Base currencies count */
  BaseCurrency = 'base_currency',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy currencies count */
  BuyCurrency = 'buy_currency',
  /** Unique date count */
  Dates = 'dates',
  /** Unique makers count */
  Makers = 'makers',
  /** Unique protocols count */
  Protocols = 'protocols',
  /** Quote currencies count */
  QuoteCurrency = 'quote_currency',
  /** Sell currencies count */
  SellCurrency = 'sell_currency',
  /** Unique TX senders count */
  Senders = 'senders',
  /** Unique smart contract count */
  SmartContracts = 'smart_contracts',
  /** Unique makers count */
  Takers = 'takers',
  /** Unique transactions count */
  Txs = 'txs'
}

export enum EthereumEventsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract Event Signature */
  Signature = 'signature',
  /** Smart Contract Event Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Event Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum EthereumNetwork {
  /** Binance Smart Chain Mainnet */
  Bsc = 'bsc',
  /** Binance Smart Chain Testnet */
  BscTestnet = 'bsc_testnet',
  /** Celo Alfajores Testnet */
  CeloAlfajores = 'celo_alfajores',
  /** Celo Baklava Testnet */
  CeloBaklava = 'celo_baklava',
  /** Celo RC1 */
  CeloRc1 = 'celo_rc1',
  /** Ethereum Classic */
  Ethclassic = 'ethclassic',
  /** Ethereum Classic ( no reorg from block 10904146) */
  EthclassicReorg = 'ethclassic_reorg',
  /** Ethereum Mainnet */
  Ethereum = 'ethereum',
  /** Goerli Ethereum Testnet */
  Goerli = 'goerli',
  /** Klaytn Mainnet */
  Klaytn = 'klaytn',
  /** Matic (Polygon) Mainnet */
  Matic = 'matic',
  /** Velas Mainnet */
  Velas = 'velas',
  /** Velas Testnet */
  VelasTestnet = 'velas_testnet'
}

/** Ethereum smart contract */
export type EthereumSmartContract = {
  __typename?: 'EthereumSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<Currency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EthereumSmartContractCallFilter = {
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: Maybe<MethodSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  success?: Maybe<Array<Scalars['Boolean']>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};

/** Smart Contract Calls */
export type EthereumSmartContractCalls = {
  __typename?: 'EthereumSmartContractCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Call arguments */
  arguments?: Maybe<Array<ArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Caller of the method invocation ( tx sender or another smart contract ) */
  caller?: Maybe<EthereumAddressInfo>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** External call executed explicitly by tx sender. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  /** Gas used for transaction in external call, or by methd in internal call */
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where call happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: Maybe<MethodSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  success?: Maybe<Array<Scalars['Boolean']>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsAnyArgs = {
  of: EthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsCallerArgs = {
  caller?: Maybe<Array<EthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsCountArgs = {
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: Maybe<MethodSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  success?: Maybe<Array<Scalars['Boolean']>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsCountBigIntArgs = {
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: Maybe<MethodSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  success?: Maybe<Array<Scalars['Boolean']>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsGasValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  caller?: Maybe<Array<EthereumAddressSelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractMethod?: Maybe<MethodSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  success?: Maybe<Array<Scalars['Boolean']>>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsMaximumArgs = {
  get?: Maybe<EthereumCallsMeasureable>;
  of: EthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsMinimumArgs = {
  get?: Maybe<EthereumCallsMeasureable>;
  of: EthereumCallsMeasureable;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsSmartContractArgs = {
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: Maybe<MethodSelector>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsSuccessArgs = {
  success?: Maybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type EthereumSmartContractCallsTransactionArgs = {
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<Array<HashSelector>>;
};

/** Smart Contract Events */
export type EthereumSmartContractEvent = {
  __typename?: 'EthereumSmartContractEvent';
  any?: Maybe<Scalars['String']>;
  /** Event arguments */
  arguments?: Maybe<Array<ArgumentNameValue>>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Event index */
  eventIndex?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being called */
  smartContract?: Maybe<EthereumSmartContract>;
  /** Contract event logged */
  smartContractEvent?: Maybe<Event>;
  /** Transaction where event happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Smart Contract Events */
export type EthereumSmartContractEventAnyArgs = {
  of: EthereumEventsMeasureable;
};


/** Smart Contract Events */
export type EthereumSmartContractEventBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Events */
export type EthereumSmartContractEventCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type EthereumSmartContractEventCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type EthereumSmartContractEventMaximumArgs = {
  get?: Maybe<EthereumEventsMeasureable>;
  of: EthereumEventsMeasureable;
};


/** Smart Contract Events */
export type EthereumSmartContractEventMinimumArgs = {
  get?: Maybe<EthereumEventsMeasureable>;
  of: EthereumEventsMeasureable;
};


/** Smart Contract Events */
export type EthereumSmartContractEventSmartContractArgs = {
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
};


/** Smart Contract Events */
export type EthereumSmartContractEventSmartContractEventArgs = {
  smartContractEvent?: Maybe<EventSelector>;
};


/** Smart Contract Events */
export type EthereumSmartContractEventTransactionArgs = {
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<Array<HashSelector>>;
};

export type EthereumSmartContractEventFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<Array<EthereumAddressSelector>>;
  smartContractEvent?: Maybe<EventSelector>;
  smartContractType?: Maybe<SmartContractTypeSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};

/** Blockchain smart contract */
export type EthereumSmartContractInfo = {
  __typename?: 'EthereumSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<Currency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

/** Blockchain smart contract */
export type EthereumSmartContractInfoWithAttributes = {
  __typename?: 'EthereumSmartContractInfoWithAttributes';
  /** Attributes from readonly methods */
  attributes?: Maybe<Array<SmartContractReadonlyAttribute>>;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<Currency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type EthereumTransactionFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};

/** Blockchain transaction info */
export type EthereumTransactionInfo = {
  __typename?: 'EthereumTransactionInfo';
  /** Gas consumed */
  gas: Scalars['Int'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  /** Gas value cost */
  gasValue: Scalars['Float'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction from address */
  txFrom: EthereumAddressInfo;
};

/** Blockchain Transaction Extended info */
export type EthereumTransactionInfoExtended = {
  __typename?: 'EthereumTransactionInfoExtended';
  /** Gas consumed */
  gas: Scalars['Int'];
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  /** Gas value cost */
  gasValue: Scalars['Float'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Transaction receiver */
  to?: Maybe<EthereumAddressInfo>;
  /** Transaction from address */
  txFrom: EthereumAddressInfo;
};

/** Transactions in Ethereum blockchain */
export type EthereumTransactions = {
  __typename?: 'EthereumTransactions';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Created smart contract */
  creates?: Maybe<EthereumAddressInfo>;
  /** Currency of amount */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Error message if any */
  error?: Maybe<Scalars['String']>;
  gas?: Maybe<Scalars['Float']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas price in Gwei */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Transaction sender */
  sender?: Maybe<EthereumAddressInfo>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction receiver */
  to?: Maybe<EthereumAddressInfo>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsAnyArgs = {
  of: EthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
  uniq?: Maybe<EthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
  uniq?: Maybe<EthereumTransactionsUniq>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsCreatesArgs = {
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsGasArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsGasCurrencyArgs = {
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsGasPriceArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsGasValueArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<EthereumCurrencySelector>>;
  gasValue?: Maybe<Array<AmountSelector>>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txCreates?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  txSender?: Maybe<Array<EthereumAddressSelector>>;
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsHashArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsIndexArgs = {
  txIndex?: Maybe<Array<TxIndexSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsMaximumArgs = {
  get?: Maybe<EthereumTransactionsMeasureable>;
  of: EthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsMinimumArgs = {
  get?: Maybe<EthereumTransactionsMeasureable>;
  of: EthereumTransactionsMeasureable;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsSenderArgs = {
  txSender?: Maybe<Array<EthereumAddressSelector>>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Ethereum blockchain */
export type EthereumTransactionsToArgs = {
  txTo?: Maybe<Array<EthereumAddressSelector>>;
};

export enum EthereumTransactionsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Gas value */
  GasValue = 'gas_value',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction Sender */
  TxSender = 'tx_sender'
}

export enum EthereumTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique TX receivers count */
  Receivers = 'receivers',
  /** Unique TX senders count */
  Senders = 'senders'
}

export type EthereumTransferFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<Array<EthereumAddressSelector>>;
  sender?: Maybe<Array<EthereumAddressSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfers = {
  __typename?: 'EthereumTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<EthereumAddressInfo>;
  /** Transfer sender */
  sender?: Maybe<EthereumAddressInfo>;
  /** Success flag */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction where transfer happened */
  transaction?: Maybe<EthereumTransactionInfo>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<Array<EthereumAddressSelector>>;
  sender?: Maybe<Array<EthereumAddressSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersAnyArgs = {
  of: EthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<Array<EthereumAddressSelector>>;
  sender?: Maybe<Array<EthereumAddressSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<Array<EthereumAddressSelector>>;
  sender?: Maybe<Array<EthereumAddressSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersCurrencyArgs = {
  currency?: Maybe<Array<EthereumCurrencySelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersEntityIdArgs = {
  entityId?: Maybe<EntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersGasValueArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<EthereumCurrencySelector>>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<Array<EthereumAddressSelector>>;
  sender?: Maybe<Array<EthereumAddressSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersMaximumArgs = {
  get?: Maybe<EthereumTransfersMeasureable>;
  of: EthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersMinimumArgs = {
  get?: Maybe<EthereumTransfersMeasureable>;
  of: EthereumTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersReceiverArgs = {
  receiver?: Maybe<Array<EthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersSenderArgs = {
  sender?: Maybe<Array<EthereumAddressSelector>>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type EthereumTransfersTransactionArgs = {
  txFrom?: Maybe<Array<EthereumAddressSelector>>;
  txHash?: Maybe<Array<HashSelector>>;
};

export enum EthereumTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Entity ID */
  EntityId = 'entity_id',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Smart contract event */
export type Event = {
  __typename?: 'Event';
  /** Name */
  name?: Maybe<Scalars['String']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature Hash */
  signatureHash: Scalars['String'];
};

/** Smart contract event. In selector you can use the name, signature or hex hash */
export type EventSelector = {
  /** Event signature in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Event signature is */
  is?: Maybe<Scalars['String']>;
  /** Event signature not */
  not?: Maybe<Scalars['String']>;
  /** Event signature not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Solana External Action */
export type ExternalAction = {
  __typename?: 'ExternalAction';
  name: Scalars['String'];
};

/** Filecoin */
export type Filecoin = {
  __typename?: 'Filecoin';
  /** Filecoin Network Blocks */
  blocks?: Maybe<Array<FilecoinBlock>>;
  /** Filecoin Network Calls */
  calls?: Maybe<Array<FilecoinCalls>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<FilecoinCoinpath>>;
  /** Filecoin Network Messages ( blocks, transfers, ... ) */
  messages?: Maybe<Array<FilecoinMessages>>;
  /** Filecoin Network Currency Transfers */
  transfers?: Maybe<Array<FilecoinTransfers>>;
};


/** Filecoin */
export type FilecoinBlocksArgs = {
  any?: Maybe<Array<FilecoinBlockFilter>>;
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
};


/** Filecoin */
export type FilecoinCallsArgs = {
  amount?: Maybe<AmountSelector>;
  any?: Maybe<Array<FilecoinCallFilter>>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Filecoin */
export type FilecoinCoinpathArgs = {
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Filecoin */
export type FilecoinMessagesArgs = {
  amount?: Maybe<AmountSelector>;
  any?: Maybe<Array<FilecoinMessageFilter>>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Filecoin */
export type FilecoinTransfersArgs = {
  amount?: Maybe<AmountSelector>;
  any?: Maybe<Array<FilecoinTransferFilter>>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<TransferTypeSelector>;
};

/** Block */
export type FilecoinBlock = {
  __typename?: 'FilecoinBlock';
  any?: Maybe<Scalars['String']>;
  blockSig?: Maybe<NameWithId>;
  blsAggregate?: Maybe<NameWithId>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  electionProof?: Maybe<Scalars['String']>;
  forkSignalling?: Maybe<Scalars['BigInt']>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block round in blockchain */
  height: Scalars['Int'];
  /** Block index on height */
  index?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  messageCount?: Maybe<Scalars['Int']>;
  messageCountBigInt?: Maybe<Scalars['BigInt']>;
  messages?: Maybe<Scalars['String']>;
  /** Miner */
  miner?: Maybe<Address>;
  minerTips?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['String']>;
  parentMessageReceipts?: Maybe<Scalars['String']>;
  parentStateRoot?: Maybe<Scalars['String']>;
  parentWeight?: Maybe<Scalars['BigInt']>;
  reward?: Maybe<Scalars['Float']>;
  ticket?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  totalReward?: Maybe<Scalars['Float']>;
  winCount?: Maybe<Scalars['Int']>;
  winCountBigInt?: Maybe<Scalars['BigInt']>;
  wincount?: Maybe<Scalars['Int']>;
};


/** Block */
export type FilecoinBlockAnyArgs = {
  of: FilecoinBlocksMeasureable;
};


/** Block */
export type FilecoinBlockCountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<FilecoinBlockUniq>;
};


/** Block */
export type FilecoinBlockCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<FilecoinBlockUniq>;
};


/** Block */
export type FilecoinBlockHashArgs = {
  blockHash?: Maybe<Array<HashSelector>>;
};


/** Block */
export type FilecoinBlockHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Block */
export type FilecoinBlockIndexArgs = {
  blockIndex?: Maybe<IntegerSelector>;
};


/** Block */
export type FilecoinBlockMaximumArgs = {
  get?: Maybe<FilecoinBlocksMeasureable>;
  of: FilecoinBlocksMeasureable;
};


/** Block */
export type FilecoinBlockMessageCountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlockMessageCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlockMinerArgs = {
  miner?: Maybe<AddressSelector>;
};


/** Block */
export type FilecoinBlockMinerTipsArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlockMinimumArgs = {
  get?: Maybe<FilecoinBlocksMeasureable>;
  of: FilecoinBlocksMeasureable;
};


/** Block */
export type FilecoinBlockRewardArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlockTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlockTotalRewardArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlockWinCountArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type FilecoinBlockWinCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};

export type FilecoinBlockFilter = {
  blockHash?: Maybe<HashSelector>;
  blockIndex?: Maybe<IntegerSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  miner?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
};

export enum FilecoinBlockUniq {
  /** Unique block count */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique block height count */
  Heights = 'heights',
  /** Miner */
  Miners = 'miners'
}

export enum FilecoinBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Block Miner */
  Miner = 'miner',
  /** Time */
  Time = 'time'
}

export type FilecoinCallFilter = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};

/** Calls in Filecoin blockchain */
export type FilecoinCalls = {
  __typename?: 'FilecoinCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer Message is included */
  block?: Maybe<Block>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  exitCode?: Maybe<Scalars['BigInt']>;
  gas?: Maybe<Scalars['Int']>;
  gasFeeCap?: Maybe<Scalars['BigInt']>;
  gasLimit?: Maybe<Scalars['BigInt']>;
  gasPremium?: Maybe<Scalars['Float']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message Method */
  messageMethod?: Maybe<NameWithId>;
  /** Method */
  method?: Maybe<NameWithId>;
  minedBlock?: Maybe<FilecoinMinedBlock>;
  minimum?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['BigInt']>;
  /** Message receiver */
  receiver?: Maybe<AddressWithAccount>;
  returnValue?: Maybe<Scalars['String']>;
  /** Message sender */
  sender?: Maybe<AddressWithAccount>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsAmountArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsAnyArgs = {
  of: FilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsCountArgs = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<FilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsCountBigIntArgs = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<FilecoinMessagesUniq>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsGasArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsHashArgs = {
  hash?: Maybe<HashSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsMaximumArgs = {
  get?: Maybe<FilecoinCallsMeasureable>;
  of: FilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsMessageMethodArgs = {
  messageMethod?: Maybe<IntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsMethodArgs = {
  method?: Maybe<IntegerSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsMinimumArgs = {
  get?: Maybe<FilecoinCallsMeasureable>;
  of: FilecoinCallsMeasureable;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsReceiverArgs = {
  receiver?: Maybe<AddressSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsSenderArgs = {
  sender?: Maybe<AddressSelector>;
};


/** Calls in Filecoin blockchain */
export type FilecoinCallsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};

export enum FilecoinCallsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas limit */
  GasLimit = 'gas_limit',
  /** Gas value */
  GasValue = 'gas_value',
  /** Message hash */
  MessageHash = 'message_hash',
  /** Time */
  Time = 'time'
}

/** Coinpath */
export type FilecoinCoinpath = {
  __typename?: 'FilecoinCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message of transfer happened */
  message?: Maybe<TransactionHashValue>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
};


/** Coinpath */
export type FilecoinCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type FilecoinCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type FilecoinCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type FilecoinCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

export type FilecoinMessageFilter = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};

/** Messages in Filecoin blockchain */
export type FilecoinMessages = {
  __typename?: 'FilecoinMessages';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  baseFeeBurn?: Maybe<Scalars['Float']>;
  /** Block where transfer Message is included */
  block?: Maybe<Block>;
  burned?: Maybe<Scalars['Float']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  exitCode?: Maybe<Scalars['BigInt']>;
  gas?: Maybe<Scalars['Int']>;
  gasFeeCap?: Maybe<Scalars['BigInt']>;
  gasLimit?: Maybe<Scalars['BigInt']>;
  gasPremium?: Maybe<Scalars['Float']>;
  /** Message hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Method */
  method?: Maybe<NameWithId>;
  minedBlock?: Maybe<FilecoinMinedBlock>;
  minerPenalty?: Maybe<Scalars['Float']>;
  minerTip?: Maybe<Scalars['Float']>;
  minimum?: Maybe<Scalars['String']>;
  nonce?: Maybe<Scalars['BigInt']>;
  overEstimationBurn?: Maybe<Scalars['Float']>;
  /** Message receiver */
  receiver?: Maybe<AddressWithAccount>;
  refund?: Maybe<Scalars['Float']>;
  returnValue?: Maybe<Scalars['String']>;
  /** Message sender */
  sender?: Maybe<AddressWithAccount>;
  signature?: Maybe<Scalars['String']>;
  signatureType?: Maybe<Scalars['String']>;
  /** Signed Message hash */
  signedHash?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  totalCost?: Maybe<Scalars['Float']>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesAmountArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesAnyArgs = {
  of: FilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesBaseFeeBurnArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesBurnedArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesCountArgs = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<FilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesCountBigIntArgs = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<FilecoinMessagesUniq>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesGasArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesHashArgs = {
  hash?: Maybe<HashSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesMaximumArgs = {
  get?: Maybe<FilecoinMessagesMeasureable>;
  of: FilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesMethodArgs = {
  method?: Maybe<IntegerSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesMinerPenaltyArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesMinerTipArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesMinimumArgs = {
  get?: Maybe<FilecoinMessagesMeasureable>;
  of: FilecoinMessagesMeasureable;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesOverEstimationBurnArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesReceiverArgs = {
  receiver?: Maybe<AddressSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesRefundArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesSenderArgs = {
  sender?: Maybe<AddressSelector>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Messages in Filecoin blockchain */
export type FilecoinMessagesTotalCostArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  index?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
};

export enum FilecoinMessagesMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas limit */
  GasLimit = 'gas_limit',
  /** Gas value */
  GasValue = 'gas_value',
  /** Message hash */
  MessageHash = 'message_hash',
  /** Time */
  Time = 'time'
}

export enum FilecoinMessagesUniq {
  /** Unique block heights */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique Message receivers */
  Receivers = 'receivers',
  /** Unique Message senders */
  Senders = 'senders'
}

/** Filecoin Mined Block */
export type FilecoinMinedBlock = {
  __typename?: 'FilecoinMinedBlock';
  /** Hash */
  hash?: Maybe<Scalars['String']>;
  /** Index on height */
  index?: Maybe<Scalars['Int']>;
  /** Miner */
  miner?: Maybe<Address>;
};

export enum FilecoinNetwork {
  /** Filecoin Mainnet */
  Filecoin = 'filecoin'
}

export type FilecoinTransferFilter = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<TransferTypeSelector>;
};

export enum FilecoinTransferType {
  /** Burn */
  Burn = 'burn',
  /** Genesis */
  Genesis = 'genesis',
  /** Miner Tip */
  Miner = 'miner',
  /** Rebalance */
  Rebalance = 'rebalance',
  /** Reward */
  Reward = 'reward',
  /** Send (transfer) */
  Send = 'send'
}

/** Transfers in Filecoin blockchain */
export type FilecoinTransfers = {
  __typename?: 'FilecoinTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer Transfer is included */
  block?: Maybe<BlockExtended>;
  /** Call hash */
  callHash?: Maybe<Scalars['String']>;
  /** Call hash */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Message hash */
  hash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Message Method */
  messageMethod?: Maybe<NameWithId>;
  /** Method */
  method?: Maybe<NameWithId>;
  minimum?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transfer timestamp */
  timestamp?: Maybe<DateTime>;
  /** Type of transfer */
  transferType?: Maybe<FilecoinTransferType>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersAmountArgs = {
  amount?: Maybe<AmountSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<TransferTypeSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersAnyArgs = {
  of: FilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersCountArgs = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<TransferTypeSelector>;
  uniq?: Maybe<FilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersCountBigIntArgs = {
  amount?: Maybe<AmountSelector>;
  date?: Maybe<DateSelector>;
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  messageMethod?: Maybe<IntegerSelector>;
  method?: Maybe<IntegerSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  transferType?: Maybe<TransferTypeSelector>;
  uniq?: Maybe<FilecoinMessagesUniq>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersHashArgs = {
  hash?: Maybe<HashSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersMaximumArgs = {
  get?: Maybe<FilecoinTransfersMeasureable>;
  of: FilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersMessageMethodArgs = {
  messageMethod?: Maybe<IntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersMethodArgs = {
  method?: Maybe<IntegerSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersMinimumArgs = {
  get?: Maybe<FilecoinTransfersMeasureable>;
  of: FilecoinTransfersMeasureable;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersReceiverArgs = {
  receiver?: Maybe<AddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersSenderArgs = {
  sender?: Maybe<AddressSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Transfers in Filecoin blockchain */
export type FilecoinTransfersTransferTypeArgs = {
  transferType?: Maybe<TransferTypeSelector>;
};

export enum FilecoinTransfersMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas limit */
  GasLimit = 'gas_limit',
  /** Gas value */
  GasValue = 'gas_value',
  /** Time */
  Time = 'time',
  /** Transfer hash */
  TxHash = 'tx_hash',
  /** Value */
  Value = 'value'
}

/** Select by number */
export type FloatSelector = {
  /** in range */
  between?: Maybe<Array<Scalars['Float']>>;
  /** greater than */
  gt?: Maybe<Scalars['Float']>;
  /** greater or equal than */
  gteq?: Maybe<Scalars['Float']>;
  /** in the list */
  in?: Maybe<Array<Scalars['Float']>>;
  /** is */
  is?: Maybe<Scalars['Float']>;
  /** less than */
  lt?: Maybe<Scalars['Float']>;
  /** less or equal than */
  lteq?: Maybe<Scalars['Float']>;
  /** not */
  not?: Maybe<Scalars['Float']>;
  /** not in the list */
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export enum FlowDirection {
  /** Inbound transfers */
  Inbound = 'inbound',
  /** Outbound transfers */
  Outbound = 'outbound'
}

/** Harmony Chain */
export type Harmony = {
  __typename?: 'Harmony';
  /** Arguments of Smart Contract Calls and Events */
  arguments?: Maybe<Array<HarmonyArguments>>;
  /** Harmony Blocks */
  blocks?: Maybe<Array<HarmonyBlocks>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<HarmonySmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<HarmonySmartContractEvents>>;
  /** Harmony Staking Transactions */
  stakingTransactions?: Maybe<Array<HarmonyStakingTransactions>>;
  /** Harmony Transactions */
  transactions?: Maybe<Array<HarmonyTransactions>>;
  /** Harmony Transfers */
  transfers?: Maybe<Array<HarmonyTransfers>>;
};


/** Harmony Chain */
export type HarmonyArgumentsArgs = {
  any?: Maybe<Array<HarmonyArgumentsFilter>>;
  argument?: Maybe<StringSelector>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  smartContractAddress?: Maybe<HashSelector>;
  smartContractId?: Maybe<IntegerSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Harmony Chain */
export type HarmonyBlocksArgs = {
  any?: Maybe<Array<HarmonyBlocksFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  miner?: Maybe<HashSelector>;
  options?: Maybe<QueryOptions>;
  perentHash?: Maybe<HashSelector>;
  stakingTransactionsCount?: Maybe<HashSelector>;
  transactionCount?: Maybe<HashSelector>;
  unclesCount?: Maybe<HashSelector>;
  viewId?: Maybe<HashSelector>;
};


/** Harmony Chain */
export type HarmonySmartContractCallsArgs = {
  any?: Maybe<Array<HarmonySmartContractCallsFilter>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Harmony Chain */
export type HarmonySmartContractEventsArgs = {
  any?: Maybe<Array<HarmonySmartContractEventsFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractEvent?: Maybe<EventSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Harmony Chain */
export type HarmonyStakingTransactionsArgs = {
  any?: Maybe<Array<HarmonyStakingTransactionsFilter>>;
  date?: Maybe<DateSelector>;
  delegatorAddress?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  status?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<StakingTransactionsTypeSelector>;
  validatorAddress?: Maybe<HashSelector>;
};


/** Harmony Chain */
export type HarmonyTransactionsArgs = {
  any?: Maybe<Array<HarmonyTransactionsFilter>>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  reciever?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  status?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Harmony Chain */
export type HarmonyTransfersArgs = {
  any?: Maybe<Array<HarmonyTransfersFilter>>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  sender?: Maybe<HashSelector>;
  status?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};

/** Arguments of Smart Contract Calls and Events */
export type HarmonyArguments = {
  __typename?: 'HarmonyArguments';
  /** Value */
  address?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  /** Argument Index */
  argIndex?: Maybe<Scalars['String']>;
  /** Argument Type */
  argType?: Maybe<Scalars['String']>;
  /** Argument */
  argument?: Maybe<Scalars['String']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Value */
  number?: Maybe<Scalars['String']>;
  /** Address of the receiver */
  receiver?: Maybe<Scalars['String']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Signature ID */
  signatureId?: Maybe<Scalars['BigInt']>;
  /** Address of the smart contract */
  smartContractAddress?: Maybe<Scalars['String']>;
  /** Id of the smart contract */
  smartContractId?: Maybe<Scalars['BigInt']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Value */
  value?: Maybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsAnyArgs = {
  of: HarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsArgumentArgs = {
  argument?: Maybe<Scalars['String']>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsCountArgs = {
  uniq?: Maybe<HarmonyArgumentsUniq>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsMaximumArgs = {
  get?: Maybe<HarmonyArgumentsMeasureable>;
  of: HarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsMinimumArgs = {
  get?: Maybe<HarmonyArgumentsMeasureable>;
  of: HarmonyArgumentsMeasureable;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsReceiverArgs = {
  receiver?: Maybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsSmartContractAddressArgs = {
  smartContractAddress?: Maybe<HashSelector>;
};


/** Arguments of Smart Contract Calls and Events */
export type HarmonyArgumentsSmartContractIdArgs = {
  smartContractAddress?: Maybe<IntegerSelector>;
};

export type HarmonyArgumentsFilter = {
  argument?: Maybe<StringSelector>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  receiver?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  smartContractAddress?: Maybe<HashSelector>;
  smartContractId?: Maybe<IntegerSelector>;
  time?: Maybe<DateTimeSelector>;
};

export enum HarmonyArgumentsMeasureable {
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Address of  the receive */
  Receiver = 'receiver',
  /** Address of the sender */
  Sender = 'sender',
  /** Signature */
  Signature = 'signature',
  /** Hash of the signature */
  SignatureHash = 'signature_hash',
  /** Name of the signature */
  SignatureName = 'signature_name',
  /** Address of the smart contract */
  SmartContractAddress = 'smart_contract_address',
  /** Id of the smart contract */
  SmartContractId = 'smart_contract_id',
  /** Time */
  Time = 'time'
}

export enum HarmonyArgumentsUniq {
  /** Unique block hash count */
  BlockHash = 'block_hash',
  /** Unique date count */
  Dates = 'dates',
  /** Unique ledger count */
  Ledger = 'ledger',
  /** Unique address of the receiver */
  Receiver = 'receiver',
  /** Unique address of the sender */
  Sender = 'sender',
  /** Unique smart contract address */
  SmartContractAddress = 'smart_contract_address',
  /** Unique time */
  Times = 'times'
}

/** Blocks in Harmony blockchain */
export type HarmonyBlocks = {
  __typename?: 'HarmonyBlocks';
  any?: Maybe<Scalars['String']>;
  /** Transaction hash */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Difficulty */
  difficulty?: Maybe<Scalars['String']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  /** The “extra data” field of this block */
  extraData?: Maybe<Scalars['String']>;
  /** Gas limit */
  gasLimit?: Maybe<Scalars['BigInt']>;
  /** Gas used */
  gasUsed?: Maybe<Scalars['String']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  /** The bloom filter for the logs of the block. null when its pending block */
  logsBloom?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Transaction hash */
  miner?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Mix Hash */
  mixHash?: Maybe<Scalars['String']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Parent hash */
  parentHash?: Maybe<Scalars['String']>;
  /** Receipts Root */
  receiptsRoot?: Maybe<Scalars['String']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Integer the size of this block in bytes */
  size?: Maybe<Scalars['BigInt']>;
  /** Staking Transaction Count */
  stakingTransactionsCount?: Maybe<Scalars['BigInt']>;
  /** The root of the final state trie of the block */
  stateRoot?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction Count */
  transactionCount?: Maybe<Scalars['BigInt']>;
  /** The root of the transaction trie of the block */
  transactionsRoot?: Maybe<Scalars['String']>;
  /** Count of ucles hashes */
  unclesCount?: Maybe<Scalars['BigInt']>;
  /** View ID */
  viewId?: Maybe<Scalars['String']>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksAnyArgs = {
  of: HarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksCountArgs = {
  uniq?: Maybe<HarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksCountBigIntArgs = {
  uniq?: Maybe<HarmonyBlocksUniq>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksMaximumArgs = {
  get?: Maybe<HarmonyBlocksMeasureable>;
  of: HarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksMinerArgs = {
  miner?: Maybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksMinimumArgs = {
  get?: Maybe<HarmonyBlocksMeasureable>;
  of: HarmonyBlocksMeasureable;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksParentHashArgs = {
  parentHash?: Maybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksSizeArgs = {
  size?: Maybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksStakingTransactionsCountArgs = {
  stakingTransactionsCount?: Maybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksTransactionCountArgs = {
  transactionCount?: Maybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksUnclesCountArgs = {
  unclesCount?: Maybe<HashSelector>;
};


/** Blocks in Harmony blockchain */
export type HarmonyBlocksViewIdArgs = {
  viewId?: Maybe<HashSelector>;
};

export type HarmonyBlocksFilter = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  miner?: Maybe<HashSelector>;
  perentHash?: Maybe<HashSelector>;
  stakingTransactionsCount?: Maybe<HashSelector>;
  transactionCount?: Maybe<HashSelector>;
  unclesCount?: Maybe<HashSelector>;
  viewId?: Maybe<HashSelector>;
};

export enum HarmonyBlocksMeasureable {
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Gas limit */
  GasLimit = 'gas_limit',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Parent hash */
  ParetHash = 'paret_hash',
  /** Time */
  Time = 'time'
}

export enum HarmonyBlocksUniq {
  /** Unique block hash count */
  BlockHash = 'block_hash',
  /** Unique date count */
  Dates = 'dates',
  /** Unique ledger count */
  Ledger = 'ledger',
  /** Unique miner count */
  Miner = 'miner',
  /** Unique mix hash count */
  MixHash = 'mix_hash',
  /** Unique parent hash count */
  ParentHash = 'parent_hash',
  /** Unique receipts root count */
  ReceiptsRoot = 'receipts_root',
  /** Unique state root count */
  StateRoot = 'state_root',
  /** Unique time */
  Times = 'times',
  /** Unique transactions root count */
  TransactionsRoot = 'transactions_root'
}

export enum HarmonyEventsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Action To */
  TxTo = 'tx_to'
}

export enum HarmonyNetwork {
  /** Harmony Mainnat */
  Harmony = 'harmony',
  /** Harmony Testnet */
  HarmonyTestnet = 'harmony_testnet'
}

/** Smart Contract Calls */
export type HarmonySmartContractCalls = {
  __typename?: 'HarmonySmartContractCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callPath?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  gas?: Maybe<Scalars['Int']>;
  /** Gas unit price */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Nonce */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Transaction Sender */
  txSender?: Maybe<Address>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsAnyArgs = {
  of: HarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsCountArgs = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<HarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<HarmonySmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsGasArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsGasPriceArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsGasValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsMaximumArgs = {
  get?: Maybe<HarmonySmartContractCallsMeasureable>;
  of: HarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsMinimumArgs = {
  get?: Maybe<HarmonySmartContractCallsMeasureable>;
  of: HarmonySmartContractCallsMeasureable;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsNonceArgs = {
  nonce?: Maybe<IntegerSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: Maybe<MethodSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsSuccessArgs = {
  success?: Maybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsTxFromArgs = {
  txFrom?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsTxSenderArgs = {
  txSender?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type HarmonySmartContractCallsTxToArgs = {
  txTo?: Maybe<AddressSelector>;
};

export type HarmonySmartContractCallsFilter = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

export enum HarmonySmartContractCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Action To */
  TxTo = 'tx_to'
}

export enum HarmonySmartContractCallsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique smart contract methods count */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** Unique transaction senders */
  TxFrom = 'tx_from',
  /** Unique callers count */
  TxTo = 'tx_to',
  /** Unique transactions count */
  Txs = 'txs'
}

/** Smart Contract Events */
export type HarmonySmartContractEvents = {
  __typename?: 'HarmonySmartContractEvents';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Transaction hash where transfer happened */
  epoch?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one. */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<Event>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsAnyArgs = {
  of: HarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsCountArgs = {
  uniq?: Maybe<SmartContractEventsUniq>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsCountBigIntArgs = {
  uniq?: Maybe<SmartContractEventsUniq>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsEpochArgs = {
  epoch?: Maybe<IntegerSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsMaximumArgs = {
  get?: Maybe<HarmonyEventsMeasureable>;
  of: HarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsMinimumArgs = {
  get?: Maybe<HarmonyEventsMeasureable>;
  of: HarmonyEventsMeasureable;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsNonceArgs = {
  nonce?: Maybe<IntegerSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsSmartContractEventArgs = {
  smartContractEvent?: Maybe<EventSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsTxFromArgs = {
  txFrom?: Maybe<AddressSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Smart Contract Events */
export type HarmonySmartContractEventsTxToArgs = {
  txTo?: Maybe<AddressSelector>;
};

export type HarmonySmartContractEventsFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractEvent?: Maybe<EventSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactions = {
  __typename?: 'HarmonyStakingTransactions';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Delegator Address */
  delegatorAddress?: Maybe<Scalars['String']>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BigInt']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BigInt']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transaction type */
  transactionType?: Maybe<Scalars['String']>;
  /** Validator Address */
  validatorAddress?: Maybe<Scalars['String']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsAnyArgs = {
  of: HarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsCountArgs = {
  uniq?: Maybe<HarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsCountBigIntArgs = {
  uniq?: Maybe<HarmonyStakingTransactionsUniq>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsDelegatorAddressArgs = {
  delegatorAddress?: Maybe<HashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsMaximumArgs = {
  get?: Maybe<HarmonyStakingTransactionsMeasureable>;
  of: HarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsMinimumArgs = {
  get?: Maybe<HarmonyStakingTransactionsMeasureable>;
  of: HarmonyStakingTransactionsMeasureable;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsStatusArgs = {
  status?: Maybe<Scalars['Boolean']>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsTransactionTypeArgs = {
  transactionType?: Maybe<StakingTransactionsTypeSelector>;
};


/** StakingTransactions in Harmony blockchain */
export type HarmonyStakingTransactionsValidatorAddressArgs = {
  validatorAddress?: Maybe<HashSelector>;
};

export type HarmonyStakingTransactionsFilter = {
  date?: Maybe<DateSelector>;
  delegatorAddress?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  status?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<StakingTransactionsTypeSelector>;
  validatorAddress?: Maybe<HashSelector>;
};

export enum HarmonyStakingTransactionsMeasureable {
  /** Date */
  Date = 'date',
  /** Deligator Address */
  DeligatorAddress = 'deligator_address',
  /** Gas provided by the sender */
  Gas = 'gas',
  /** Gas price provided by the sender */
  GasPrice = 'gasPrice',
  /** Gas price provided by the sender */
  GasPrice = 'gas_price',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Validator Address */
  ValidatorAddress = 'validator_address',
  /** Value transferred in ATTO */
  Value = 'value'
}

export enum HarmonyStakingTransactionsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique delegator validator */
  DelegatorAddress = 'delegator_address',
  /** Unique block */
  Ledger = 'ledger',
  /** Unique time */
  Times = 'times',
  /** Unique address validator */
  ValidatorAddress = 'validator_address'
}

/** Transactions in Harmony blockchain */
export type HarmonyTransactions = {
  __typename?: 'HarmonyTransactions';
  any?: Maybe<Scalars['String']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Transaction creates */
  creates?: Maybe<Scalars['String']>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BigInt']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']>;
  /** Gas value provided by the sender */
  gasValue?: Maybe<Scalars['String']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Address of the reciever */
  reciever?: Maybe<Scalars['String']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsAnyArgs = {
  of: HarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsCountArgs = {
  uniq?: Maybe<HarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsCountBigIntArgs = {
  uniq?: Maybe<HarmonyTransactionsUniq>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsCreatesArgs = {
  creates?: Maybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsMaximumArgs = {
  get?: Maybe<HarmonyTransactionsMeasureable>;
  of: HarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsMinimumArgs = {
  get?: Maybe<HarmonyTransactionsMeasureable>;
  of: HarmonyTransactionsMeasureable;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsRecieverArgs = {
  reciever?: Maybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsStatusArgs = {
  status?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Transactions in Harmony blockchain */
export type HarmonyTransactionsTransactionIndexArgs = {
  transactionIndex?: Maybe<HashSelector>;
};

export type HarmonyTransactionsFilter = {
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  reciever?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  status?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};

export enum HarmonyTransactionsMeasureable {
  /** Date */
  Date = 'date',
  /** Gas provided by the sender */
  Gas = 'gas',
  /** Gas price provided by the sender */
  GasPrice = 'gasPrice',
  /** Gas value provided by the sender */
  GasValue = 'gasValue',
  /** Gas price provided by the sender */
  GasPrice = 'gas_price',
  /** Deligator Address */
  Reciever = 'reciever',
  /** Validator Address */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Value transferred in ATTO */
  Value = 'value'
}

export enum HarmonyTransactionsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique block */
  Ledger = 'ledger',
  /** Unique reciever */
  Reciever = 'reciever',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

/** Transfers in Harmony blockchain */
export type HarmonyTransfers = {
  __typename?: 'HarmonyTransfers';
  any?: Maybe<Scalars['String']>;
  /** Hash of the block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Data */
  data?: Maybe<Scalars['String']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Epoch */
  epoch?: Maybe<Scalars['BigInt']>;
  /** External */
  external?: Maybe<Scalars['Boolean']>;
  /** Gas provided by the sender */
  gas?: Maybe<Scalars['BigInt']>;
  /** Gas price provided by the sender */
  gasPrice?: Maybe<Scalars['String']>;
  /** Gas value provided by the sender */
  gasValue?: Maybe<Scalars['String']>;
  /** Hash of the block where this transaction was in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The number of transactions made by the sender prior to this one */
  nonce?: Maybe<Scalars['BigInt']>;
  /** Address of the sender */
  sender?: Maybe<Scalars['String']>;
  /** ShardID */
  shardId?: Maybe<Scalars['BigInt']>;
  /** Status */
  status?: Maybe<Scalars['Boolean']>;
  /** Successful of not */
  success?: Maybe<Scalars['Boolean']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Integer of the transactions index position in the block. null when its pending. */
  transactionHash?: Maybe<Scalars['String']>;
  /** Index of the transaction */
  transactionIndex?: Maybe<Scalars['Int']>;
  /** Address of the payer */
  transferFrom?: Maybe<Scalars['String']>;
  /** Address of the receiver */
  transferTo?: Maybe<Scalars['String']>;
  /** Value transferred in ATTO */
  value?: Maybe<Scalars['String']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersAnyArgs = {
  of: HarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersCountArgs = {
  uniq?: Maybe<HarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersCountBigIntArgs = {
  uniq?: Maybe<HarmonyTransfersUniq>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersMaximumArgs = {
  get?: Maybe<HarmonyTransfersMeasureable>;
  of: HarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersMinimumArgs = {
  get?: Maybe<HarmonyTransfersMeasureable>;
  of: HarmonyTransfersMeasureable;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersStatusArgs = {
  status?: Maybe<Scalars['Boolean']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersTransactionIndexArgs = {
  transactionIndex?: Maybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersTransferFromArgs = {
  transferFrom?: Maybe<HashSelector>;
};


/** Transfers in Harmony blockchain */
export type HarmonyTransfersTransferToArgs = {
  transferTo?: Maybe<HashSelector>;
};

export type HarmonyTransfersFilter = {
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  sender?: Maybe<HashSelector>;
  status?: Maybe<Scalars['Boolean']>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};

export enum HarmonyTransfersMeasureable {
  /** Date */
  Date = 'date',
  /** Gas provided by the sender */
  Gas = 'gas',
  /** Gas price provided by the sender */
  GasPrice = 'gasPrice',
  /** Gas value provided by the sender */
  GasValue = 'gasValue',
  /** Gas price provided by the sender */
  GasPrice = 'gas_price',
  /** Validator Address */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Value transferred in ATTO */
  Value = 'value'
}

export enum HarmonyTransfersUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique block */
  Ledger = 'ledger',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times',
  /** Unique transfer from */
  TransferFrom = 'transfer_from',
  /** Unique transfer to */
  TransferTo = 'transfer_to'
}

/** Select by hash */
export type HashSelector = {
  /** Hash in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Hash is */
  is?: Maybe<Scalars['String']>;
  /** Hash not */
  not?: Maybe<Scalars['String']>;
  /** Hash not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Hedera Chain */
export type Hedera = {
  __typename?: 'Hedera';
  /** Blockchain Arguments */
  arguments?: Maybe<Array<HederaArgument>>;
  /** Blockhain Calls */
  calls?: Maybe<Array<HederaCall>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<HederaCoinpath>>;
  /** Blockhain Inputs */
  inputs?: Maybe<Array<HederaInput>>;
  /** Blockhain Messages */
  messages?: Maybe<Array<HederaMessage>>;
  /** Blockchain Outputs */
  outputs?: Maybe<Array<HederaOutput>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<HederaTransaction>>;
};


/** Hedera Chain */
export type HederaArgumentsArgs = {
  any?: Maybe<Array<HederaArgumentFilter>>;
  date?: Maybe<DateSelector>;
  nodeAccount?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Hedera Chain */
export type HederaCallsArgs = {
  any?: Maybe<Array<HederaCallFilter>>;
  callInput?: Maybe<HashSelector>;
  callResult?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  nodeAccount?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Hedera Chain */
export type HederaCoinpathArgs = {
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Hedera Chain */
export type HederaInputsArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<HederaInputFilter>>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Hedera Chain */
export type HederaMessagesArgs = {
  any?: Maybe<Array<HederaMessageFilter>>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transactionRunningHash?: Maybe<HashSelector>;
};


/** Hedera Chain */
export type HederaOutputsArgs = {
  any?: Maybe<Array<HederaOutputFilter>>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Hedera Chain */
export type HederaTransactionsArgs = {
  any?: Maybe<Array<HederaTransactionFilter>>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};

/** Arguments in Hedera blockchain */
export type HederaArgument = {
  __typename?: 'HederaArgument';
  any?: Maybe<Scalars['String']>;
  /** Argument type */
  argtype?: Maybe<Scalars['String']>;
  /** Argument */
  argument?: Maybe<Scalars['String']>;
  chargedTxFee?: Maybe<Scalars['BigInt']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   * account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   * reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<Account>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  transactionBytes?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
  /** Value */
  value?: Maybe<Scalars['String']>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentAnyArgs = {
  of: HederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentCountArgs = {
  uniq?: Maybe<HederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentCountBigIntArgs = {
  uniq?: Maybe<HederaArgumentsUniq>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentInitialBalanceArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentMaxFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentMaximumArgs = {
  get?: Maybe<HederaArgumentsMeasureable>;
  of: HederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentMinimumArgs = {
  get?: Maybe<HederaArgumentsMeasureable>;
  of: HederaArgumentsMeasureable;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentResultArgs = {
  result?: Maybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentTransactionFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Arguments in Hedera blockchain */
export type HederaArgumentValidStartArgs = {
  nanoseconds?: Maybe<Scalars['BigInt']>;
  time?: Maybe<DateTimeSelector>;
};

export type HederaArgumentFilter = {
  date?: Maybe<DateSelector>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};

export enum HederaArgumentsMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum HederaArgumentsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique node account */
  SmartContractEntity = 'smart_contract_entity',
  /** Unique time */
  Times = 'times'
}

/** Calls in Hedera blockchain */
export type HederaCall = {
  __typename?: 'HederaCall';
  any?: Maybe<Scalars['String']>;
  /** Call input */
  callInput?: Maybe<Scalars['String']>;
  /** Call input */
  callResult?: Maybe<Scalars['String']>;
  chargedTxFee?: Maybe<Scalars['BigInt']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  gas?: Maybe<Scalars['Int']>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   * account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   * reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Smart contract */
  smartContractEntity?: Maybe<Account>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  transactionBytes?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
};


/** Calls in Hedera blockchain */
export type HederaCallAnyArgs = {
  of: HederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type HederaCallCallInputArgs = {
  callInput?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallCallResultArgs = {
  callResult?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallCountArgs = {
  uniq?: Maybe<HederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type HederaCallCountBigIntArgs = {
  uniq?: Maybe<HederaCallsUniq>;
};


/** Calls in Hedera blockchain */
export type HederaCallGasArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  callInput?: Maybe<HashSelector>;
  callResult?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallInitialBalanceArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallMaxFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallMaximumArgs = {
  get?: Maybe<HederaCallsMeasureable>;
  of: HederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type HederaCallMinimumArgs = {
  get?: Maybe<HederaCallsMeasureable>;
  of: HederaCallsMeasureable;
};


/** Calls in Hedera blockchain */
export type HederaCallResultArgs = {
  result?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Calls in Hedera blockchain */
export type HederaCallTransactionFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Calls in Hedera blockchain */
export type HederaCallValidStartArgs = {
  nanoseconds?: Maybe<Scalars['BigInt']>;
  time?: Maybe<DateTimeSelector>;
};

export type HederaCallFilter = {
  callInput?: Maybe<HashSelector>;
  callResult?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  smartContractEntity?: Maybe<StringSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};

export enum HederaCallsMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum HederaCallsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique node account */
  SmartContractEntity = 'smart_contract_entity',
  /** Unique time */
  Times = 'times'
}

/** Coinpath */
export type HederaCoinpath = {
  __typename?: 'HederaCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Attributes of transaction included in Coinpath result */
  transactions?: Maybe<Array<CoinpathEntry>>;
};


/** Coinpath */
export type HederaCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type HederaCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type HederaCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type HederaCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

/** Currency selector in Hedera blockchain. */
export type HederaCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Inputs in Hedera blockchain */
export type HederaInput = {
  __typename?: 'HederaInput';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   * account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   * reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar time */
  time?: Maybe<DateTime>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  /** Transfer Account */
  transferEntity?: Maybe<Account>;
  validStart?: Maybe<Timestamp>;
};


/** Inputs in Hedera blockchain */
export type HederaInputAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputAnyArgs = {
  of: HederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type HederaInputCountArgs = {
  uniq?: Maybe<HederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type HederaInputCountBigIntArgs = {
  uniq?: Maybe<HederaInputsUniq>;
};


/** Inputs in Hedera blockchain */
export type HederaInputCurrencyArgs = {
  currency?: Maybe<HederaCurrencySelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputEntityArgs = {
  entityType?: Maybe<EntityTypeSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputInitialBalanceArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputMaxFeeArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputMaximumArgs = {
  get?: Maybe<HederaInputMeasureable>;
  of: HederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type HederaInputMinimumArgs = {
  get?: Maybe<HederaInputMeasureable>;
  of: HederaInputMeasureable;
};


/** Inputs in Hedera blockchain */
export type HederaInputResultArgs = {
  result?: Maybe<HashSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Inputs in Hedera blockchain */
export type HederaInputTransactionFeeArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Inputs in Hedera blockchain */
export type HederaInputValidStartArgs = {
  nanoseconds?: Maybe<Scalars['BigInt']>;
  time?: Maybe<DateTimeSelector>;
};

export type HederaInputFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};

export enum HederaInputMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum HederaInputsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times'
}

/** Messages in Hedera blockchain */
export type HederaMessage = {
  __typename?: 'HederaMessage';
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   * account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   * reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar date time */
  time?: Maybe<DateTime>;
  /** Transaction running hash */
  topicRunningHash?: Maybe<Scalars['String']>;
  /** Transaction running hash */
  topicSequenceNumber?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
};


/** Messages in Hedera blockchain */
export type HederaMessageAnyArgs = {
  of: HederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type HederaMessageCountArgs = {
  uniq?: Maybe<HederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type HederaMessageCountBigIntArgs = {
  uniq?: Maybe<HederaMessagesUniq>;
};


/** Messages in Hedera blockchain */
export type HederaMessageEntityArgs = {
  entityType?: Maybe<EntityTypeSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageInitialBalanceArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transactionRunningHash?: Maybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageMaxFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transactionRunningHash?: Maybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageMaximumArgs = {
  get?: Maybe<HederaMessageMeasureable>;
  of: HederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type HederaMessageMinimumArgs = {
  get?: Maybe<HederaMessageMeasureable>;
  of: HederaMessageMeasureable;
};


/** Messages in Hedera blockchain */
export type HederaMessageResultArgs = {
  result?: Maybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Messages in Hedera blockchain */
export type HederaMessageTopicRunningHashArgs = {
  topicRunningHash?: Maybe<StringSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageTopicSequenceNumberArgs = {
  topicSequenceNumber?: Maybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageTransactionFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transactionRunningHash?: Maybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Messages in Hedera blockchain */
export type HederaMessageValidStartArgs = {
  nanoseconds?: Maybe<Scalars['BigInt']>;
  time?: Maybe<DateTimeSelector>;
};

export type HederaMessageFilter = {
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transactionRunningHash?: Maybe<HashSelector>;
};

export enum HederaMessageMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum HederaMessagesUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times'
}

export enum HederaNetwork {
  /** The Hedera mainnet */
  Hedera = 'hedera',
  /** The Hedera testnets */
  HederaTestnets = 'hedera_testnets'
}

/** Outputs in Hedera blockchain */
export type HederaOutput = {
  __typename?: 'HederaOutput';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   * account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   * reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar time */
  time?: Maybe<DateTime>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  /** Transfer Account */
  transferEntity?: Maybe<Account>;
  validStart?: Maybe<Timestamp>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputAnyArgs = {
  of: HederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type HederaOutputCountArgs = {
  uniq?: Maybe<HederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputCountBigIntArgs = {
  uniq?: Maybe<HederaOutputUniq>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputCurrencyArgs = {
  currency?: Maybe<HederaCurrencySelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputEntityArgs = {
  entityType?: Maybe<EntityTypeSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputInitialBalanceArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputMaxFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputMaximumArgs = {
  get?: Maybe<HederaOutputMeasureable>;
  of: HederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type HederaOutputMinimumArgs = {
  get?: Maybe<HederaOutputMeasureable>;
  of: HederaOutputMeasureable;
};


/** Outputs in Hedera blockchain */
export type HederaOutputResultArgs = {
  result?: Maybe<HashSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputTransactionFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Outputs in Hedera blockchain */
export type HederaOutputValidStartArgs = {
  nanoseconds?: Maybe<Scalars['BigInt']>;
  time?: Maybe<DateTimeSelector>;
};

export type HederaOutputFilter = {
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
  transferEntity?: Maybe<StringSelector>;
};

export enum HederaOutputMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum HederaOutputUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times',
  /** Unique Transfer entity */
  TransferEntity = 'transfer_entity'
}

/** Transactions in Hedera blockchain */
export type HederaTransaction = {
  __typename?: 'HederaTransaction';
  any?: Maybe<Scalars['String']>;
  consensusTimestamp?: Maybe<Timestamp>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Entity */
  entity?: Maybe<Entity>;
  /** Currency of transfer */
  feeCurrency?: Maybe<Currency>;
  initialBalance?: Maybe<Scalars['Float']>;
  maxFee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  memo?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /**
   * Used to reference a specific
   * account of the node the transaction is being sent to
   */
  nodeAccount?: Maybe<Account>;
  /**
   * Used to
   * reference a specific account in transactions
   */
  payerAccount?: Maybe<Account>;
  /** Transaction result */
  result?: Maybe<TransactionResult>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Calendar time */
  time?: Maybe<DateTime>;
  transactionBytes?: Maybe<Scalars['String']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash where transfer happened */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transaction Type */
  transactionType?: Maybe<Scalars['String']>;
  transactionValidDurationInSec?: Maybe<Scalars['Int']>;
  validStart?: Maybe<Timestamp>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionAnyArgs = {
  of: HederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionCountArgs = {
  uniq?: Maybe<HederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionCountBigIntArgs = {
  uniq?: Maybe<HederaTransactionsUniq>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionEntityArgs = {
  entityType?: Maybe<EntityTypeSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionInitialBalanceArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionMaxFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionMaximumArgs = {
  get?: Maybe<HederaTransactionMeasureable>;
  of: HederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionMinimumArgs = {
  get?: Maybe<HederaTransactionMeasureable>;
  of: HederaTransactionMeasureable;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionResultArgs = {
  result?: Maybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionTransactionFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Transactions in Hedera blockchain */
export type HederaTransactionValidStartArgs = {
  nanoseconds?: Maybe<Scalars['BigInt']>;
  time?: Maybe<DateTimeSelector>;
};

export type HederaTransactionFilter = {
  date?: Maybe<DateSelector>;
  entityType?: Maybe<EntityTypeSelector>;
  nodeAccount?: Maybe<StringSelector>;
  payerAccount?: Maybe<StringSelector>;
  result?: Maybe<HashSelector>;
  success?: Maybe<Scalars['Boolean']>;
  transactionHash?: Maybe<HashSelector>;
};

export enum HederaTransactionMeasureable {
  /** Date */
  Date = 'date',
  /** Max Fee */
  MaxFee = 'max_fee',
  /** Time */
  Time = 'time',
  /** Charged Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Valid duration */
  ValidDuration = 'valid_duration',
  /** Valid start */
  ValidStart = 'valid_start'
}

export enum HederaTransactionsUniq {
  /** Unique consensus time */
  ConsensusTimes = 'consensus_times',
  /** Unique date count */
  Dates = 'dates',
  /** Unique entity id */
  EntityId = 'entity_id',
  /** Unique entity type */
  EntityType = 'entity_type',
  /** Unique initial balance */
  InitialBalance = 'initial_balance',
  /** Unique node account */
  NodeAccount = 'node_account',
  /** Unique payer account */
  PayerAccount = 'payer_account',
  /** Unique time */
  Times = 'times',
  /** Unique transaction type */
  TransactionType = 'transaction_type'
}

/** Input Script Type of UTXO transaction input */
export type InputScript = {
  __typename?: 'InputScript';
  /** Script annotation */
  annotation?: Maybe<Scalars['String']>;
  /** Long script pattern */
  pattern: Scalars['String'];
  /** Short script pattern */
  shortPattern: Scalars['String'];
  /** Simple script pattern */
  simplePattern: Scalars['String'];
  /** Script type */
  type?: Maybe<BitcoinInputScriptType>;
};

/** Select by ID */
export type IntIdSelector = {
  /** ID in range */
  between?: Maybe<Array<Scalars['Int']>>;
  /** ID greater than */
  gt?: Maybe<Scalars['Int']>;
  /** ID greater or equal than */
  gteq?: Maybe<Scalars['Int']>;
  /** ID in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** ID is */
  is?: Maybe<Scalars['Int']>;
  /** ID less than */
  lt?: Maybe<Scalars['Int']>;
  /** ID less or equal than */
  lteq?: Maybe<Scalars['Int']>;
  /** ID not */
  not?: Maybe<Scalars['Int']>;
  /** ID not in the list */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

/** Select limited upper number */
export type IntegerLimitedSelector = {
  /** in range */
  between?: Maybe<Array<Scalars['Int']>>;
  /** in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** is */
  is?: Maybe<Scalars['Int']>;
  /** less than */
  lt?: Maybe<Scalars['Int']>;
  /** less or equal than */
  lteq?: Maybe<Scalars['Int']>;
};

/** Select by number */
export type IntegerSelector = {
  /** in range */
  between?: Maybe<Array<Scalars['Int']>>;
  /** greater than */
  gt?: Maybe<Scalars['Int']>;
  /** greater or equal than */
  gteq?: Maybe<Scalars['Int']>;
  /** in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** is */
  is?: Maybe<Scalars['Int']>;
  /** less than */
  lt?: Maybe<Scalars['Int']>;
  /** less or equal than */
  lteq?: Maybe<Scalars['Int']>;
  /** not */
  not?: Maybe<Scalars['Int']>;
  /** not in the list */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

/** Libra */
export type Libra = {
  __typename?: 'Libra';
  /** Libra Network Blocks */
  blocks?: Maybe<Array<LibraBlock>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<LibraCoinpath>>;
  /** Libra Network Currency Minting */
  mints?: Maybe<Array<LibraMints>>;
  /** Libra Network Transactions */
  transactions?: Maybe<Array<LibraTransactions>>;
  /** Libra Network Currency Transfers */
  transfers?: Maybe<Array<LibraTransfers>>;
};


/** Libra */
export type LibraBlocksArgs = {
  any?: Maybe<Array<LibraBlockFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  metadata?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Libra */
export type LibraCoinpathArgs = {
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Libra */
export type LibraMintsArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<LibraMintFilter>>;
  block?: Maybe<BlockSelector>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  minter?: Maybe<AddressSelector>;
  options?: Maybe<QueryOptions>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Libra */
export type LibraTransactionsArgs = {
  any?: Maybe<Array<LibraTransactionFilter>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Libra */
export type LibraTransfersArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<LibraTransferFilter>>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<AddressSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};

/** Block */
export type LibraBlock = {
  __typename?: 'LibraBlock';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  gasUsed?: Maybe<Scalars['Float']>;
  /** Block round in blockchain */
  height: Scalars['Int'];
  /** Key */
  key?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  /** Metadata */
  metadata?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Proposer */
  proposer?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** Version of transaction for this block */
  version: Scalars['Int'];
  /** Version hash of transaction for this block */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Block */
export type LibraBlockAnyArgs = {
  of: LibraBlocksMeasureable;
};


/** Block */
export type LibraBlockCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  metadata?: Maybe<StringSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<LibraBlockUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Block */
export type LibraBlockCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  metadata?: Maybe<StringSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<LibraBlockUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Block */
export type LibraBlockGasUsedArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  metadata?: Maybe<StringSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Block */
export type LibraBlockHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Block */
export type LibraBlockMaximumArgs = {
  get?: Maybe<LibraBlocksMeasureable>;
  of: LibraBlocksMeasureable;
};


/** Block */
export type LibraBlockMetadataArgs = {
  metadata?: Maybe<StringSelector>;
};


/** Block */
export type LibraBlockMinimumArgs = {
  get?: Maybe<LibraBlocksMeasureable>;
  of: LibraBlocksMeasureable;
};


/** Block */
export type LibraBlockProposerArgs = {
  proposer?: Maybe<AddressSelector>;
};


/** Block */
export type LibraBlockTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Block */
export type LibraBlockVersionArgs = {
  version?: Maybe<IntegerSelector>;
};

export type LibraBlockFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  metadata?: Maybe<StringSelector>;
  proposer?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
};

export enum LibraBlockUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Proposer */
  Proposer = 'proposer'
}

export enum LibraBlocksMeasureable {
  /** Block round */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas Used */
  GasUsed = 'gas_used',
  /** Proposer */
  Proposer = 'proposer',
  /** Time */
  Time = 'time',
  /** Version */
  Version = 'version'
}

/** Coinpath */
export type LibraCoinpath = {
  __typename?: 'LibraCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<Address>;
  /** Sender address */
  sender?: Maybe<Address>;
  /** Transaction of transfer happened */
  transaction?: Maybe<LibraTransactionValue>;
};


/** Coinpath */
export type LibraCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type LibraCoinpathAnyArgs = {
  of: LibraCoinpathMeasureable;
};


/** Coinpath */
export type LibraCoinpathMaximumArgs = {
  get?: Maybe<LibraCoinpathMeasureable>;
  of: LibraCoinpathMeasureable;
};


/** Coinpath */
export type LibraCoinpathMinimumArgs = {
  get?: Maybe<LibraCoinpathMeasureable>;
  of: LibraCoinpathMeasureable;
};

export enum LibraCoinpathMeasureable {
  /** Block */
  Block = 'block',
  /** Depth */
  Depth = 'depth',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Version */
  Version = 'version'
}

/**
 * Currency selector in Libra blockchain.
 * Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
 * Use name of currency for selection
 */
export type LibraCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

export type LibraMintFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  block?: Maybe<BlockSelector>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  minter?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
};

/** Mints in Libra blockchain */
export type LibraMints = {
  __typename?: 'LibraMints';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Minter */
  minter?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Mint timestamp */
  timestamp?: Maybe<DateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Mints in Libra blockchain */
export type LibraMintsAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  block?: Maybe<BlockSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  minter?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Mints in Libra blockchain */
export type LibraMintsAnyArgs = {
  of: LibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type LibraMintsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Mints in Libra blockchain */
export type LibraMintsCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  block?: Maybe<BlockSelector>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  minter?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<LibraMintsUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Mints in Libra blockchain */
export type LibraMintsCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  block?: Maybe<BlockSelector>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  minter?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<LibraMintsUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Mints in Libra blockchain */
export type LibraMintsCurrencyArgs = {
  currency?: Maybe<Array<LibraCurrencySelector>>;
};


/** Mints in Libra blockchain */
export type LibraMintsMaximumArgs = {
  get?: Maybe<LibraMintsMeasureable>;
  of: LibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type LibraMintsMinimumArgs = {
  get?: Maybe<LibraMintsMeasureable>;
  of: LibraMintsMeasureable;
};


/** Mints in Libra blockchain */
export type LibraMintsMinterArgs = {
  sender?: Maybe<AddressSelector>;
};


/** Mints in Libra blockchain */
export type LibraMintsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Mints in Libra blockchain */
export type LibraMintsTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Mints in Libra blockchain */
export type LibraMintsVersionArgs = {
  version?: Maybe<IntegerSelector>;
};

export enum LibraMintsMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Minter */
  Minter = 'minter',
  /** Time */
  Time = 'time',
  /** Version */
  Version = 'version',
  /** Mint version hash */
  VersionHash = 'version_hash'
}

export enum LibraMintsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique minters */
  Minters = 'minters',
  /** Unique versions */
  Versions = 'versions'
}

export type LibraTransactionFilter = {
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};

/** Blockchain transaction with value */
export type LibraTransactionValue = {
  __typename?: 'LibraTransactionValue';
  /** Transaction value */
  value: Scalars['Float'];
  /** Transaction version */
  version: Scalars['Int'];
};

/** Transactions in Libra blockchain */
export type LibraTransactions = {
  __typename?: 'LibraTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Expiration Time */
  expirationTime?: Maybe<DateTime>;
  gas?: Maybe<Scalars['Int']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas unit price */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']>;
  /** Script Type */
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  /** Transaction sender */
  sender?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction timestamp */
  timestamp?: Maybe<DateTime>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsAnyArgs = {
  of: LibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsCountArgs = {
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  uniq?: Maybe<LibraTransactionsUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  uniq?: Maybe<LibraTransactionsUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsGasArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsGasCurrencyArgs = {
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsGasPriceArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsGasValueArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsMaximumArgs = {
  get?: Maybe<LibraTransactionsMeasureable>;
  of: LibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsMinimumArgs = {
  get?: Maybe<LibraTransactionsMeasureable>;
  of: LibraTransactionsMeasureable;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsScriptHashArgs = {
  scriptHash?: Maybe<StringSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsSenderArgs = {
  txSender?: Maybe<AddressSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in Libra blockchain */
export type LibraTransactionsVersionArgs = {
  version?: Maybe<IntegerSelector>;
};

export enum LibraTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Script Hash */
  ScriptHash = 'script_hash',
  /** Time */
  Time = 'time',
  /** Transaction Sender */
  TxSender = 'tx_sender',
  /** Version */
  Version = 'version'
}

export enum LibraTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction script hashes */
  Scripts = 'scripts',
  /** Unique transaction senders */
  Senders = 'senders',
  /** Unique versions */
  Versions = 'versions'
}

export type LibraTransferFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};

/** Transfers in Libra blockchain */
export type LibraTransfers = {
  __typename?: 'LibraTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Expiration Time */
  expirationTime?: Maybe<DateTime>;
  gas?: Maybe<Scalars['Int']>;
  /** Currency of gas */
  gasCurrency?: Maybe<Currency>;
  /** Gas price */
  gasPrice: Scalars['Float'];
  gasValue?: Maybe<Scalars['Float']>;
  /** Max gas amount */
  maxGasAmount?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Public key */
  publicKey?: Maybe<Scalars['String']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Script Hash */
  scriptHash?: Maybe<Scalars['String']>;
  /** Script Type */
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Sequence number */
  sequenceNumber?: Maybe<Scalars['Int']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature scheme */
  signatureScheme?: Maybe<Scalars['String']>;
  /** Status Name */
  statusName?: Maybe<Scalars['String']>;
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
  /** Transfer timestamp */
  timestamp?: Maybe<DateTime>;
  /** Transaction sender */
  txSender?: Maybe<Address>;
  /** Version of blockchain for this transaction */
  version: Scalars['Int'];
  /** Version hash of blockchain for this transaction */
  versionHash: Scalars['String'];
  /** VM Status */
  vmStatus?: Maybe<Scalars['Int']>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersAnyArgs = {
  of: LibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type LibraTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  uniq?: Maybe<TransfersUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  uniq?: Maybe<TransfersUniq>;
  version?: Maybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersCurrencyArgs = {
  currency?: Maybe<Array<LibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersGasArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersGasCurrencyArgs = {
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersGasValueArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  currency?: Maybe<Array<LibraCurrencySelector>>;
  date?: Maybe<DateSelector>;
  gasCurrency?: Maybe<Array<LibraCurrencySelector>>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  scriptHash?: Maybe<StringSelector>;
  scriptType?: Maybe<ScriptTypeSelectorSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
  txSender?: Maybe<AddressSelector>;
  version?: Maybe<IntegerSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersMaximumArgs = {
  get?: Maybe<LibraTransfersMeasureable>;
  of: LibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type LibraTransfersMinimumArgs = {
  get?: Maybe<LibraTransfersMeasureable>;
  of: LibraTransfersMeasureable;
};


/** Transfers in Libra blockchain */
export type LibraTransfersReceiverArgs = {
  receiver?: Maybe<AddressSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersScriptHashArgs = {
  scriptHash?: Maybe<StringSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersSenderArgs = {
  sender?: Maybe<AddressSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersTxSenderArgs = {
  txSender?: Maybe<AddressSelector>;
};


/** Transfers in Libra blockchain */
export type LibraTransfersVersionArgs = {
  version?: Maybe<IntegerSelector>;
};

export enum LibraTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Gas used */
  Gas = 'gas',
  /** Gas price */
  GasPrice = 'gas_price',
  /** Gas value */
  GasValue = 'gas_value',
  /** Block */
  Height = 'height',
  /** Receiver */
  Receiver = 'receiver',
  /** Script Hash */
  ScriptHash = 'script_hash',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transfer Sender */
  TxSender = 'tx_sender',
  /** Version */
  Version = 'version',
  /** Version hash */
  VersionHash = 'version_hash'
}

/** Limit by definition */
export type LimitByOption = {
  /** Take limit for each combination of the field */
  each: Scalars['String'];
  /** Limit number of results */
  limit?: Maybe<Scalars['Int']>;
  /** Offset of results, starting from 0 */
  offset?: Maybe<Scalars['Int']>;
};

/** Solana Log */
export type Log = {
  __typename?: 'Log';
  consumed: Scalars['BigInt'];
  instruction: Scalars['String'];
  logs: Scalars['String'];
  result: Scalars['String'];
  totalGas: Scalars['BigInt'];
};

/** Smart contract method */
export type Method = {
  __typename?: 'Method';
  /** Name */
  name?: Maybe<Scalars['String']>;
  /** Signature */
  signature?: Maybe<Scalars['String']>;
  /** Signature Hash */
  signatureHash: Scalars['String'];
};

/** Smart contract method. In selector you can use the name, signature or hex hash */
export type MethodSelector = {
  /** Method signature in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Method signature is */
  is?: Maybe<Scalars['String']>;
  /** Method signature not */
  not?: Maybe<Scalars['String']>;
  /** Method signature not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Information about miniblock */
export type MiniblockElrond = {
  __typename?: 'MiniblockElrond';
  /** Miniblock hash */
  hash?: Maybe<Scalars['String']>;
  /** Hash of the receiver block */
  receiverBlockHash?: Maybe<Scalars['String']>;
  /** Number of the receiver shard */
  receiverShard?: Maybe<Scalars['String']>;
  /** Miniblock type */
  type?: Maybe<Scalars['String']>;
};


/** Information about miniblock */
export type MiniblockElrondHashArgs = {
  miniblockHash?: Maybe<HashSelector>;
};


/** Information about miniblock */
export type MiniblockElrondReceiverBlockHashArgs = {
  miniblockReceiverBlockHash?: Maybe<HashSelector>;
};


/** Information about miniblock */
export type MiniblockElrondReceiverShardArgs = {
  miniblockReceiverShard?: Maybe<IntIdSelector>;
};


/** Information about miniblock */
export type MiniblockElrondTypeArgs = {
  type?: Maybe<StringSelector>;
};

/** Name with an identifier */
export type NameWithId = {
  __typename?: 'NameWithId';
  /** ID */
  id?: Maybe<Scalars['Int']>;
  /** Name */
  name?: Maybe<Scalars['String']>;
};

export enum Network {
  /** Algorand Mainnet (ALGO) */
  Algorand = 'algorand',
  /** Algorand Betanet */
  AlgorandBetanet = 'algorand_betanet',
  /** Algorand Testnet */
  AlgorandTestnet = 'algorand_testnet',
  /** Binance DEX */
  Binance = 'binance',
  /** Bitcoin Cash ( BCH ) */
  Bitcash = 'bitcash',
  /** Bitcoin ( BTC ) */
  Bitcoin = 'bitcoin',
  /** Bitcoin SV ( BSV ) */
  Bitcoinsv = 'bitcoinsv',
  /** Binance Smart Chain Mainnet */
  Bsc = 'bsc',
  /** Binance Smart Chain Testnet */
  BscTestnet = 'bsc_testnet',
  /** Cardano ( ADA ) */
  Cardano = 'cardano',
  /** Celo Alfajores Testnet */
  CeloAlfajores = 'celo_alfajores',
  /** Celo Baklava Testnet */
  CeloBaklava = 'celo_baklava',
  /** Celo RC1 */
  CeloRc1 = 'celo_rc1',
  /** Conflux Oceanus */
  ConfluxOceanus = 'conflux_oceanus',
  /** Conflux Tethys */
  ConfluxTethys = 'conflux_tethys',
  /** Dash ( DASH ) */
  Dash = 'dash',
  /** Diem Testnet */
  DiemTestnet = 'diem_testnet',
  /** Dogecoin ( DOGE ) */
  Dogecoin = 'dogecoin',
  /** Elrond Mainnet */
  Elrond = 'elrond',
  /** EOS Mainnet */
  Eos = 'eos',
  /** Beacon Chain Ethereum 2.0 */
  Eth2 = 'eth2',
  /** Ethereum Classic */
  Ethclassic = 'ethclassic',
  /** Ethereum Classic ( no reorg from block 10904146) */
  EthclassicReorg = 'ethclassic_reorg',
  /** Ethereum Mainnet */
  Ethereum = 'ethereum',
  /** Filecoin Mainnet */
  Filecoin = 'filecoin',
  /** Goerli Ethereum Testnet */
  Goerli = 'goerli',
  /** Hedera Hashgraph */
  Hedera = 'hedera',
  /** Klaytn Mainnet */
  Klaytn = 'klaytn',
  /** Libra Testnet */
  LibraTestnet = 'libra_testnet',
  /** Litecoin ( LTC ) */
  Litecoin = 'litecoin',
  /** Matic (Polygon) Mainnet */
  Matic = 'matic',
  /** Medalla Ethereum 2.0 Beacon Testnet */
  Medalla = 'medalla',
  /** Solana Mainnet */
  Solana = 'solana',
  /** TRON Mainnet */
  Tron = 'tron',
  /** Velas Mainnet */
  Velas = 'velas',
  /** Velas Testnet */
  VelasTestnet = 'velas_testnet',
  /** Zcash ( ZEC ) */
  Zcash = 'zcash'
}

/** Offchain Data */
export type Offchain = {
  __typename?: 'Offchain';
  /** Historical COVID data */
  covid?: Maybe<CovidHistory>;
};

/** Select order by ID */
export type OrderIdSelector = {
  /** Order ID in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Order ID is */
  is?: Maybe<Scalars['String']>;
  /** Order ID not */
  not?: Maybe<Scalars['String']>;
  /** Order ID not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Select by order side */
export type OrderSideSelector = {
  /** Order Side in the list */
  in?: Maybe<Array<BinanceOrderSide>>;
  /** Order Side is */
  is?: Maybe<BinanceOrderSide>;
  /** Order Side not */
  not?: Maybe<BinanceOrderSide>;
  /** Order Side not in the list */
  notIn?: Maybe<Array<BinanceOrderSide>>;
};

/** Select by order status */
export type OrderStatusSelector = {
  /** Order Status in the list */
  in?: Maybe<Array<BinanceOrderStatus>>;
  /** Order Status is */
  is?: Maybe<BinanceOrderStatus>;
  /** Order Status not */
  not?: Maybe<BinanceOrderStatus>;
  /** Order Status not in the list */
  notIn?: Maybe<Array<BinanceOrderStatus>>;
};

/** Select by order time in force */
export type OrderTimeInForceSelector = {
  /** Order TimeInForce in the list */
  in?: Maybe<Array<BinanceOrderTimeInForce>>;
  /** Order TimeInForce is */
  is?: Maybe<BinanceOrderTimeInForce>;
  /** Order TimeInForce not */
  not?: Maybe<BinanceOrderTimeInForce>;
  /** Order TimeInForce not in the list */
  notIn?: Maybe<Array<BinanceOrderTimeInForce>>;
};

/** Select by order type */
export type OrderTypeSelector = {
  /** Order Type in the list */
  in?: Maybe<Array<BinanceOrderType>>;
  /** Order Type is */
  is?: Maybe<BinanceOrderType>;
  /** Order Type not */
  not?: Maybe<BinanceOrderType>;
  /** Order Type not in the list */
  notIn?: Maybe<Array<BinanceOrderType>>;
};

/** Select by output index ( o based ) */
export type OutputIndexSelector = {
  /** Output index in range */
  between?: Maybe<Array<Scalars['Int']>>;
  /** Output index greater than */
  gt?: Maybe<Scalars['Int']>;
  /** Output index greater or equal than */
  gteq?: Maybe<Scalars['Int']>;
  /** Output index in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Output index is */
  is?: Maybe<Scalars['Int']>;
  /** Output index less than */
  lt?: Maybe<Scalars['Int']>;
  /** Output index less or equal than */
  lteq?: Maybe<Scalars['Int']>;
  /** Output index not */
  not?: Maybe<Scalars['Int']>;
  /** Output index not in the list */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

/** Output Script Type of UTXO transaction output */
export type OutputScript = {
  __typename?: 'OutputScript';
  /** Script annotation */
  annotation?: Maybe<Scalars['String']>;
  /** Long script pattern */
  pattern: Scalars['String'];
  /** Short script pattern */
  short: Scalars['String'];
  /** Simple script pattern */
  simplePattern: Scalars['String'];
  /** Script type */
  type?: Maybe<BitcoinOutputScriptType>;
};

export enum PriceAggregateFunction {
  /** Any value */
  Any = 'any',
  /** Last value */
  AnyLast = 'anyLast',
  /** Average */
  Average = 'average',
  /** Maximum */
  Maximum = 'maximum',
  /** Median */
  Median = 'median',
  /** Minimum */
  Minimum = 'minimum',
  /** Aggregated over interval */
  Sum = 'sum'
}

/** Solana Program */
export type Program = {
  __typename?: 'Program';
  id: Scalars['String'];
  name: Scalars['String'];
  parsedName: Scalars['String'];
};

export enum Protocol {
  /** Algorand */
  Algorand = 'algorand',
  /** Binance DEX */
  Binance = 'binance',
  /** Bitcoin */
  Bitcoin = 'bitcoin',
  /** Cardano */
  Cardano = 'cardano',
  /** Elrond */
  Elrond = 'elrond',
  /** EOS */
  Eos = 'eos',
  /** Ethereum */
  Ethereum = 'ethereum',
  /** Filecoin */
  Filecoin = 'filecoin',
  /** Hedera Hashgraph */
  Hedera = 'hedera',
  /** Libra */
  Libra = 'libra',
  /** Solana */
  Solana = 'solana',
  /** Tron */
  Tron = 'tron'
}

/** Blockchain Unified GraphQL API */
export type Query = {
  __typename?: 'Query';
  /** Algorand Chains Dataset */
  algorand?: Maybe<Algorand>;
  /** Binance DEX Chain Dataset */
  binance?: Maybe<Binance>;
  /** Bitcoin and other UTXO Chains Dataset */
  bitcoin?: Maybe<Bitcoin>;
  /** Cardano Chain Dataset */
  cardano?: Maybe<Cardano>;
  /** Conflux Chains Dataset */
  conflux?: Maybe<Conflux>;
  /** Diem ( former Libra ) Testnet Dataset */
  diem?: Maybe<Libra>;
  /** Elrond Dataset */
  elrond?: Maybe<Elrond>;
  /** EOS Mainnet Dataset */
  eos?: Maybe<Eos>;
  /** Ethereum Mainnet / Classic Chain Datasets */
  ethereum?: Maybe<Ethereum>;
  /** Ethereum v2.0 Beacon Chain Datasets */
  ethereum2?: Maybe<Ethereum2>;
  /** Filecoin Dataset */
  filecoin?: Maybe<Filecoin>;
  /** Harmony Dataset */
  harmony?: Maybe<Harmony>;
  /** Hedera Dataset */
  hedera?: Maybe<Hedera>;
  /** Offchain data */
  offchain?: Maybe<Offchain>;
  /** Ripple Dataset */
  ripple?: Maybe<Ripple>;
  /** Search by query string */
  search?: Maybe<Array<Result>>;
  /** Solana Dataset */
  solana?: Maybe<Solana>;
  /** Stellar Dataset */
  stellar?: Maybe<Stellar>;
  /** Tron Mainnet Dataset */
  tron?: Maybe<Tron>;
};


/** Blockchain Unified GraphQL API */
export type QueryAlgorandArgs = {
  network?: Maybe<AlgorandNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryBitcoinArgs = {
  network?: Maybe<BitcoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryCardanoArgs = {
  network?: Maybe<CardanoNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryConfluxArgs = {
  network?: Maybe<ConfluxNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryDiemArgs = {
  network?: Maybe<DiemNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryElrondArgs = {
  network?: Maybe<ElrondNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryEosArgs = {
  network?: Maybe<EosNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryEthereumArgs = {
  network?: Maybe<EthereumNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryEthereum2Args = {
  network?: Maybe<Ethereum2Network>;
};


/** Blockchain Unified GraphQL API */
export type QueryFilecoinArgs = {
  network?: Maybe<FilecoinNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryHarmonyArgs = {
  network?: Maybe<HarmonyNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryHederaArgs = {
  network?: Maybe<HederaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryRippleArgs = {
  network?: Maybe<RippleNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QuerySearchArgs = {
  limit?: Maybe<Scalars['Int']>;
  network?: Maybe<Network>;
  offset?: Maybe<Scalars['Int']>;
  string: Scalars['String'];
};


/** Blockchain Unified GraphQL API */
export type QuerySolanaArgs = {
  network?: Maybe<SolanaNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryStellarArgs = {
  network?: Maybe<StellarNetwork>;
};


/** Blockchain Unified GraphQL API */
export type QueryTronArgs = {
  network?: Maybe<TronNetwork>;
};

/** Limits, Ordering, Constraints */
export type QueryOptions = {
  /** Ordering field(s) for ascending */
  asc?: Maybe<Array<Scalars['String']>>;
  /** Ordering field(s) for descending */
  desc?: Maybe<Array<Scalars['String']>>;
  /** Limit number of results */
  limit?: Maybe<Scalars['Int']>;
  /** Limit number of results by specific field */
  limitBy?: Maybe<LimitByOption>;
  /** Offset of results, starting from 0 */
  offset?: Maybe<Scalars['Int']>;
};

/** Solana Receiver */
export type Receiver = {
  __typename?: 'Receiver';
  address: Scalars['String'];
  mintAccount: Scalars['String'];
  type: Scalars['String'];
};

/** Search result item */
export type Result = {
  __typename?: 'Result';
  /** Blockchain where result is found */
  network: BlockchainNetwork;
  /** Subject in blockchain */
  subject: Subject;
};

/** Select by reward type */
export type RewardTypeSelector = {
  /** Type in the list */
  in?: Maybe<Array<SolanaRewardType>>;
  /** Type is */
  is?: Maybe<SolanaRewardType>;
  /** Type not */
  not?: Maybe<SolanaRewardType>;
  /** Type not in the list */
  notIn?: Maybe<Array<SolanaRewardType>>;
};

/** Ripple Chain */
export type Ripple = {
  __typename?: 'Ripple';
  /** The Escrow object type represents a held payment of XRP waiting to be executed or canceled */
  accountRoots?: Maybe<Array<RippleAccountRoots>>;
  /** Ripple Balances */
  balances?: Maybe<Array<RippleBalances>>;
  /** Ripple Blocks */
  blocks?: Maybe<Array<RippleBlocks>>;
  /** A check that can be redeemed for money by its destination. */
  checks?: Maybe<Array<RippleChecks>>;
  /** The Escrow object type represents a held payment of XRP waiting to be executed or canceled */
  escrows?: Maybe<Array<RippleEscrows>>;
  /** An order to make a currency trade. */
  offers?: Maybe<Array<RippleOffers>>;
  /** Ripple Payments */
  payments?: Maybe<Array<RipplePayments>>;
  /** The RippleState object type connects two accounts in a single currency */
  rippleStates?: Maybe<Array<RippleRippleStates>>;
  /** Ripple Transactions */
  transactions?: Maybe<Array<RippleTransactions>>;
  /** Ripple Transfers */
  transfers?: Maybe<Array<RippleTransfers>>;
};


/** Ripple Chain */
export type RippleAccountRootsArgs = {
  account?: Maybe<HashSelector>;
  any?: Maybe<Array<RippleAccountRootsFilter>>;
  balance?: Maybe<IntegerSelector>;
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  domain?: Maybe<StringSelector>;
  flags?: Maybe<IntegerSelector>;
  operation?: Maybe<HashSelector>;
  options?: Maybe<QueryOptions>;
  ownerCount?: Maybe<IntegerSelector>;
  prevBalance?: Maybe<IntegerSelector>;
  previousTxnId?: Maybe<HashSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sequence?: Maybe<IntegerSelector>;
  transactionType?: Maybe<TypeSelector>;
  transferRate?: Maybe<IntegerSelector>;
};


/** Ripple Chain */
export type RippleBalancesArgs = {
  account?: Maybe<HashSelector>;
  any?: Maybe<Array<RippleBalancesFilter>>;
  date?: Maybe<DateSelector>;
  flags?: Maybe<HashSelector>;
  issuer?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  prevBalance?: Maybe<HashSelector>;
  prevLedgerSeq?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionSender?: Maybe<HashSelector>;
};


/** Ripple Chain */
export type RippleBlocksArgs = {
  accountHash?: Maybe<HashSelector>;
  any?: Maybe<Array<RippleBlocksFilter>>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  ledgerHash?: Maybe<HashSelector>;
  options?: Maybe<QueryOptions>;
  transactionHash?: Maybe<HashSelector>;
};


/** Ripple Chain */
export type RippleChecksArgs = {
  any?: Maybe<Array<RippleChecksFilter>>;
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  destination?: Maybe<HashSelector>;
  destinationTag?: Maybe<IntegerSelector>;
  expiration?: Maybe<IntegerSelector>;
  flags?: Maybe<IntegerSelector>;
  invoiceId?: Maybe<IntegerSelector>;
  operation?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  previousTxnId?: Maybe<IntegerSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sendMax?: Maybe<IntegerSelector>;
  sender?: Maybe<HashSelector>;
  sequence?: Maybe<IntegerSelector>;
  sourceTag?: Maybe<IntegerSelector>;
  transactionType?: Maybe<HashSelector>;
};


/** Ripple Chain */
export type RippleEscrowsArgs = {
  amount?: Maybe<IntegerSelector>;
  any?: Maybe<Array<RippleEscrowsFilter>>;
  blockHeight?: Maybe<BlockSelector>;
  cancelAfter?: Maybe<IntegerSelector>;
  condition?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  destination?: Maybe<HashSelector>;
  destinationTag?: Maybe<IntegerSelector>;
  finishedAfter?: Maybe<IntegerSelector>;
  flags?: Maybe<IntegerSelector>;
  operation?: Maybe<HashSelector>;
  options?: Maybe<QueryOptions>;
  previousTxnId?: Maybe<IntegerSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sender?: Maybe<HashSelector>;
  sourceTag?: Maybe<IntegerSelector>;
  transactionType?: Maybe<TypeSelector>;
};


/** Ripple Chain */
export type RippleOffersArgs = {
  account?: Maybe<HashSelector>;
  any?: Maybe<Array<RippleOffersFilter>>;
  bookDirectory?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  sequence?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionSender?: Maybe<HashSelector>;
  transactionType?: Maybe<HashSelector>;
};


/** Ripple Chain */
export type RipplePaymentsArgs = {
  amountIssuer?: Maybe<HashSelector>;
  any?: Maybe<Array<RipplePaymentsFilter>>;
  date?: Maybe<DateSelector>;
  deliverIssuer?: Maybe<HashSelector>;
  deliverMinIssuer?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  sendMaxIssuer?: Maybe<HashSelector>;
  tag?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};


/** Ripple Chain */
export type RippleRippleStatesArgs = {
  any?: Maybe<Array<RippleStatesFilter>>;
  balance?: Maybe<IntegerSelector>;
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  flags?: Maybe<IntegerSelector>;
  highAccount?: Maybe<HashSelector>;
  lowAccount?: Maybe<HashSelector>;
  operation?: Maybe<StringSelector>;
  options?: Maybe<QueryOptions>;
  preBalance?: Maybe<IntegerSelector>;
  previousTxnId?: Maybe<IntegerSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sender?: Maybe<HashSelector>;
  transactionType?: Maybe<HashSelector>;
};


/** Ripple Chain */
export type RippleTransactionsArgs = {
  any?: Maybe<Array<RippleTransactionsFilter>>;
  date?: Maybe<DateSelector>;
  lastLedgerSequence?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  result?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  sequence?: Maybe<HashSelector>;
  status?: Maybe<Scalars['Boolean']>;
  transactionFee?: Maybe<TransactionTypeSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<TransactionTypeSelector>;
};


/** Ripple Chain */
export type RippleTransfersArgs = {
  any?: Maybe<Array<RippleTransfersFilter>>;
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  options?: Maybe<QueryOptions>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<StringSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};

/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRoots = {
  __typename?: 'RippleAccountRoots';
  /** The identifying (classic) address of this account. */
  account?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  /** The account`s current XRP balance in drops, represented as a string. */
  balance?: Maybe<Scalars['BigInt']>;
  /** Number of block in the blockchains */
  blockHeight?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** domain associated with this account. In JSON, this is the hexadecimal for the ASCII representation of the domain */
  domain?: Maybe<Scalars['String']>;
  /** 	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */
  flags?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** The number of objects this account owns in the ledger, which contributes to its owner reserve. */
  ownerCount?: Maybe<Scalars['Int']>;
  /** Previous Balance */
  prevBalance?: Maybe<Scalars['BigInt']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnId?: Maybe<Scalars['String']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;
  /** The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.) */
  sequence?: Maybe<Scalars['BigInt']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Type of transaction */
  transactionType?: Maybe<Scalars['String']>;
  /** A transfer fee  to charge other users for sending currency issued by this account to each other. */
  transferRate?: Maybe<Scalars['BigInt']>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsAccountArgs = {
  account?: Maybe<HashSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsAnyArgs = {
  of: RippleccountRootsMeasureable;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsBalanceArgs = {
  balance?: Maybe<IntegerSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsBlockHeightArgs = {
  blockHeight?: Maybe<BlockSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsCountArgs = {
  uniq?: Maybe<RippleAccountRootsUniq>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsCountBigIntArgs = {
  uniq?: Maybe<RippleAccountRootsUniq>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsDomainArgs = {
  domain?: Maybe<StringSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsFlagsArgs = {
  flags?: Maybe<IntegerSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsMaximumArgs = {
  get?: Maybe<RippleccountRootsMeasureable>;
  of: RippleccountRootsMeasureable;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsMinimumArgs = {
  get?: Maybe<RippleccountRootsMeasureable>;
  of: RippleccountRootsMeasureable;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsOperationArgs = {
  operation?: Maybe<HashSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsOwnerCountArgs = {
  ownerCount?: Maybe<IntegerSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsPrevBalanceArgs = {
  prevBalance?: Maybe<IntegerSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsPreviousTxnIdArgs = {
  previousTxnId?: Maybe<HashSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsPreviousTxnLedgerSeqArgs = {
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsSequenceArgs = {
  sequence?: Maybe<IntegerSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsTransactionTypeArgs = {
  transactionType?: Maybe<TypeSelector>;
};


/** The AccountRoot object type describes a single account, its settings, and XRP balance. */
export type RippleAccountRootsTransferRateArgs = {
  transferRate?: Maybe<IntegerSelector>;
};

export type RippleAccountRootsFilter = {
  account?: Maybe<HashSelector>;
  balance?: Maybe<IntegerSelector>;
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  domain?: Maybe<StringSelector>;
  flags?: Maybe<IntegerSelector>;
  operation?: Maybe<HashSelector>;
  ownerCount?: Maybe<IntegerSelector>;
  prevBalance?: Maybe<IntegerSelector>;
  previousTxnId?: Maybe<HashSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sequence?: Maybe<IntegerSelector>;
  transactionType?: Maybe<TypeSelector>;
  transferRate?: Maybe<IntegerSelector>;
};

export enum RippleAccountRootsUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

/** Balances in Ripple blockchain */
export type RippleBalances = {
  __typename?: 'RippleBalances';
  /** Account */
  account?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['Float']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Previous Ledge Seq */
  flags?: Maybe<Scalars['BigInt']>;
  /** Issuer */
  issuer?: Maybe<Scalars['String']>;
  /** Block number */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Previous Balance */
  prevBalance?: Maybe<Scalars['Float']>;
  /** Previous Ledger Seq */
  prevLedgerSeq?: Maybe<Scalars['BigInt']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transaction Sender */
  transactionSender?: Maybe<Scalars['String']>;
  /** Transaction type */
  transactionType?: Maybe<Scalars['String']>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesAccountArgs = {
  account?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesAnyArgs = {
  of: RippleBalancesMeasureable;
};


/** Balances in Ripple blockchain */
export type RippleBalancesBalanceArgs = {
  account?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  flags?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  issuer?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  prevBalance?: Maybe<HashSelector>;
  prevLedgerSeq?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionSender?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesCountArgs = {
  uniq?: Maybe<RippleBalancesUniq>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesCountBigIntArgs = {
  uniq?: Maybe<RippleBalancesUniq>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesFlagsArgs = {
  flags?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesIssuerArgs = {
  issuer?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesMaximumArgs = {
  get?: Maybe<RippleBalancesMeasureable>;
  of: RippleBalancesMeasureable;
};


/** Balances in Ripple blockchain */
export type RippleBalancesMinimumArgs = {
  get?: Maybe<RippleBalancesMeasureable>;
  of: RippleBalancesMeasureable;
};


/** Balances in Ripple blockchain */
export type RippleBalancesPrevBalanceArgs = {
  prevBalance?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesPrevLedgerSeqArgs = {
  prevLedgerSeq?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesTransactionSenderArgs = {
  transactionSender?: Maybe<HashSelector>;
};


/** Balances in Ripple blockchain */
export type RippleBalancesTransactionTypeArgs = {
  transactionType?: Maybe<TransactionTypeSelector>;
};

export type RippleBalancesFilter = {
  account?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  flags?: Maybe<HashSelector>;
  issuer?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  prevBalance?: Maybe<HashSelector>;
  prevLedgerSeq?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionSender?: Maybe<HashSelector>;
};

export enum RippleBalancesMeasureable {
  /** Account */
  Account = 'account',
  /** Balance */
  Balance = 'balance',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Transaction Sender */
  TransactionSender = 'transaction_sender'
}

export enum RippleBalancesUniq {
  /** Unique account count */
  Account = 'account',
  /** Unique date count */
  Dates = 'dates',
  /** Unique issuer count */
  Issuer = 'issuer',
  /** Unique ledger count */
  Ledger = 'ledger',
  /** Unique time */
  Times = 'times',
  /** Unique transaction hash count */
  TransactionHash = 'transactionHash',
  /** Unique transaction sender count */
  TransactionSender = 'transactionSender'
}

/** Blocks in Ripple blockchain */
export type RippleBlocks = {
  __typename?: 'RippleBlocks';
  /** Hash of this ledger`s state tree information. */
  accountHash?: Maybe<Scalars['String']>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Block number */
  ledger?: Maybe<Scalars['BigInt']>;
  /** This serves as a unique identifier for this ledger and all its contents. */
  ledgerHash?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** The total number of drops of XRP owned by accounts in the ledger. */
  totalCoins?: Maybe<Scalars['BigInt']>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksAccountHashArgs = {
  accountHash?: Maybe<HashSelector>;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksAnyArgs = {
  of: RippleBlocksMeasureable;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksCountArgs = {
  uniq?: Maybe<RippleBlocksUniq>;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksCountBigIntArgs = {
  uniq?: Maybe<RippleBlocksUniq>;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksLedgerHashArgs = {
  ledgerHash?: Maybe<HashSelector>;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksMaximumArgs = {
  get?: Maybe<RippleBlocksMeasureable>;
  of: RippleBlocksMeasureable;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksMinimumArgs = {
  get?: Maybe<RippleBlocksMeasureable>;
  of: RippleBlocksMeasureable;
};


/** Blocks in Ripple blockchain */
export type RippleBlocksTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};

export type RippleBlocksFilter = {
  accountHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  ledgerHash?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
};

export enum RippleBlocksMeasureable {
  /** Hash of this ledger`s state tree information */
  AccountHash = 'account_hash',
  /** Date */
  Date = 'date',
  /** Block number */
  Ledger = 'ledger',
  /** This serves as a unique identifier for this ledger and all its contents */
  LedgerHash = 'ledger_hash',
  /** Time */
  Time = 'time',
  /** The total number of drops of XRP owned by accounts in the ledger */
  TotalCoins = 'total_coins'
}

export enum RippleBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique blocks */
  Ledger = 'ledger',
  /** Unique time */
  Times = 'times'
}

/** Checks in Ripple blockchain */
export type RippleChecks = {
  __typename?: 'RippleChecks';
  any?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  blockHeight?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** The destination address where the XRP is paid if the held payment is successful. */
  destination?: Maybe<Scalars['String']>;
  /** An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address. */
  destinationTag?: Maybe<Scalars['BigInt']>;
  /** Indicates the time after which this Check is considered expired. */
  expiration?: Maybe<Scalars['BigInt']>;
  /** A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */
  flags?: Maybe<Scalars['BigInt']>;
  /** The time after which this held payment can be finished */
  invoiceId?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnId?: Maybe<Scalars['String']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;
  /** The maximum amount of currency this Check can debit the sender.  */
  sendMax?: Maybe<Scalars['BigInt']>;
  /** The sender of the Check. Cashing the Check debits this address`s balance. */
  sender?: Maybe<Scalars['String']>;
  /** The sequence number of the CheckCreate transaction that created this check. */
  sequence?: Maybe<Scalars['BigInt']>;
  /** An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address. */
  sourceTag?: Maybe<Scalars['BigInt']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Type of transaction */
  transactionType?: Maybe<Scalars['String']>;
};


/** Checks in Ripple blockchain */
export type RippleChecksAnyArgs = {
  of: RippleChecksMeasureable;
};


/** Checks in Ripple blockchain */
export type RippleChecksBlockHeightArgs = {
  blockHeight?: Maybe<BlockSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksCountArgs = {
  uniq?: Maybe<RippleChecksUniq>;
};


/** Checks in Ripple blockchain */
export type RippleChecksCountBigIntArgs = {
  uniq?: Maybe<RippleChecksUniq>;
};


/** Checks in Ripple blockchain */
export type RippleChecksDestinationArgs = {
  destination?: Maybe<HashSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksDestinationTagArgs = {
  destinationTag?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksExpirationArgs = {
  expiration?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksFlagsArgs = {
  flags?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksInvoiceIdArgs = {
  invoiceId?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksMaximumArgs = {
  get?: Maybe<RippleChecksMeasureable>;
  of: RippleChecksMeasureable;
};


/** Checks in Ripple blockchain */
export type RippleChecksMinimumArgs = {
  get?: Maybe<RippleChecksMeasureable>;
  of: RippleChecksMeasureable;
};


/** Checks in Ripple blockchain */
export type RippleChecksOperationArgs = {
  operation?: Maybe<StringSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksPreviousTxnIdArgs = {
  previousTxnId?: Maybe<HashSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksPreviousTxnLedgerSeqArgs = {
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksSendMaxArgs = {
  sendMax?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksSequenceArgs = {
  sequence?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksSourceTagArgs = {
  sourceTag?: Maybe<IntegerSelector>;
};


/** Checks in Ripple blockchain */
export type RippleChecksTransactionTypeArgs = {
  transactionType?: Maybe<TypeSelector>;
};

export type RippleChecksFilter = {
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  destination?: Maybe<HashSelector>;
  destinationTag?: Maybe<IntegerSelector>;
  expiration?: Maybe<IntegerSelector>;
  flags?: Maybe<IntegerSelector>;
  invoiceId?: Maybe<IntegerSelector>;
  operation?: Maybe<StringSelector>;
  previousTxnId?: Maybe<IntegerSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sendMax?: Maybe<IntegerSelector>;
  sender?: Maybe<HashSelector>;
  sequence?: Maybe<IntegerSelector>;
  sourceTag?: Maybe<IntegerSelector>;
  transactionType?: Maybe<HashSelector>;
};

export enum RippleChecksMeasureable {
  /** Number of block in the blockhains */
  BlockHeight = 'block_height',
  /** Currency Address */
  CurrencyAddress = 'currency_address',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** The sender of the Check. Cashing the Check debits this address`s balance. */
  Sender = 'sender',
  /** Time */
  Time = 'time'
}

export enum RippleChecksUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique destination */
  Destination = 'destination',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

/** Escrows in Ripple blockchain */
export type RippleEscrows = {
  __typename?: 'RippleEscrows';
  /** The amount of XRP, in drops, to be delivered by the held payment. */
  amount?: Maybe<Scalars['BigInt']>;
  any?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  blockHeight?: Maybe<Scalars['BigInt']>;
  /** The held payment can be canceled if and only if this field is present and the time it specifies has passed */
  cancelAfter?: Maybe<Scalars['BigInt']>;
  /** Crypto condition as hexadecimal. If present, the EscrowFinish transaction must contain a fulfillment that satisfies this condition. */
  condition?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** The destination address where the XRP is paid if the held payment is successful. */
  destination?: Maybe<Scalars['String']>;
  /** An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address. */
  destinationTag?: Maybe<Scalars['BigInt']>;
  /** The time after which this held payment can be finished */
  finishedAfter?: Maybe<Scalars['BigInt']>;
  /** 	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */
  flags?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnId?: Maybe<Scalars['String']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;
  /** The address of the owner (sender) of this held payment */
  sender?: Maybe<Scalars['String']>;
  /** An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner`s address. */
  sourceTag?: Maybe<Scalars['BigInt']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Type of transaction */
  transactionType?: Maybe<Scalars['String']>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsAmountArgs = {
  amount?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsAnyArgs = {
  of: RippleEscrowsMeasureable;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsBlockHeightArgs = {
  blockHeight?: Maybe<BlockSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsCancelAfterArgs = {
  cancelAfter?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsConditionArgs = {
  condition?: Maybe<HashSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsCountArgs = {
  uniq?: Maybe<RippleEscrowsUniq>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsCountBigIntArgs = {
  uniq?: Maybe<RippleEscrowsUniq>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsDestinationArgs = {
  destination?: Maybe<HashSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsDestinationTagArgs = {
  destinationTag?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsFinishedAfterArgs = {
  finishedAfter?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsFlagsArgs = {
  flags?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsMaximumArgs = {
  get?: Maybe<RippleEscrowsMeasureable>;
  of: RippleEscrowsMeasureable;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsMinimumArgs = {
  get?: Maybe<RippleEscrowsMeasureable>;
  of: RippleEscrowsMeasureable;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsOperationArgs = {
  operation?: Maybe<HashSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsPreviousTxnIdArgs = {
  previousTxnId?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsPreviousTxnLedgerSeqArgs = {
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsSourceTagArgs = {
  sourceTag?: Maybe<IntegerSelector>;
};


/** Escrows in Ripple blockchain */
export type RippleEscrowsTransactionTypeArgs = {
  transactionType?: Maybe<TypeSelector>;
};

export type RippleEscrowsFilter = {
  amount?: Maybe<IntegerSelector>;
  blockHeight?: Maybe<BlockSelector>;
  cancelAfter?: Maybe<IntegerSelector>;
  condition?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  destination?: Maybe<HashSelector>;
  destinationTag?: Maybe<IntegerSelector>;
  finishedAfter?: Maybe<IntegerSelector>;
  flags?: Maybe<IntegerSelector>;
  operation?: Maybe<HashSelector>;
  previousTxnId?: Maybe<IntegerSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sender?: Maybe<HashSelector>;
  sourceTag?: Maybe<IntegerSelector>;
  transactionType?: Maybe<TypeSelector>;
};

export enum RippleEscrowsMeasureable {
  /** Number of block in the blockhains */
  BlockHeight = 'block_height',
  /** Currency Address */
  CurrencyAddress = 'currency_address',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** The address of the owner (sender) of this held payment */
  Sender = 'sender',
  /** Time */
  Time = 'time'
}

export enum RippleEscrowsUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique date count */
  Dates = 'dates',
  /** Unique destination */
  Destination = 'destination',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

export enum RippleNetwork {
  /** Ripple XRP Ledger */
  Ripple = 'ripple'
}

/** Offers in Ripple blockchain */
export type RippleOffers = {
  __typename?: 'RippleOffers';
  any?: Maybe<Scalars['String']>;
  /** Book Directory */
  bookDirectory?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Expiration */
  expiration?: Maybe<Scalars['BigInt']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** Block number */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Sequence */
  sequence?: Maybe<Scalars['Float']>;
  takerGets?: Maybe<Scalars['BigInt']>;
  /** Taker Gets Currency */
  takerGetsCurrency?: Maybe<Currency>;
  takerPays?: Maybe<Scalars['BigInt']>;
  /** Taker Pays Currency */
  takerPaysCurrency?: Maybe<Currency>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transaction Sender */
  transactionSender?: Maybe<Scalars['String']>;
  /** Transaction type */
  transactionType?: Maybe<Scalars['String']>;
};


/** Offers in Ripple blockchain */
export type RippleOffersAnyArgs = {
  of: RippleOffersMeasureable;
};


/** Offers in Ripple blockchain */
export type RippleOffersBookDirectoryArgs = {
  bookDirectory?: Maybe<HashSelector>;
};


/** Offers in Ripple blockchain */
export type RippleOffersCountArgs = {
  uniq?: Maybe<RippleOffersUniq>;
};


/** Offers in Ripple blockchain */
export type RippleOffersCountBigIntArgs = {
  uniq?: Maybe<RippleOffersUniq>;
};


/** Offers in Ripple blockchain */
export type RippleOffersLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Offers in Ripple blockchain */
export type RippleOffersMaximumArgs = {
  get?: Maybe<RippleOffersMeasureable>;
  of: RippleOffersMeasureable;
};


/** Offers in Ripple blockchain */
export type RippleOffersMinimumArgs = {
  get?: Maybe<RippleOffersMeasureable>;
  of: RippleOffersMeasureable;
};


/** Offers in Ripple blockchain */
export type RippleOffersSequenceArgs = {
  sequence?: Maybe<HashSelector>;
};


/** Offers in Ripple blockchain */
export type RippleOffersTakerGetsArgs = {
  account?: Maybe<HashSelector>;
  bookDirectory?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  ledger?: Maybe<BlockSelector>;
  sequence?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionSender?: Maybe<HashSelector>;
  transactionType?: Maybe<HashSelector>;
};


/** Offers in Ripple blockchain */
export type RippleOffersTakerPaysArgs = {
  account?: Maybe<HashSelector>;
  bookDirectory?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  ledger?: Maybe<BlockSelector>;
  sequence?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionSender?: Maybe<HashSelector>;
  transactionType?: Maybe<HashSelector>;
};


/** Offers in Ripple blockchain */
export type RippleOffersTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Offers in Ripple blockchain */
export type RippleOffersTransactionSenderArgs = {
  transactionSender?: Maybe<HashSelector>;
};


/** Offers in Ripple blockchain */
export type RippleOffersTransactionTypeArgs = {
  transactionType?: Maybe<TransactionTypeSelector>;
};

export type RippleOffersFilter = {
  account?: Maybe<HashSelector>;
  bookDirectory?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  ledger?: Maybe<BlockSelector>;
  sequence?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionSender?: Maybe<HashSelector>;
  transactionType?: Maybe<HashSelector>;
};

export enum RippleOffersMeasureable {
  /** Date */
  Date = 'date',
  /** Taker Gets Currency Address */
  TakerGetsCurrencyAddress = 'taker_gets_currency_address',
  /** Taker Gets Currency Symbol */
  TakerGetsCurrencySymbol = 'taker_gets_currency_symbol',
  /** Taker Pays Currency Address */
  TakerPaysCurrencyAddress = 'taker_pays_currency_address',
  /** Taker Pays Currency Symbol */
  TakerPaysCurrencySymbol = 'taker_pays_currency_symbol',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Transaction Sender */
  TransactionSender = 'transaction_sender',
  /** Transaction Type */
  TransactionType = 'transaction_type'
}

export enum RippleOffersUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique time */
  Times = 'times',
  /** Uniq transaction hash */
  TransactionHash = 'transaction_hash',
  /** Uniq transaction sender */
  TransactionSender = 'transaction_sender'
}

/** Payments in Ripple blockchain */
export type RipplePayments = {
  __typename?: 'RipplePayments';
  /** Amount Currency */
  amountCurrency?: Maybe<Currency>;
  /** Amount Issuer */
  amountIssuer?: Maybe<Scalars['String']>;
  amountValue?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Delivered min currency */
  deliverMinCurrency?: Maybe<Currency>;
  /** Delivered Min Issuer */
  deliverMinIssuer?: Maybe<Scalars['String']>;
  deliverMinValue?: Maybe<Scalars['Float']>;
  /** Currency of the money sender's transfer */
  deliveredCurrency?: Maybe<Currency>;
  /** Delivered Value */
  deliveredIssuer?: Maybe<Scalars['String']>;
  deliveredValue?: Maybe<Scalars['Float']>;
  /** Flags */
  flags?: Maybe<Scalars['BigInt']>;
  /** Invoice */
  invoice?: Maybe<Scalars['String']>;
  /** Block number */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Partial */
  partial?: Maybe<Scalars['BigInt']>;
  /** Currency of the money sender's transfer */
  sendMaxCurrency?: Maybe<Currency>;
  /** Send Max Issuer */
  sendMaxIssuer?: Maybe<Scalars['String']>;
  sendMaxValue?: Maybe<Scalars['Float']>;
  /** Tag */
  tag?: Maybe<Scalars['BigInt']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transfer from */
  transferFrom?: Maybe<Scalars['String']>;
  /** Transfer to */
  transferTo?: Maybe<Scalars['String']>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsAmountIssuerArgs = {
  amountIssuer?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsAmountValueArgs = {
  amountIssuer?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  deliverIssuer?: Maybe<HashSelector>;
  deliverMinIssuer?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  ledger?: Maybe<BlockSelector>;
  sendMaxIssuer?: Maybe<HashSelector>;
  tag?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsAnyArgs = {
  of: RipplePaymentsMeasureable;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsCountArgs = {
  uniq?: Maybe<RipplePaymentsUniq>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsCountBigIntArgs = {
  uniq?: Maybe<RipplePaymentsUniq>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsDeliverMinIssuerArgs = {
  deliverMinIssuer?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsDeliverMinValueArgs = {
  amountIssuer?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  deliverIssuer?: Maybe<HashSelector>;
  deliverMinIssuer?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  ledger?: Maybe<BlockSelector>;
  sendMaxIssuer?: Maybe<HashSelector>;
  tag?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsDeliveredIssuerArgs = {
  deliveredIssuer?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsDeliveredValueArgs = {
  amountIssuer?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  deliverIssuer?: Maybe<HashSelector>;
  deliverMinIssuer?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  ledger?: Maybe<BlockSelector>;
  sendMaxIssuer?: Maybe<HashSelector>;
  tag?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsMaximumArgs = {
  get?: Maybe<RipplePaymentsMeasureable>;
  of: RipplePaymentsMeasureable;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsMinimumArgs = {
  get?: Maybe<RipplePaymentsMeasureable>;
  of: RipplePaymentsMeasureable;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsSendMaxIssuerArgs = {
  sendMaxIssuer?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsSendMaxValueArgs = {
  amountIssuer?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  deliverIssuer?: Maybe<HashSelector>;
  deliverMinIssuer?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  ledger?: Maybe<BlockSelector>;
  sendMaxIssuer?: Maybe<HashSelector>;
  tag?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsTagArgs = {
  tag?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsTransferFromArgs = {
  transferFrom?: Maybe<HashSelector>;
};


/** Payments in Ripple blockchain */
export type RipplePaymentsTransferToArgs = {
  transferTo?: Maybe<HashSelector>;
};

export type RipplePaymentsFilter = {
  amountIssuer?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  deliverIssuer?: Maybe<HashSelector>;
  deliverMinIssuer?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  sendMaxIssuer?: Maybe<HashSelector>;
  tag?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};

export enum RipplePaymentsMeasureable {
  /** Amount Currency Address */
  AmountCurrencyAddress = 'amount_currency_address',
  /** Amount Currency Symbol */
  AmountCurrencySymbol = 'amount_currency_symbol',
  /** Amount Value */
  AmountValue = 'amount_value',
  /** Date */
  Date = 'date',
  /** Delivered Min Currency Address */
  DeliverMinCurrencyAddress = 'deliver_min_currency_address',
  /** Delivered Min Currency Symbol */
  DeliverMinCurrencySymbol = 'deliver_min_currency_symbol',
  /** Delivered Currency Address */
  DeliveredCurrencyAddress = 'delivered_currency_address',
  /** Delivered Currency Symbol */
  DeliveredCurrencySymbol = 'delivered_currency_symbol',
  /** Send max Currency Address */
  SendMaxCurrencyAddress = 'send_max_currency_address',
  /** Send max Currency Symbol */
  SendMaxCurrencySymbol = 'send_max_currency_symbol',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash',
  /** Transfer From */
  TransferFrom = 'transfer_from',
  /** Transfer To */
  TransferTo = 'transfer_to'
}

export enum RipplePaymentsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique blocks */
  Ledger = 'ledger',
  /** Unique time */
  Times = 'times',
  /** Unique transfer from */
  TransferFrom = 'transfer_from',
  /** Unique transfer to */
  TransferTo = 'transfer_to'
}

/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStates = {
  __typename?: 'RippleRippleStates';
  any?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['Float']>;
  /** Number of block in the blockchains */
  blockHeight?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** 	A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0. */
  flags?: Maybe<Scalars['String']>;
  /** High Account */
  highAccount?: Maybe<Scalars['String']>;
  /** Low Account */
  lowAccount?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** Previous Balance */
  preBalance?: Maybe<Scalars['BigInt']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnId?: Maybe<Scalars['String']>;
  /** The identifying hash of the transaction that most recently modified this object. */
  previousTxnLedgerSeq?: Maybe<Scalars['BigInt']>;
  /** The address of the owner (sender) of this held payment */
  sender?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Type of transaction */
  transactionType?: Maybe<Scalars['String']>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesAnyArgs = {
  of: RippleRippleStatesMeasureable;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesBalanceArgs = {
  balance?: Maybe<IntegerSelector>;
  blockHeight?: Maybe<BlockSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  flags?: Maybe<IntegerSelector>;
  highAccount?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  lowAccount?: Maybe<HashSelector>;
  operation?: Maybe<StringSelector>;
  preBalance?: Maybe<IntegerSelector>;
  previousTxnId?: Maybe<IntegerSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sender?: Maybe<HashSelector>;
  transactionType?: Maybe<HashSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesBlockHeightArgs = {
  blockHeight?: Maybe<BlockSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesCountArgs = {
  uniq?: Maybe<RippleRippleStatesUniq>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesCountBigIntArgs = {
  uniq?: Maybe<RippleRippleStatesUniq>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesFlagsArgs = {
  flags?: Maybe<IntegerSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesHighAccountArgs = {
  highAccount?: Maybe<HashSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesLowAccountArgs = {
  lowAccount?: Maybe<HashSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesMaximumArgs = {
  get?: Maybe<RippleRippleStatesMeasureable>;
  of: RippleRippleStatesMeasureable;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesMinimumArgs = {
  get?: Maybe<RippleRippleStatesMeasureable>;
  of: RippleRippleStatesMeasureable;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesOperationArgs = {
  operation?: Maybe<StringSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesPreBalanceArgs = {
  preBalance?: Maybe<HashSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesPreviousTxnIdArgs = {
  previousTxnId?: Maybe<IntegerSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesPreviousTxnLedgerSeqArgs = {
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** The RippleState object type connects two accounts in a single currency */
export type RippleRippleStatesTransactionTypeArgs = {
  transactionType?: Maybe<TypeSelector>;
};

export enum RippleRippleStatesMeasureable {
  /** Number of block in the blockhains */
  BlockHeight = 'block_height',
  /** Currency Address */
  CurrencyAddress = 'currency_address',
  /** Currency Symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** High Account */
  HighAccount = 'high_account',
  /** Low Account */
  LowAccount = 'low_account',
  /** The address of the owner (sender) of this held payment */
  Sender = 'sender',
  /** Time */
  Time = 'time'
}

export enum RippleRippleStatesUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique High Account */
  HighAccount = 'high_account',
  /** Unique Lower Account */
  LowerAccount = 'lower_account',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

export type RippleStatesFilter = {
  balance?: Maybe<IntegerSelector>;
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  flags?: Maybe<IntegerSelector>;
  highAccount?: Maybe<HashSelector>;
  lowAccount?: Maybe<HashSelector>;
  operation?: Maybe<StringSelector>;
  preBalance?: Maybe<IntegerSelector>;
  previousTxnId?: Maybe<IntegerSelector>;
  previousTxnLedgerSeq?: Maybe<IntegerSelector>;
  sender?: Maybe<HashSelector>;
  transactionType?: Maybe<HashSelector>;
};

/** Transactions in Ripple blockchain */
export type RippleTransactions = {
  __typename?: 'RippleTransactions';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** A transactions Flags field can contain flags that apply at different levels or contexts. */
  flags?: Maybe<Scalars['BigInt']>;
  /** Index in ledger */
  indexInLedger?: Maybe<Scalars['BigInt']>;
  /** Highest ledger index this transaction can appear in. */
  lastLedgerSequence?: Maybe<Scalars['Float']>;
  /** Block number */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  /** Additional arbitrary information used to identify this transaction. */
  memos?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Result */
  result?: Maybe<Scalars['String']>;
  /** Transaction Sender */
  sender?: Maybe<Scalars['String']>;
  /** The sequence number of the account sending the transaction. */
  sequence?: Maybe<Scalars['Float']>;
  /** Successful of not */
  status?: Maybe<Scalars['Boolean']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction fee */
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction hash */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transaction type */
  transactionType?: Maybe<Scalars['String']>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsAnyArgs = {
  of: RippleTransactionsMeasureable;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsCountArgs = {
  uniq?: Maybe<RippleTransactionsUniq>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsCountBigIntArgs = {
  uniq?: Maybe<RippleTransactionsUniq>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsLastLedgerSequenceArgs = {
  lastLedgerSequence?: Maybe<HashSelector>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsLedgerArgs = {
  ledger?: Maybe<BlockSelector>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsMaximumArgs = {
  get?: Maybe<RippleTransactionsMeasureable>;
  of: RippleTransactionsMeasureable;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsMinimumArgs = {
  get?: Maybe<RippleTransactionsMeasureable>;
  of: RippleTransactionsMeasureable;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsResultArgs = {
  result?: Maybe<HashSelector>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsSequenceArgs = {
  sequence?: Maybe<HashSelector>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsStatusArgs = {
  status?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsTransactionFeeArgs = {
  transactionFee?: Maybe<HashSelector>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Transactions in Ripple blockchain */
export type RippleTransactionsTransactionTypeArgs = {
  transactionType?: Maybe<TransactionTypeSelector>;
};

export type RippleTransactionsFilter = {
  date?: Maybe<DateSelector>;
  lastLedgerSequence?: Maybe<HashSelector>;
  ledger?: Maybe<BlockSelector>;
  result?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  sequence?: Maybe<HashSelector>;
  status?: Maybe<Scalars['Boolean']>;
  transactionFee?: Maybe<TransactionTypeSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<TransactionTypeSelector>;
};

export enum RippleTransactionsMeasureable {
  /** Date */
  Date = 'date',
  /** Transaction sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction Fee */
  TransactionFee = 'transaction_fee',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash'
}

export enum RippleTransactionsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique ledger count */
  Ledger = 'ledger',
  /** Unique sender count */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

/** Transfers in Ripple blockchain */
export type RippleTransfers = {
  __typename?: 'RippleTransfers';
  any?: Maybe<Scalars['String']>;
  /** Number of block in the blockchains */
  blockHeight?: Maybe<Scalars['BigInt']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of the money sender's transfer */
  currencyFrom?: Maybe<Currency>;
  /** Currency of the money receiver's transfer */
  currencyTo?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The sender of the Check. Cashing the Check debits this address`s balance. */
  sender?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Transaction Hash */
  transactionHash?: Maybe<Scalars['String']>;
  /** Transfer From */
  transferFrom?: Maybe<Scalars['String']>;
  /** Transfer To */
  transferTo?: Maybe<Scalars['String']>;
  valueFrom?: Maybe<Scalars['Float']>;
  valueTo?: Maybe<Scalars['Float']>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersAnyArgs = {
  of: RippleTransfersMeasureable;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersBlockHeightArgs = {
  blockHeight?: Maybe<BlockSelector>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersCountArgs = {
  uniq?: Maybe<RippleTransfersUniq>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersCountBigIntArgs = {
  uniq?: Maybe<RippleTransfersUniq>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersMaximumArgs = {
  get?: Maybe<RippleTransfersMeasureable>;
  of: RippleTransfersMeasureable;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersMinimumArgs = {
  get?: Maybe<RippleTransfersMeasureable>;
  of: RippleTransfersMeasureable;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersTransferFromArgs = {
  transferFrom?: Maybe<HashSelector>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersTransferToArgs = {
  transferTo?: Maybe<HashSelector>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersValueFromArgs = {
  blockHeight?: Maybe<BlockSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<StringSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};


/** Transfers in Ripple blockchain */
export type RippleTransfersValueToArgs = {
  blockHeight?: Maybe<BlockSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<StringSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};

export type RippleTransfersFilter = {
  blockHeight?: Maybe<BlockSelector>;
  date?: Maybe<DateSelector>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
  transactionType?: Maybe<StringSelector>;
  transferFrom?: Maybe<HashSelector>;
  transferTo?: Maybe<HashSelector>;
};

export enum RippleTransfersMeasureable {
  /** Number of block in the blockhains */
  BlockHeight = 'block_height',
  /** Currency Address of the money sender`s transfer */
  CurrencyFromAddress = 'currency_from_address',
  /** Currency Symbol of the money sender`s transfer */
  CurrencyFromSymbol = 'currency_from_symbol',
  /** Currency Address of the money receiver`s trasfer */
  CurrencyToAddress = 'currency_to_address',
  /** Currency Symbol of the money receiver`s transfer */
  CurrencyToSymbol = 'currency_to_symbol',
  /** Date */
  Date = 'date',
  /** The sender of the payment */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transfer From */
  TransferFrom = 'transfer_from',
  /** Transfer To */
  TransferTo = 'transfer_to',
  /** Value From */
  ValueFrom = 'value_from',
  /** Value To */
  ValueTo = 'value_to'
}

export enum RippleTransfersUniq {
  /** Unique Number of block in the blockchains */
  BlockHeight = 'block_height',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique destination */
  Destination = 'destination',
  /** Unique sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times'
}

export enum RippleccountRootsMeasureable {
  /** The identifying (classic) address of this account. */
  Account = 'account',
  /** Number of block in the blockhains */
  BlockHeight = 'block_height',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time'
}

export enum ScriptTypeSelectorSelector {
  /** Peer-to-peer */
  PeerToPeerTransaction = 'peer_to_peer_transaction',
  /** Unknown Transaction */
  UnknownTransaction = 'unknown_transaction'
}

/** Solana Sender */
export type Sender = {
  __typename?: 'Sender';
  address: Scalars['String'];
  mintAccount: Scalars['String'];
  type: Scalars['String'];
};

/** Smart contract method or event */
export type Signature = Event | Method;

export enum SignatureTypeSelector {
  /** Smart contract event */
  Event = 'Event',
  /** Smart contract method */
  Function = 'Function'
}

/** Blockchain smart contract */
export type SmartContract = {
  __typename?: 'SmartContract';
  /** String address representation */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract Type */
  contractType: SmartContractType;
  /** Smart Contract Protocol Type */
  protocol?: Maybe<Scalars['String']>;
};

export enum SmartContractArgumentsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique callers count */
  Callers = 'callers',
  /** Calls or events */
  Calls = 'calls',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction senders */
  Senders = 'senders',
  /** Unique signatures count */
  Signatures = 'signatures',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** Unique transactions count */
  Txs = 'txs',
  /** Unique values */
  Values = 'values'
}

export enum SmartContractCallsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique callers count */
  Callers = 'callers',
  /** Calls */
  Calls = 'calls',
  /** Unique date count */
  Dates = 'dates',
  /** Unique transaction senders */
  Senders = 'senders',
  /** Unique smart contract methods count */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** Unique transactions count */
  Txs = 'txs'
}

export enum SmartContractEventsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates',
  /** Unique smart contract methods count */
  SmartContractMethods = 'smart_contract_methods',
  /** Unique smart contracts count */
  SmartContracts = 'smart_contracts',
  /** Unique transaction senders */
  TxFrom = 'tx_from',
  /** Unique callers count */
  TxTo = 'tx_to',
  /** Unique transactions count */
  Txs = 'txs'
}

export type SmartContractReadonlyAttribute = {
  __typename?: 'SmartContractReadonlyAttribute';
  /** Value as address if applicable */
  address?: Maybe<EthereumAddressInfo>;
  /** Method name */
  name: Scalars['String'];
  /** Method return type */
  type: Scalars['String'];
  /** Method return value */
  value: Scalars['String'];
};

export enum SmartContractType {
  /** Decentralized exchange */
  Dex = 'DEX',
  /** General Purpose Smart contract */
  Generic = 'Generic',
  /** Smart contract for token derivatives */
  MarginPositionToken = 'MarginPositionToken',
  /** Multi signature wallet */
  Multisig = 'Multisig',
  /** Not A Smart contract */
  None = 'None',
  /** Transaction Execution Approval Language */
  Teal = 'TEAL',
  /** Token */
  Token = 'Token',
  /** Token Sale */
  TokenSale = 'TokenSale'
}

/** Selector of smart contract type */
export type SmartContractTypeSelector = {
  /** Smart Contract type in the list */
  in?: Maybe<Array<SmartContractType>>;
  /** Smart Contract type is */
  is?: Maybe<SmartContractType>;
  /** Smart Contract type not */
  not?: Maybe<SmartContractType>;
  /** Smart Contract type not in the list */
  notIn?: Maybe<Array<SmartContractType>>;
};

/** Solana Chain */
export type Solana = {
  __typename?: 'Solana';
  /** BlockRewards of Smart Contract Calls and Events */
  blockRewards?: Maybe<Array<SolanaBlockRewards>>;
  /** Solana Blocks */
  blocks?: Maybe<Array<SolanaBlocks>>;
  /**
   * Each instruction specifies a single program, a subset of the transaction`s accounts
   * that should be passed to the program.
   */
  instructions?: Maybe<Array<SolanaInstructions>>;
  /** Solana Transactions */
  transactions?: Maybe<Array<SolanaTransactions>>;
  /** Currency transfers from/to addresses in crypto currencies */
  transfers?: Maybe<Array<SolanaTransfers>>;
};


/** Solana Chain */
export type SolanaBlockRewardsArgs = {
  any?: Maybe<Array<SolanaBlockRewardsFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  parentSlot?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  reward?: Maybe<AmountSelector>;
};


/** Solana Chain */
export type SolanaBlocksArgs = {
  any?: Maybe<Array<SolanaBlocksFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  parentSlot?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  rewards?: Maybe<AmountSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Solana Chain */
export type SolanaInstructionsArgs = {
  any?: Maybe<Array<SolanaInstructionsFilter>>;
  blockHash?: Maybe<HashSelector>;
  callPath?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  external?: Maybe<IntegerSelector>;
  externalParsedActionName?: Maybe<StringSelector>;
  externalParsedProgramName?: Maybe<StringSelector>;
  externalProgramId?: Maybe<StringSelector>;
  fee?: Maybe<IntegerSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  parsedActionName?: Maybe<StringSelector>;
  parsedProgramName?: Maybe<StringSelector>;
  parsedType?: Maybe<StringSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  programId?: Maybe<StringSelector>;
  signature?: Maybe<StringSelector>;
  success?: Maybe<BooleanSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
};


/** Solana Chain */
export type SolanaTransactionsArgs = {
  any?: Maybe<Array<SolanaTransactionsFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  fee?: Maybe<IntegerSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  parentSlot?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  recentBlockHash?: Maybe<HashSelector>;
  signature?: Maybe<HashSelector>;
  signer?: Maybe<HashSelector>;
  success?: Maybe<BooleanSelector>;
  transactionFee?: Maybe<AmountSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
};


/** Solana Chain */
export type SolanaTransfersArgs = {
  any?: Maybe<Array<SolanaTransfersFilter>>;
  blockHash?: Maybe<HashSelector>;
  callPath?: Maybe<StringSelector>;
  currency?: Maybe<Array<SolanaCurrencySelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<StringSelector>;
  externalParsedActionName?: Maybe<StringSelector>;
  externalParsedProgramName?: Maybe<StringSelector>;
  externalProgramId?: Maybe<StringSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  parsedActionName?: Maybe<StringSelector>;
  parsedProgramName?: Maybe<StringSelector>;
  parsedType?: Maybe<StringSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  programId?: Maybe<StringSelector>;
  receiverAddress?: Maybe<StringSelector>;
  receiverType?: Maybe<StringSelector>;
  recentBlockHash?: Maybe<HashSelector>;
  senderAddress?: Maybe<StringSelector>;
  senderType?: Maybe<StringSelector>;
  signature?: Maybe<HashSelector>;
  success?: Maybe<BooleanSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
  transferType?: Maybe<SolanaTransferTypeSelector>;
};

/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewards = {
  __typename?: 'SolanaBlockRewards';
  /** Account */
  account?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The slot index of this block`s parent */
  parentSlot?: Maybe<Scalars['BigInt']>;
  /** Account balances after the transaction was processed */
  postBalance?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Type of reward */
  rewardType?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsAccountArgs = {
  account?: Maybe<BlockSelector>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsAmountArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  parentSlot?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  reward?: Maybe<AmountSelector>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsAnyArgs = {
  of: SolanaBlockRewardsMeasureable;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsCountArgs = {
  uniq?: Maybe<SolanaBlockRewardsUniq>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsCountBigIntArgs = {
  uniq?: Maybe<SolanaBlockRewardsUniq>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsMaximumArgs = {
  get?: Maybe<SolanaBlockRewardsMeasureable>;
  of: SolanaBlockRewardsMeasureable;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsMinimumArgs = {
  get?: Maybe<SolanaBlockRewardsMeasureable>;
  of: SolanaBlockRewardsMeasureable;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsParentSlotArgs = {
  parentSlot?: Maybe<IntegerSelector>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsPostBalanceArgs = {
  postBalance?: Maybe<IntegerSelector>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsPreviousBlockHashArgs = {
  previousBlockHash?: Maybe<HashSelector>;
};


/** BlockRewards in Solana  blockchain */
export type SolanaBlockRewardsRewardTypeArgs = {
  rewardType?: Maybe<RewardTypeSelector>;
};

export type SolanaBlockRewardsFilter = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  parentSlot?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  reward?: Maybe<AmountSelector>;
};

export enum SolanaBlockRewardsMeasureable {
  /** Account */
  Account = 'account',
  /** Number of reward lamports credited or debited by the account */
  Amount = 'amount',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The slot index of this block`s parent */
  ParentSlot = 'parent_slot',
  /** Account balances after the transaction was processed */
  PostBalance = 'post_balance',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Time */
  Time = 'time'
}

export enum SolanaBlockRewardsUniq {
  /** Unique accounts */
  Account = 'account',
  /** Unique hash of the the block */
  BlockHash = 'block_hash',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique time */
  Times = 'times'
}

/** Blocks in Solana  blockchain */
export type SolanaBlocks = {
  __typename?: 'SolanaBlocks';
  any?: Maybe<Scalars['String']>;
  /** Hash of the the block */
  blockHash?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Number of block in the blockchains */
  height?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The slot index of this block`s parent */
  parentSlot?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  rewards?: Maybe<Scalars['Float']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Count of transactions in this block */
  transactionCount?: Maybe<Scalars['Int']>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksAnyArgs = {
  of: SolanaBlocksMeasureable;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksBlockHashArgs = {
  blockHash?: Maybe<HashSelector>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksCountArgs = {
  uniq?: Maybe<SolanaBlocksUniq>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksCountBigIntArgs = {
  uniq?: Maybe<SolanaBlocksUniq>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksMaximumArgs = {
  get?: Maybe<SolanaBlocksMeasureable>;
  of: SolanaBlocksMeasureable;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksMinimumArgs = {
  get?: Maybe<SolanaBlocksMeasureable>;
  of: SolanaBlocksMeasureable;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksParentSlotArgs = {
  parentSlot?: Maybe<IntegerSelector>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksPreviousBlockHashArgs = {
  previousBlockHash?: Maybe<HashSelector>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksRewardsArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  parentSlot?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  rewards?: Maybe<AmountSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};


/** Blocks in Solana  blockchain */
export type SolanaBlocksTransactionCountArgs = {
  transactionCount?: Maybe<IntegerSelector>;
};

export type SolanaBlocksFilter = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  parentSlot?: Maybe<IntegerSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  rewards?: Maybe<AmountSelector>;
  transactionCount?: Maybe<IntegerSelector>;
};

export enum SolanaBlocksMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The slot index of this block`s parent */
  ParentSlot = 'parent_slot',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Number of reward lamports credited or debited by the account */
  Rewards = 'rewards',
  /** Time */
  Time = 'time',
  /** Count of transactions in this block */
  TransactionCount = 'transaction_count'
}

export enum SolanaBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique Number of block in the blockchains */
  Height = 'height',
  /** Unique time */
  Times = 'times'
}

/** Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol */
export type SolanaCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Instructions in Solana  blockchain */
export type SolanaInstructions = {
  __typename?: 'SolanaInstructions';
  /** Accounts count */
  accountsCount?: Maybe<Scalars['Int']>;
  /** Action */
  action?: Maybe<Action>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BlockExtended>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** External */
  external?: Maybe<Scalars['BigInt']>;
  /** External Action */
  externalAction?: Maybe<ExternalAction>;
  /** External Program */
  externalProgram?: Maybe<Program>;
  /** Fee Payer */
  feePayer?: Maybe<Scalars['String']>;
  /** Parsed Action Name */
  log?: Maybe<Log>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Program */
  program?: Maybe<Program>;
  /** Transaction Hash */
  signature?: Maybe<Scalars['String']>;
  /** Successed or failed */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction Index */
  transactionIndex?: Maybe<Scalars['BigInt']>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsActionArgs = {
  parsedActionName?: Maybe<StringSelector>;
  parsedType?: Maybe<StringSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsAnyArgs = {
  of: SolanaInstructionsMeasureable;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsBlockArgs = {
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsCallPathArgs = {
  callPath?: Maybe<StringSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsCountArgs = {
  uniq?: Maybe<SolanaInstructionsUniq>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsCountBigIntArgs = {
  uniq?: Maybe<SolanaInstructionsUniq>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsExternalArgs = {
  external?: Maybe<IntegerSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsExternalActionArgs = {
  externalParsedActionName?: Maybe<StringSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsExternalProgramArgs = {
  externalParsedProgramName?: Maybe<StringSelector>;
  externalProgramId?: Maybe<StringSelector>;
  externalProgramName?: Maybe<StringSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsFeePayerArgs = {
  feePayer?: Maybe<HashSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsMaximumArgs = {
  get?: Maybe<SolanaInstructionsMeasureable>;
  of: SolanaInstructionsMeasureable;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsMinimumArgs = {
  get?: Maybe<SolanaInstructionsMeasureable>;
  of: SolanaInstructionsMeasureable;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsPreviousBlockHashArgs = {
  previousBlockHash?: Maybe<HashSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsProgramArgs = {
  parsedProgramName?: Maybe<StringSelector>;
  programId?: Maybe<StringSelector>;
  programName?: Maybe<StringSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsSignatureArgs = {
  signature?: Maybe<HashSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsSuccessArgs = {
  success?: Maybe<BooleanSelector>;
};


/** Instructions in Solana  blockchain */
export type SolanaInstructionsTransactionIndexArgs = {
  transactionIndex?: Maybe<IntegerSelector>;
};

export type SolanaInstructionsFilter = {
  blockHash?: Maybe<HashSelector>;
  callPath?: Maybe<StringSelector>;
  date?: Maybe<DateSelector>;
  external?: Maybe<IntegerSelector>;
  externalParsedActionName?: Maybe<StringSelector>;
  externalParsedProgramName?: Maybe<StringSelector>;
  externalProgramId?: Maybe<StringSelector>;
  fee?: Maybe<IntegerSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  parsedActionName?: Maybe<StringSelector>;
  parsedProgramName?: Maybe<StringSelector>;
  parsedType?: Maybe<StringSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  programId?: Maybe<StringSelector>;
  signature?: Maybe<StringSelector>;
  success?: Maybe<BooleanSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
};

export enum SolanaInstructionsMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Transaction Fee */
  Fee = 'fee',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Transaction Hash */
  Signature = 'signature',
  /** Time */
  Time = 'time'
}

export enum SolanaInstructionsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Number of block in the blockchains */
  Height = 'height',
  /** Transaction Hash */
  Signature = 'signature',
  /** Unique time */
  Times = 'times'
}

export enum SolanaNetwork {
  /** Solana Mainnat */
  Solana = 'solana'
}

export enum SolanaRewardType {
  /** fee type */
  Fee = 'Fee',
  /** rent type */
  Rent = 'Rent',
  /** staking type */
  Staking = 'Staking',
  /** voing type */
  Voting = 'Voting'
}

/** Transactions in Solana  blockchain */
export type SolanaTransactions = {
  __typename?: 'SolanaTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BlockExtended>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Error */
  error?: Maybe<Scalars['String']>;
  /** Fee Payer */
  feePayer?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** The slot index of this block`s parent */
  parentSlot?: Maybe<Scalars['BigInt']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Recent blockhash prevents duplication and to give transactions lifetimes */
  recentBlockHash?: Maybe<Scalars['String']>;
  /** Transaction Hash */
  signature?: Maybe<Scalars['String']>;
  /** Accounts` public keys */
  signer?: Maybe<Scalars['String']>;
  /** Successed or failed */
  success?: Maybe<Scalars['Boolean']>;
  transactionFee?: Maybe<Scalars['Float']>;
  /** Transaction Index */
  transactionIndex?: Maybe<Scalars['BigInt']>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsAnyArgs = {
  of: SolanaTransactionsMeasureable;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsBlockArgs = {
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsCountArgs = {
  uniq?: Maybe<SolanaTransactionsUniq>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsCountBigIntArgs = {
  uniq?: Maybe<SolanaTransactionsUniq>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsErrorArgs = {
  error?: Maybe<StringSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsFeePayerArgs = {
  feePayer?: Maybe<HashSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsMaximumArgs = {
  get?: Maybe<SolanaTransactionsMeasureable>;
  of: SolanaTransactionsMeasureable;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsMinimumArgs = {
  get?: Maybe<SolanaTransactionsMeasureable>;
  of: SolanaTransactionsMeasureable;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsParentSlotArgs = {
  parentSlot?: Maybe<BlockSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsPreviousBlockHashArgs = {
  previousBlockHash?: Maybe<HashSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsRecentBlockHashArgs = {
  recentBlockHash?: Maybe<HashSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsSignatureArgs = {
  signature?: Maybe<StringSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsSignerArgs = {
  signer?: Maybe<HashSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsSuccessArgs = {
  success?: Maybe<BooleanSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsTransactionFeeArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  fee?: Maybe<IntegerSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  parentSlot?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  recentBlockHash?: Maybe<HashSelector>;
  signature?: Maybe<HashSelector>;
  signer?: Maybe<HashSelector>;
  success?: Maybe<BooleanSelector>;
  transactionFee?: Maybe<AmountSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
};


/** Transactions in Solana  blockchain */
export type SolanaTransactionsTransactionIndexArgs = {
  transactionIndex?: Maybe<IntegerSelector>;
};

export type SolanaTransactionsFilter = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  fee?: Maybe<IntegerSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  parentSlot?: Maybe<BlockSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  recentBlockHash?: Maybe<HashSelector>;
  signature?: Maybe<HashSelector>;
  signer?: Maybe<HashSelector>;
  success?: Maybe<BooleanSelector>;
  transactionFee?: Maybe<AmountSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
};

export enum SolanaTransactionsMeasureable {
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Transaction Fee */
  Fee = 'fee',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The slot index of this block`s parent */
  ParentSlot = 'parent_slot',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Transaction Hash */
  Signature = 'signature',
  /** Time */
  Time = 'time',
  /** Transaction Fee */
  TransactionFee = 'transaction_fee'
}

export enum SolanaTransactionsUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Number of block in the blockchains */
  Height = 'height',
  /** Transaction Hash */
  Signature = 'signature',
  /** Accounts` public key */
  Signer = 'signer',
  /** Unique time */
  Times = 'times'
}

export enum SolanaTransferType {
  /** Burn */
  Burn = 'burn',
  /** Close Account */
  CloseAccount = 'close_account',
  /** Create Account */
  CreateAccount = 'create_account',
  /** Mint */
  Mint = 'mint',
  /** Nonce Withdraw */
  NonceWithdraw = 'nonce_withdraw',
  /** Rent Exemption */
  RentExemption = 'rent_exemption',
  /** Self */
  Self = 'self',
  /** Stake */
  Stake = 'stake',
  /** Stake Withdraw */
  StakeWithdraw = 'stake_withdraw',
  /** Trade Unknown */
  TradeUnknown = 'trade_unknown',
  /** Transfer */
  Transfer = 'transfer',
  /** Vote */
  Vote = 'vote'
}

/** Select by transfer type */
export type SolanaTransferTypeSelector = {
  /** Type in the list */
  in?: Maybe<Array<SolanaTransferType>>;
  /** Type is */
  is?: Maybe<SolanaTransferType>;
  /** Type not */
  not?: Maybe<SolanaTransferType>;
  /** Type not in the list */
  notIn?: Maybe<Array<SolanaTransferType>>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfers = {
  __typename?: 'SolanaTransfers';
  /** Action */
  action?: Maybe<Action>;
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<BlockExtended>;
  /** Call Path */
  callPath?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Action */
  externalAction?: Maybe<ExternalAction>;
  /** External Parsed */
  externalParsed?: Maybe<Scalars['Int']>;
  /** Parsed Type */
  externalParsedType?: Maybe<Scalars['String']>;
  /** External Program */
  externalProgram?: Maybe<Program>;
  /** Fee Payer */
  feePayer?: Maybe<Scalars['String']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Parsed Action Name */
  parsedActionName?: Maybe<Scalars['String']>;
  /** The block hash of this block`s parent */
  previousBlockHash?: Maybe<Scalars['String']>;
  /** Program */
  program?: Maybe<Program>;
  /** Receiver */
  receiver?: Maybe<Receiver>;
  /** Sender */
  sender?: Maybe<Sender>;
  /** Transaction Hash */
  signature?: Maybe<Scalars['String']>;
  /** Successed or failed */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction Index */
  transactionIndex?: Maybe<Scalars['BigInt']>;
  /** Transfer Type */
  transferType?: Maybe<Scalars['String']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersActionArgs = {
  parsedActionName?: Maybe<StringSelector>;
  parsedType?: Maybe<StringSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersAmountArgs = {
  blockHash?: Maybe<HashSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  callPath?: Maybe<StringSelector>;
  currency?: Maybe<Array<SolanaCurrencySelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<StringSelector>;
  externalParsedActionName?: Maybe<StringSelector>;
  externalParsedProgramName?: Maybe<StringSelector>;
  externalProgramId?: Maybe<StringSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  parsedActionName?: Maybe<StringSelector>;
  parsedProgramName?: Maybe<StringSelector>;
  parsedType?: Maybe<StringSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  programId?: Maybe<StringSelector>;
  receiverAddress?: Maybe<StringSelector>;
  receiverType?: Maybe<StringSelector>;
  recentBlockHash?: Maybe<HashSelector>;
  senderAddress?: Maybe<StringSelector>;
  senderType?: Maybe<StringSelector>;
  signature?: Maybe<HashSelector>;
  success?: Maybe<BooleanSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
  transferType?: Maybe<SolanaTransferTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersAnyArgs = {
  of: SolanaTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersBlockArgs = {
  hash?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersCallPathArgs = {
  callPath?: Maybe<StringSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersCountArgs = {
  uniq?: Maybe<SolanaTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersCountBigIntArgs = {
  uniq?: Maybe<SolanaTransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersExternalActionArgs = {
  externalParsedActionName?: Maybe<StringSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersExternalParsedArgs = {
  externalParsed?: Maybe<IntegerSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersExternalParsedTypeArgs = {
  externalParsedType?: Maybe<StringSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersExternalProgramArgs = {
  externalParsedProgramName?: Maybe<StringSelector>;
  externalProgramId?: Maybe<StringSelector>;
  externalProgramName?: Maybe<StringSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersFeePayerArgs = {
  feePayer?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersMaximumArgs = {
  get?: Maybe<SolanaTransfersMeasureable>;
  of: SolanaTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersMinimumArgs = {
  get?: Maybe<SolanaTransfersMeasureable>;
  of: SolanaTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersParsedActionNameArgs = {
  parsedActionName?: Maybe<StringSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersPreviousBlockHashArgs = {
  previousBlockHash?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersProgramArgs = {
  parsedProgramName?: Maybe<StringSelector>;
  programId?: Maybe<StringSelector>;
  programName?: Maybe<StringSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersSignatureArgs = {
  signature?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersSuccessArgs = {
  success?: Maybe<BooleanSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersTransactionIndexArgs = {
  transactionIndex?: Maybe<IntegerSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type SolanaTransfersTransferTypeArgs = {
  transferType?: Maybe<SolanaTransferTypeSelector>;
};

export type SolanaTransfersFilter = {
  blockHash?: Maybe<HashSelector>;
  callPath?: Maybe<StringSelector>;
  currency?: Maybe<Array<SolanaCurrencySelector>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<StringSelector>;
  externalParsedActionName?: Maybe<StringSelector>;
  externalParsedProgramName?: Maybe<StringSelector>;
  externalProgramId?: Maybe<StringSelector>;
  feePayer?: Maybe<HashSelector>;
  height?: Maybe<BlockSelector>;
  parsedActionName?: Maybe<StringSelector>;
  parsedProgramName?: Maybe<StringSelector>;
  parsedType?: Maybe<StringSelector>;
  previousBlockHash?: Maybe<HashSelector>;
  programId?: Maybe<StringSelector>;
  receiverAddress?: Maybe<StringSelector>;
  receiverType?: Maybe<StringSelector>;
  recentBlockHash?: Maybe<HashSelector>;
  senderAddress?: Maybe<StringSelector>;
  senderType?: Maybe<StringSelector>;
  signature?: Maybe<HashSelector>;
  success?: Maybe<BooleanSelector>;
  time?: Maybe<DateTimeSelector>;
  transactionIndex?: Maybe<IntegerSelector>;
  transferType?: Maybe<SolanaTransferTypeSelector>;
};

export enum SolanaTransfersMeasureable {
  /** Amount Transfers */
  Amount = 'amount',
  /** Hash of the the block */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Transaction Fee */
  FeePayer = 'fee_payer',
  /** Number of block in the blockhains */
  Height = 'height',
  /** The block hash of this block`s parent */
  PreviousBlockHash = 'previous_block_hash',
  /** Transaction Hash */
  Signature = 'signature',
  /** Time */
  Time = 'time',
  /** Transfer Type */
  TransferType = 'transfer_type'
}

export enum SolanaTransfersUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Number of block in the blockchains */
  Height = 'height',
  /** Transfer To */
  ReceiverAddress = 'receiver_address',
  /** Transfer From */
  SenderAddress = 'sender_address',
  /** Transaction Hash */
  Signature = 'signature',
  /** Unique time */
  Times = 'times'
}

export enum StakingTransactionsTypeEnum {
  CollectRewards = 'CollectRewards',
  CreateValidator = 'CreateValidator',
  Delegate = 'Delegate',
  EditValidator = 'EditValidator',
  Undelegate = 'Undelegate'
}

/** Indicates what type of operation the transaction is supposed to do. */
export type StakingTransactionsTypeSelector = {
  /** Type in the list */
  in?: Maybe<Array<StakingTransactionsTypeEnum>>;
  /** Type is */
  is?: Maybe<StakingTransactionsTypeEnum>;
  /** Type not */
  not?: Maybe<StakingTransactionsTypeEnum>;
  /** Type not in the list */
  notIn?: Maybe<Array<StakingTransactionsTypeEnum>>;
};

/** Stellar Chain */
export type Stellar = {
  __typename?: 'Stellar';
  /** Stellar Transfers */
  transfers?: Maybe<Array<StellarTransfers>>;
};


/** Stellar Chain */
export type StellarTransfersArgs = {
  any?: Maybe<Array<StellarTransfersFilter>>;
  date?: Maybe<DateSelector>;
  direction?: Maybe<HashSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
};

export enum StellarNetwork {
  /** The Stellar Ledger */
  Stellar = 'stellar'
}

/** Transfers in Stellar blockchain */
export type StellarTransfers = {
  __typename?: 'StellarTransfers';
  amountFrom?: Maybe<Scalars['Float']>;
  amountTo?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency from of transfer */
  currencyFrom?: Maybe<Currency>;
  /** Currency to of transfer */
  currencyTo?: Maybe<Currency>;
  /** The date this transaction was created */
  date?: Maybe<Date>;
  /** Direction */
  direction?: Maybe<Scalars['String']>;
  /** The sequence number of the ledger that this transaction was included in */
  ledger?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Operation */
  operation?: Maybe<Scalars['String']>;
  /** The number of operations contained within this transaction */
  operationCount?: Maybe<Scalars['BigInt']>;
  /** The account this transaction is been sent to */
  receiver?: Maybe<Scalars['String']>;
  /** Sender */
  sender?: Maybe<Scalars['String']>;
  /** The time this transaction was created */
  time?: Maybe<DateTime>;
  /** Hash of this transaction */
  transactionHash?: Maybe<Scalars['String']>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersAmountFromArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  direction?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersAmountToArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  direction?: Maybe<HashSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersAnyArgs = {
  of: StellarTransfersMeasureable;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersCountArgs = {
  uniq?: Maybe<StellarTransfersUniq>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersCountBigIntArgs = {
  uniq?: Maybe<StellarTransfersUniq>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersDirectionArgs = {
  direction?: Maybe<StringSelector>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersMaximumArgs = {
  get?: Maybe<StellarTransfersMeasureable>;
  of: StellarTransfersMeasureable;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersMinimumArgs = {
  get?: Maybe<StellarTransfersMeasureable>;
  of: StellarTransfersMeasureable;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersReceiverArgs = {
  receiver?: Maybe<HashSelector>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersSenderArgs = {
  sender?: Maybe<HashSelector>;
};


/** Transfers in Stellar blockchain */
export type StellarTransfersTransactionHashArgs = {
  transactionHash?: Maybe<HashSelector>;
};

export type StellarTransfersFilter = {
  date?: Maybe<DateSelector>;
  direction?: Maybe<HashSelector>;
  receiver?: Maybe<HashSelector>;
  sender?: Maybe<HashSelector>;
  transactionHash?: Maybe<HashSelector>;
};

export enum StellarTransfersMeasureable {
  /** Date */
  Date = 'date',
  /** Transfer Receiver */
  Receiver = 'receiver',
  /** Transfer Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Transaction Hash */
  TransactionHash = 'transaction_hash'
}

export enum StellarTransfersUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Transfer Receiver */
  Receiver = 'receiver',
  /** Transfer sender */
  Sender = 'sender',
  /** Unique time */
  Times = 'times',
  /** Unique date count */
  TransactionHash = 'transaction_hash'
}

/** Select by ID */
export type StringIdSelector = {
  /** ID in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** ID is */
  is?: Maybe<Scalars['String']>;
  /** ID not */
  not?: Maybe<Scalars['String']>;
  /** ID not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Select by string */
export type StringSelector = {
  /** String in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** String is */
  is?: Maybe<Scalars['String']>;
  /** String not */
  not?: Maybe<Scalars['String']>;
  /** String not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Search result subject */
export type Subject = Address | Currency | SmartContract | TransactionHash;

/** Blockchain Unified GraphQL Subscription API */
export type Subscription = {
  __typename?: 'Subscription';
  /** Ethereum Mainnet / Classic Chain Datasets */
  ethereum?: Maybe<Ethereum>;
};


/** Blockchain Unified GraphQL Subscription API */
export type SubscriptionEthereumArgs = {
  network?: Maybe<EthereumNetwork>;
};

/** Time Interval */
export type TimeInterval = {
  __typename?: 'TimeInterval';
  day: Scalars['String'];
  hour: Scalars['String'];
  minute: Scalars['String'];
  month: Scalars['String'];
  second: Scalars['String'];
  year: Scalars['String'];
};


/** Time Interval */
export type TimeIntervalDayArgs = {
  count?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
};


/** Time Interval */
export type TimeIntervalHourArgs = {
  count?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
};


/** Time Interval */
export type TimeIntervalMinuteArgs = {
  count?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
};


/** Time Interval */
export type TimeIntervalMonthArgs = {
  count?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
};


/** Time Interval */
export type TimeIntervalSecondArgs = {
  count?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
};


/** Time Interval */
export type TimeIntervalYearArgs = {
  count?: Maybe<Scalars['Int']>;
  format?: Maybe<Scalars['String']>;
};

/** Timestamp */
export type Timestamp = {
  __typename?: 'Timestamp';
  /** Nanoseconds */
  nanoseconds: Scalars['BigInt'];
  time: Scalars['ISO8601Date'];
};

/** Select trade by ID */
export type TradeIdSelector = {
  /** Trade ID in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Trade ID is */
  is?: Maybe<Scalars['String']>;
  /** Trade ID not */
  not?: Maybe<Scalars['String']>;
  /** Trade ID not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

export enum TradeSide {
  /** Buy side */
  Buy = 'BUY',
  /** Sell side */
  Sell = 'SELL'
}

/** Information about transaction */
export type TransactionElrond = {
  __typename?: 'TransactionElrond';
  /** Shard number of sender */
  data?: Maybe<Scalars['String']>;
  /** Shard number of sender */
  dataOperation?: Maybe<Scalars['String']>;
  fee?: Maybe<Scalars['Float']>;
  /** Transaction hash */
  hash?: Maybe<Scalars['String']>;
  /** Transaction index */
  index?: Maybe<Scalars['Int']>;
  /** Transaction nonce */
  nonce?: Maybe<Scalars['Int']>;
  /** Hash of the receiver */
  receiver?: Maybe<Address>;
  /** Shard number of receiver */
  receiverShard?: Maybe<Scalars['BigInt']>;
  /** Hash of the sender */
  sender?: Maybe<Address>;
  /** Shard number of sender */
  senderShard?: Maybe<Scalars['BigInt']>;
  /** Shard number of sender */
  signature?: Maybe<Scalars['String']>;
  /** Shard number of sender */
  status?: Maybe<Scalars['String']>;
};


/** Information about transaction */
export type TransactionElrondDataArgs = {
  data?: Maybe<StringSelector>;
};


/** Information about transaction */
export type TransactionElrondDataOperationArgs = {
  dataOperation?: Maybe<StringSelector>;
};


/** Information about transaction */
export type TransactionElrondFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Information about transaction */
export type TransactionElrondHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Information about transaction */
export type TransactionElrondIndexArgs = {
  index?: Maybe<IntegerSelector>;
};


/** Information about transaction */
export type TransactionElrondNonceArgs = {
  nonce?: Maybe<IntegerSelector>;
};


/** Information about transaction */
export type TransactionElrondReceiverArgs = {
  txReceiver?: Maybe<HashSelector>;
};


/** Information about transaction */
export type TransactionElrondReceiverShardArgs = {
  txReceiverShard?: Maybe<IntIdSelector>;
};


/** Information about transaction */
export type TransactionElrondSenderArgs = {
  txSender?: Maybe<HashSelector>;
};


/** Information about transaction */
export type TransactionElrondSenderShardArgs = {
  txSenderShard?: Maybe<IntIdSelector>;
};


/** Information about transaction */
export type TransactionElrondSignatureArgs = {
  signature?: Maybe<HashSelector>;
};


/** Information about transaction */
export type TransactionElrondStatusArgs = {
  status?: Maybe<StringSelector>;
};

/** Blockchain transaction */
export type TransactionHash = {
  __typename?: 'TransactionHash';
  /** Hash hex representation */
  hash: Scalars['String'];
};

/** Blockchain transaction */
export type TransactionHashIndex = {
  __typename?: 'TransactionHashIndex';
  /** Block of the Output Transaction for this input */
  block?: Maybe<Scalars['Int']>;
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0-based */
  index: Scalars['String'];
};

/** Blockchain transaction with value */
export type TransactionHashValue = {
  __typename?: 'TransactionHashValue';
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction value */
  value: Scalars['Float'];
};

/** Transaction result */
export type TransactionResult = {
  __typename?: 'TransactionResult';
  /** Result ID */
  id: Scalars['Int'];
  /** Result name */
  name: Scalars['String'];
};

/** Identification of transaction source as client application */
export type TransactionSource = {
  __typename?: 'TransactionSource';
  /** ID numeric */
  code: Scalars['Int'];
  /** Name */
  name: Scalars['String'];
};

export enum TransactionTypeEnum {
  /** Delete an account */
  AccountDelete = 'AccountDelete',
  /** Set options on an account */
  AccountSet = 'AccountSet',
  /** Cancel a check */
  CheckCancel = 'CheckCancel',
  /** Redeem a check */
  CheckCash = 'CheckCash',
  /** Create a check */
  CheckCreate = 'CheckCreate',
  /** Preauthorizes an account to send payments to this one */
  DepositPreauth = 'DepositPreauth',
  /** Reclaim escrowed XRP */
  EscrowCancel = 'EscrowCancel',
  /** Create an ascrowed XRP payment */
  EscrowCreate = 'EscrowCreate',
  /** Deliver escrowed XRP recipient */
  EscrowFinish = 'EscrowFinish',
  /** Withdraw a currency-exchange order */
  OfferCancel = 'OfferCancel',
  /** Sibmit an order to exchange currency */
  OfferCreate = 'OfferCreate',
  /** Send funds from one account to another */
  Payment = 'Payment',
  /** Claim money from a payment channel */
  PaymentChannelClaim = 'PaymentChannelClaim',
  /** Open a new payment channel */
  PaymentChannelCreate = 'PaymentChannelCreate',
  /** Add more XRP to a payment channel */
  PaymentChannelFund = 'PaymentChannelFund',
  /** Add, remove or modify an accounts regular key pair */
  SetRegularKey = 'SetRegularKey',
  /** Add, remove, or modify an accounts multi-signing list */
  SignerListSet = 'SignerListSet',
  /** Setaside one or more sequence numbers as Tickets */
  TicketCreate = 'TicketCreate',
  /** Add or modify a trust line */
  TrustSet = 'TrustSet'
}

/** Indicates what type of operation the transaction is supposed to do. */
export type TransactionTypeSelector = {
  /** Type in the list */
  in?: Maybe<Array<TransactionTypeEnum>>;
  /** Type is */
  is?: Maybe<TransactionTypeEnum>;
  /** Type not */
  not?: Maybe<TransactionTypeEnum>;
  /** Type not in the list */
  notIn?: Maybe<Array<TransactionTypeEnum>>;
};

export enum TransferReasonEnum {
  /** Smart Contract Call */
  CallResult = 'call_result',
  /** ESDT Transfer */
  EsdtTransfer = 'esdt_transfer',
  /** NFT Transfer */
  NftTransfer = 'nft_transfer',
  /** Transaction */
  Transaction = 'transaction'
}

/** Select by transfer reason */
export type TransferReasonSelector = {
  /** Reason in the list */
  in?: Maybe<Array<TransferReasonEnum>>;
  /** Reason is */
  is?: Maybe<TransferReasonEnum>;
  /** Reason not */
  not?: Maybe<TransferReasonEnum>;
  /** Reason not in the list */
  notIn?: Maybe<Array<TransferReasonEnum>>;
};

/** Select by type of transfer */
export type TransferTypeSelector = {
  /** Transfer Type in the list */
  in?: Maybe<Array<FilecoinTransferType>>;
  /** Transfer Type is */
  is?: Maybe<FilecoinTransferType>;
  /** Transfer Type not */
  not?: Maybe<FilecoinTransferType>;
  /** Transfer Type not in the list */
  notIn?: Maybe<Array<FilecoinTransferType>>;
};

export enum TransfersUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique currencies */
  Currencies = 'currencies',
  /** Unique date count */
  Dates = 'dates',
  /** Unique receivers count */
  Receivers = 'receivers',
  /** Unique senders count */
  Senders = 'senders',
  /** Transfers */
  Transfers = 'transfers',
  /** Unique transactions count */
  Txs = 'txs'
}

/** Tron Chain */
export type Tron = {
  __typename?: 'Tron';
  /** Basic information about address ( or smart contract ) */
  address: Array<TronAddressInfo>;
  /** Blockchain Blocks */
  blocks?: Maybe<Array<TronBlocks>>;
  /** Money flow using Coinpath technology */
  coinpath?: Maybe<Array<TronCoinpath>>;
  /** Blockchain Embedded Contracts */
  contracts?: Maybe<Array<TronSmartContracts>>;
  /** Trades on Ethereum DEX Smart Contracts */
  dexTrades?: Maybe<Array<TronDexTrades>>;
  /** Smart Contract Calls */
  smartContractCalls?: Maybe<Array<TronSmartContractCalls>>;
  /** Smart Contract Events */
  smartContractEvents?: Maybe<Array<TronSmartContractEvents>>;
  /** Blockchain Embedded Contracts */
  trades?: Maybe<Array<TronTrades>>;
  /** Blockchain Transactions */
  transactions?: Maybe<Array<TronTransactions>>;
  /** Currency Transfers */
  transfers?: Maybe<Array<TronTransfers>>;
};


/** Tron Chain */
export type TronAddressArgs = {
  address: Array<AddressSelectorIn>;
};


/** Tron Chain */
export type TronBlocksArgs = {
  any?: Maybe<Array<TronBlockFilter>>;
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  parentBlockHash?: Maybe<Array<HashSelector>>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
  witness?: Maybe<AddressSelector>;
};


/** Tron Chain */
export type TronCoinpathArgs = {
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  depth?: Maybe<IntegerLimitedSelector>;
  initialAddress?: Maybe<AddressSelector>;
  initialDate?: Maybe<DateSelector>;
  initialTime?: Maybe<DateTimeSelector>;
  options?: Maybe<CoinpathOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Tron Chain */
export type TronContractsArgs = {
  any?: Maybe<Array<TronContractFilter>>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
};


/** Tron Chain */
export type TronDexTradesArgs = {
  any?: Maybe<Array<TronDexTradeFilter>>;
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  options?: Maybe<QueryOptions>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Tron Chain */
export type TronSmartContractCallsArgs = {
  any?: Maybe<Array<TronSmartContractCallFilter>>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Tron Chain */
export type TronSmartContractEventsArgs = {
  any?: Maybe<Array<TronSmartContractEventFilter>>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractEvent?: Maybe<EventSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Tron Chain */
export type TronTradesArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<TronTradeFilter>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Tron Chain */
export type TronTransactionsArgs = {
  any?: Maybe<Array<TronTransactionFilter>>;
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Tron Chain */
export type TronTransfersArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  any?: Maybe<Array<TronTransferFilter>>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  options?: Maybe<QueryOptions>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** Address detailed information for Tron network */
export type TronAddressInfo = {
  __typename?: 'TronAddressInfo';
  /** Address */
  address?: Maybe<Scalars['String']>;
  /** Annotations ( tags ), if exists */
  annotation?: Maybe<Scalars['String']>;
  /** Smart Contract if exists on the address */
  smartContract?: Maybe<TronSmartContractInfo>;
};

export type TronBlockFilter = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  parentBlockHash?: Maybe<Array<HashSelector>>;
  time?: Maybe<DateTimeSelector>;
  version?: Maybe<IntegerSelector>;
  witness?: Maybe<AddressSelector>;
};

/** Blocks in Tron blockchain */
export type TronBlocks = {
  __typename?: 'TronBlocks';
  any?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  /** Block hash */
  hash: Scalars['String'];
  /** Block number (height) in blockchain */
  height: Scalars['Int'];
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Parent block hash */
  parentBlockHash: Scalars['String'];
  /** Block timestamp */
  timestamp?: Maybe<DateTime>;
  /** TX Trie Root Hash */
  txTrieRoot: Scalars['String'];
  /** Block version */
  version?: Maybe<Scalars['Int']>;
  /** Block witness */
  witness?: Maybe<Address>;
  /** Witness signature */
  witnessSignature: Scalars['String'];
};


/** Blocks in Tron blockchain */
export type TronBlocksAnyArgs = {
  of: TronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type TronBlocksCountArgs = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  parentBlockHash?: Maybe<Array<HashSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<TronBlocksUniq>;
  version?: Maybe<IntegerSelector>;
  witness?: Maybe<AddressSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocksCountBigIntArgs = {
  blockHash?: Maybe<HashSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  parentBlockHash?: Maybe<Array<HashSelector>>;
  time?: Maybe<DateTimeSelector>;
  uniq?: Maybe<TronBlocksUniq>;
  version?: Maybe<IntegerSelector>;
  witness?: Maybe<AddressSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocksHashArgs = {
  blockHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Tron blockchain */
export type TronBlocksHeightArgs = {
  height?: Maybe<BlockSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocksMaximumArgs = {
  get?: Maybe<TronBlocksMeasureable>;
  of: TronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type TronBlocksMinimumArgs = {
  get?: Maybe<TronBlocksMeasureable>;
  of: TronBlocksMeasureable;
};


/** Blocks in Tron blockchain */
export type TronBlocksParentBlockHashArgs = {
  parentBlockHash?: Maybe<Array<HashSelector>>;
};


/** Blocks in Tron blockchain */
export type TronBlocksTimestampArgs = {
  time?: Maybe<DateTimeSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocksVersionArgs = {
  version?: Maybe<IntegerSelector>;
};


/** Blocks in Tron blockchain */
export type TronBlocksWitnessArgs = {
  witness?: Maybe<AddressSelector>;
};

export enum TronBlocksMeasureable {
  /** Block */
  Block = 'block',
  /** Block hash */
  BlockHash = 'block_hash',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Block Version */
  Version = 'version',
  /** Block Witness address */
  Witness = 'witness'
}

export enum TronBlocksUniq {
  /** Unique date count */
  Dates = 'dates',
  /** Unique witness count */
  Witnesses = 'witnesses'
}

export enum TronCallsMeasureable {
  /** Block */
  Block = 'block',
  /** Call depth */
  CallDepth = 'call_depth',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Action To */
  TxTo = 'tx_to'
}

/** Coinpath */
export type TronCoinpath = {
  __typename?: 'TronCoinpath';
  /** Summary of transfered value */
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transaction is included */
  block?: Maybe<Block>;
  /** Count of transfers */
  count?: Maybe<Scalars['Int']>;
  /** Count of transfers */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** 1-based hop depth of the graph */
  depth?: Maybe<Scalars['Int']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Receiver address */
  receiver?: Maybe<TronAddressInfo>;
  /** Sender address */
  sender?: Maybe<TronAddressInfo>;
  /** Transaction of transfer happened */
  transaction?: Maybe<TransactionHashValue>;
};


/** Coinpath */
export type TronCoinpathAmountArgs = {
  in?: Maybe<BaseCurrencyEnum>;
};


/** Coinpath */
export type TronCoinpathAnyArgs = {
  of: CoinpathMeasureable;
};


/** Coinpath */
export type TronCoinpathMaximumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};


/** Coinpath */
export type TronCoinpathMinimumArgs = {
  get?: Maybe<CoinpathMeasureable>;
  of: CoinpathMeasureable;
};

export type TronContractFilter = {
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
};

export enum TronContractType {
  /** Account Create */
  AccountCreate = 'AccountCreate',
  /** Account Permission Update */
  AccountPermissionUpdate = 'AccountPermissionUpdate',
  /** Account Update */
  AccountUpdate = 'AccountUpdate',
  /** Asset Issue */
  AssetIssue = 'AssetIssue',
  /** Clear ABI */
  ClearAbi = 'ClearABI',
  /** Create Smart */
  CreateSmart = 'CreateSmart',
  /** Exchange Create */
  ExchangeCreate = 'ExchangeCreate',
  /** Exchange Inject */
  ExchangeInject = 'ExchangeInject',
  /** Exchange Transaction */
  ExchangeTransaction = 'ExchangeTransaction',
  /** Exchange Withdraw */
  ExchangeWithdraw = 'ExchangeWithdraw',
  /** Freeze Balance */
  FreezeBalance = 'FreezeBalance',
  /** Participate Asset Issue */
  ParticipateAssetIssue = 'ParticipateAssetIssue',
  /** Proposal Approve */
  ProposalApprove = 'ProposalApprove',
  /** Proposal Create */
  ProposalCreate = 'ProposalCreate',
  /** Proposal Delete */
  ProposalDelete = 'ProposalDelete',
  /** Set Account Id */
  SetAccountId = 'SetAccountId',
  /** Transfer */
  Transfer = 'Transfer',
  /** Transfer Asset */
  TransferAsset = 'TransferAsset',
  /** Trigger Smart */
  TriggerSmart = 'TriggerSmart',
  /** Unfreeze Asset */
  UnfreezeAsset = 'UnfreezeAsset',
  /** Unfreeze Balance */
  UnfreezeBalance = 'UnfreezeBalance',
  /** Update Asset */
  UpdateAsset = 'UpdateAsset',
  /** Update Brokerage */
  UpdateBrokerage = 'UpdateBrokerage',
  /** Update Energy Limit */
  UpdateEnergyLimit = 'UpdateEnergyLimit',
  /** Update Setting */
  UpdateSetting = 'UpdateSetting',
  /** Vote Witness */
  VoteWitness = 'VoteWitness',
  /** Withdraw Balance */
  WithdrawBalance = 'WithdrawBalance',
  /** Witness Create */
  WitnessCreate = 'WitnessCreate',
  /** Witness Update */
  WitnessUpdate = 'WitnessUpdate'
}

/** Select contract type(s) */
export type TronContractTypeSelector = {
  /** Contract type in the list */
  in?: Maybe<Array<TronContractType>>;
  /** Contract type is */
  is?: Maybe<TronContractType>;
  /** Contract type not */
  not?: Maybe<TronContractType>;
  /** Contract type not in the list */
  notIn?: Maybe<Array<TronContractType>>;
};

export enum TronContractsMeasureable {
  /** Block */
  Block = 'block',
  /** Contract */
  ContractType = 'contract_type',
  /** Date */
  Date = 'date',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Transaction owner */
  TxOwner = 'tx_owner'
}

/**
 * Currency selector in Tron blockchain.
 * Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
 */
export type TronCurrencySelector = {
  /** Currency in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Currency is */
  is?: Maybe<Scalars['String']>;
  /** Currency not */
  not?: Maybe<Scalars['String']>;
  /** Currency not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};

/** Tron DEX attributes */
export type TronDex = {
  __typename?: 'TronDex';
  /** Address for DEX exchange identification */
  address: Address;
  /** Full name ( name for known, Protocol for unknown ) */
  fullName: Scalars['String'];
  /** Full name ( name for known, Protocol / address for unknown ) */
  fullNameWithId: Scalars['String'];
  /** Name for known exchanges */
  name?: Maybe<Scalars['String']>;
};

export type TronDexTradeFilter = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};

/** Trades on DEX smart contracts */
export type TronDexTrades = {
  __typename?: 'TronDexTrades';
  /** Trader (maker or taker) */
  address?: Maybe<TronAddressInfo>;
  any?: Maybe<Scalars['String']>;
  baseAmount?: Maybe<Scalars['Float']>;
  /** Base currency */
  baseCurrency?: Maybe<Currency>;
  /** Block in the blockchain */
  block?: Maybe<BlockExtended>;
  buyAmount?: Maybe<Scalars['Float']>;
  /** Maker buys this currency */
  buyCurrency?: Maybe<Currency>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyFee?: Maybe<Scalars['Float']>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** Identification of admin / manager / factory of smart contract, executing trades */
  exchange?: Maybe<TronDex>;
  fee?: Maybe<Scalars['Float']>;
  internalTransactionsCount?: Maybe<Scalars['Int']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BigInt']>;
  logsCount?: Maybe<Scalars['Int']>;
  logsCountBigInt?: Maybe<Scalars['BigInt']>;
  /** Trade 'maker' side */
  maker?: Maybe<TronAddressInfo>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netFee?: Maybe<Scalars['Float']>;
  netUsage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  /** Protocol name of the smart contract */
  protocol?: Maybe<Scalars['String']>;
  quoteAmount?: Maybe<Scalars['Float']>;
  /** Quote currency */
  quoteCurrency?: Maybe<Currency>;
  quotePrice?: Maybe<Scalars['Float']>;
  sellAmount?: Maybe<Scalars['Float']>;
  /** Maker sells this currency */
  sellCurrency?: Maybe<Currency>;
  /** Side of trade ( SELL / BUY ) */
  side?: Maybe<TradeSide>;
  /** Smart contract being called */
  smartContract?: Maybe<TronSmartContract>;
  /** Trade 'taker' side */
  taker?: Maybe<TronAddressInfo>;
  /** Time interval */
  timeInterval?: Maybe<TimeInterval>;
  tradeAmount?: Maybe<Scalars['Float']>;
  /** Index of trade in transaction, used to separate trades in transaction */
  tradeIndex?: Maybe<Scalars['String']>;
  /** Transaction of DexTrade */
  transaction?: Maybe<TronTransactionInfoExtended>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesAddressArgs = {
  makerOrTaker?: Maybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesAnyArgs = {
  of: TronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type TronDexTradesBaseAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesBaseCurrencyArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesBuyAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesBuyCurrencyArgs = {
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesCountArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesCountBigIntArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TronDexTradesUniq>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesEnergyFeeArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesEnergyUsageTotalArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesExchangeArgs = {
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesFeeArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesInternalTransactionsCountArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesInternalTransactionsCountBigIntArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesLogsCountArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesLogsCountBigIntArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesMakerArgs = {
  maker?: Maybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesMaximumArgs = {
  get?: Maybe<TronDexTradesMeasureable>;
  of: TronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type TronDexTradesMinimumArgs = {
  get?: Maybe<TronDexTradesMeasureable>;
  of: TronDexTradesMeasureable;
};


/** Trades on DEX smart contracts */
export type TronDexTradesNetFeeArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesNetUsageArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesPriceArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  calculate?: Maybe<PriceAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesProtocolArgs = {
  protocol?: Maybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesQuoteAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesQuoteCurrencyArgs = {
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesQuotePriceArgs = {
  baseCurrency?: Maybe<Array<TronCurrencySelector>>;
  buyAmount?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<Array<TronCurrencySelector>>;
  calculate?: Maybe<PriceAggregateFunction>;
  date?: Maybe<DateSelector>;
  exchangeAddress?: Maybe<Array<AddressSelector>>;
  exchangeName?: Maybe<Array<StringSelector>>;
  height?: Maybe<BlockSelector>;
  maker?: Maybe<Array<AddressSelector>>;
  makerOrTaker?: Maybe<Array<AddressSelector>>;
  price?: Maybe<Array<AmountSelector>>;
  priceAsymmetry?: Maybe<Array<FloatSelector>>;
  protocol?: Maybe<Array<StringSelector>>;
  quoteCurrency?: Maybe<Array<TronCurrencySelector>>;
  sellAmount?: Maybe<Array<AmountSelector>>;
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
  smartContractAddress?: Maybe<Array<AddressSelector>>;
  taker?: Maybe<Array<AddressSelector>>;
  time?: Maybe<DateTimeSelector>;
  tradeAmountUsd?: Maybe<Array<FloatSelector>>;
  tradeIndex?: Maybe<Array<StringSelector>>;
  txHash?: Maybe<HashSelector>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesSellAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in?: Maybe<BaseCurrencyEnum>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesSellCurrencyArgs = {
  sellCurrency?: Maybe<Array<TronCurrencySelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesSmartContractArgs = {
  smartContractAddress?: Maybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesTakerArgs = {
  taker?: Maybe<Array<AddressSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesTradeAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  in: BaseCurrencyEnum;
};


/** Trades on DEX smart contracts */
export type TronDexTradesTradeIndexArgs = {
  tradeIndex?: Maybe<Array<StringSelector>>;
};


/** Trades on DEX smart contracts */
export type TronDexTradesTransactionArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};

export enum TronDexTradesMeasureable {
  /** Block */
  Block = 'block',
  /** Buy Amount */
  BuyAmount = 'buy_amount',
  /** Buy Token address */
  BuyCurrencyAddress = 'buy_currency_address',
  /** Buy Currency symbol */
  BuyCurrencySymbol = 'buy_currency_symbol',
  /** Date */
  Date = 'date',
  /** Maker */
  Maker = 'maker',
  /** Price */
  Price = 'price',
  /** Quote Price */
  QuotePrice = 'quote_price',
  /** Sell Amount */
  SellAmount = 'sell_amount',
  /** Sell Token address */
  SellCurrencyAddress = 'sell_currency_address',
  /** Sell Currency symbol */
  SellCurrencySymbol = 'sell_currency_symbol',
  /** Taker */
  Taker = 'taker',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum TronDexTradesUniq {
  /** Unique makers & takers count */
  Address = 'address',
  /** Base currencies count */
  BaseCurrency = 'base_currency',
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy currencies count */
  BuyCurrency = 'buy_currency',
  /** Unique date count */
  Dates = 'dates',
  /** Unique makers count */
  Makers = 'makers',
  /** Unique protocols count */
  Protocols = 'protocols',
  /** Quote currencies count */
  QuoteCurrency = 'quote_currency',
  /** Sell currencies count */
  SellCurrency = 'sell_currency',
  /** Unique smart contract count */
  SmartContracts = 'smart_contracts',
  /** Unique makers count */
  Takers = 'takers',
  /** Unique transactions count */
  Txs = 'txs'
}

export enum TronEventsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Smart Contract Method Signature */
  Signature = 'signature',
  /** Smart Contract Method Signature Hash */
  SignatureHash = 'signature_hash',
  /** Smart Contract Method Name */
  SignatureName = 'signature_name',
  /** Smart Contract */
  SmartContract = 'smart_contract',
  /** Time */
  Time = 'time',
  /** Action From */
  TxFrom = 'tx_from',
  /** Transaction hash */
  TxHash = 'tx_hash',
  /** Action To */
  TxTo = 'tx_to'
}

export enum TronNetwork {
  /** TRON mainnet */
  Tron = 'tron'
}

/** Tron smart contract */
export type TronSmartContract = {
  __typename?: 'TronSmartContract';
  /** Smart Contract Address */
  address: Address;
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<Currency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

export type TronSmartContractCallFilter = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** Smart Contract Calls */
export type TronSmartContractCalls = {
  __typename?: 'TronSmartContractCalls';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9. */
  callDepth?: Maybe<Scalars['String']>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** External call executed explicitly by caller. Internal calls executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Smart contract being called */
  smartContract?: Maybe<TronSmartContract>;
  /** Contract method invoked */
  smartContractMethod?: Maybe<Method>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsAnyArgs = {
  of: TronCallsMeasureable;
};


/** Smart Contract Calls */
export type TronSmartContractCallsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsCountArgs = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsEnergyUsageTotalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsMaximumArgs = {
  get?: Maybe<TronCallsMeasureable>;
  of: TronCallsMeasureable;
};


/** Smart Contract Calls */
export type TronSmartContractCallsMinimumArgs = {
  get?: Maybe<TronCallsMeasureable>;
  of: TronCallsMeasureable;
};


/** Smart Contract Calls */
export type TronSmartContractCallsNetUsageArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  date?: Maybe<DateSelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractMethod?: Maybe<MethodSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsSmartContractArgs = {
  smartContractAddress?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsSmartContractMethodArgs = {
  smartContractMethod?: Maybe<MethodSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsSuccessArgs = {
  success?: Maybe<Array<Scalars['Boolean']>>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsTxFromArgs = {
  txFrom?: Maybe<AddressSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Smart Contract Calls */
export type TronSmartContractCallsTxToArgs = {
  txTo?: Maybe<AddressSelector>;
};

export type TronSmartContractEventFilter = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractEvent?: Maybe<EventSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** Smart Contract Events */
export type TronSmartContractEvents = {
  __typename?: 'TronSmartContractEvents';
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  /** Smart contract being Evented */
  smartContract?: Maybe<TronSmartContract>;
  /** Contract method invoked */
  smartContractEvent?: Maybe<Event>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Smart Contract Events */
export type TronSmartContractEventsAnyArgs = {
  of: TronEventsMeasureable;
};


/** Smart Contract Events */
export type TronSmartContractEventsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEventsCountArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractEvent?: Maybe<EventSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type TronSmartContractEventsCountBigIntArgs = {
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  smartContractAddress?: Maybe<AddressSelector>;
  smartContractEvent?: Maybe<EventSelector>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Smart Contract Events */
export type TronSmartContractEventsMaximumArgs = {
  get?: Maybe<TronEventsMeasureable>;
  of: TronEventsMeasureable;
};


/** Smart Contract Events */
export type TronSmartContractEventsMinimumArgs = {
  get?: Maybe<TronEventsMeasureable>;
  of: TronEventsMeasureable;
};


/** Smart Contract Events */
export type TronSmartContractEventsSmartContractArgs = {
  smartContractAddress?: Maybe<AddressSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEventsSmartContractEventArgs = {
  smartContractEvent?: Maybe<EventSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEventsTxFromArgs = {
  txFrom?: Maybe<AddressSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEventsTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Smart Contract Events */
export type TronSmartContractEventsTxToArgs = {
  txTo?: Maybe<AddressSelector>;
};

/** Blockchain smart contract */
export type TronSmartContractInfo = {
  __typename?: 'TronSmartContractInfo';
  /** Smart Contract Type */
  contractType?: Maybe<SmartContractType>;
  /** Token implemented in this smart contract */
  currency?: Maybe<Currency>;
  /** Smart Contract Protocol Type */
  protocolType?: Maybe<Scalars['String']>;
};

/** Contracts */
export type TronSmartContracts = {
  __typename?: 'TronSmartContracts';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block in the blockchain */
  block?: Maybe<Block>;
  /** Contract type */
  contractType?: Maybe<TronContractType>;
  /** Counts and other metrics */
  count?: Maybe<Scalars['Int']>;
  /** Counts and other metrics */
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API. */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Transactio owner from address */
  txOwner?: Maybe<Address>;
};


/** Contracts */
export type TronSmartContractsAmountArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContractsAnyArgs = {
  of: TronContractsMeasureable;
};


/** Contracts */
export type TronSmartContractsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Contracts */
export type TronSmartContractsContractTypeArgs = {
  contractType?: Maybe<TronContractTypeSelector>;
};


/** Contracts */
export type TronSmartContractsCountArgs = {
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Contracts */
export type TronSmartContractsCountBigIntArgs = {
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
  uniq?: Maybe<SmartContractCallsUniq>;
};


/** Contracts */
export type TronSmartContractsCurrencyArgs = {
  currency?: Maybe<TronCurrencySelector>;
};


/** Contracts */
export type TronSmartContractsEnergyUsageTotalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContractsFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContractsMaximumArgs = {
  get?: Maybe<TronContractsMeasureable>;
  of: TronContractsMeasureable;
};


/** Contracts */
export type TronSmartContractsMinimumArgs = {
  get?: Maybe<TronContractsMeasureable>;
  of: TronContractsMeasureable;
};


/** Contracts */
export type TronSmartContractsNetUsageArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txOwner?: Maybe<AddressSelector>;
};


/** Contracts */
export type TronSmartContractsSuccessArgs = {
  success?: Maybe<Array<Scalars['Boolean']>>;
};


/** Contracts */
export type TronSmartContractsTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Contracts */
export type TronSmartContractsTxOwnerArgs = {
  txOwner?: Maybe<AddressSelector>;
};

export type TronTradeFilter = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};

/** Currency Trades from/to addresses in crypto currencies */
export type TronTrades = {
  __typename?: 'TronTrades';
  amountBuy?: Maybe<Scalars['Float']>;
  amountSell?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where Trade transaction is included */
  block?: Maybe<Block>;
  /** Buy Currency of Trade */
  buyCurrency?: Maybe<Currency>;
  /** Trade buyer */
  buyer?: Maybe<Address>;
  /** Contract type */
  contractType?: Maybe<TronContractType>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** exchange_id */
  exchangeId?: Maybe<Scalars['Int']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Sell Currency of Trade */
  sellCurrency?: Maybe<Currency>;
  /** Trade seller */
  seller?: Maybe<Address>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']>;
  /** Transaction hash where Trade happened */
  txHash?: Maybe<Scalars['String']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesAmountBuyArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesAmountSellArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesAnyArgs = {
  of: TronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesBuyCurrencyArgs = {
  buyCurrency?: Maybe<TronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesBuyerArgs = {
  buyer?: Maybe<AddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesContractTypeArgs = {
  contractType?: Maybe<TronContractTypeSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesCountArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesCountBigIntArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  uniq?: Maybe<TronTradesUniq>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesEnergyUsageTotalArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesExchangeIdArgs = {
  exchangeId?: Maybe<IntIdSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesFeeArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesMaximumArgs = {
  get?: Maybe<TronTradesMeasureable>;
  of: TronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesMinimumArgs = {
  get?: Maybe<TronTradesMeasureable>;
  of: TronTradesMeasureable;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesNetUsageArgs = {
  amountBuy?: Maybe<Array<AmountSelector>>;
  amountSell?: Maybe<Array<AmountSelector>>;
  buyCurrency?: Maybe<TronCurrencySelector>;
  buyer?: Maybe<AddressSelector>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  date?: Maybe<DateSelector>;
  exchangeId?: Maybe<IntIdSelector>;
  height?: Maybe<BlockSelector>;
  sellCurrency?: Maybe<TronCurrencySelector>;
  seller?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesSellCurrencyArgs = {
  sellCurrency?: Maybe<TronCurrencySelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesSellerArgs = {
  seller?: Maybe<AddressSelector>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Currency Trades from/to addresses in crypto currencies */
export type TronTradesTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};

export enum TronTradesMeasureable {
  /** Amount Sell */
  AmountBuy = 'amount_buy',
  /** Amount Sell */
  AmountSell = 'amount_sell',
  /** Block */
  Block = 'block',
  /** Buy Token address */
  BuyCurrencyAddress = 'buy_currency_address',
  /** Buy Currency name */
  BuyCurrencyName = 'buy_currency_name',
  /** Buy Currency symbol */
  BuyCurrencySymbol = 'buy_currency_symbol',
  /** Buy Token address */
  BuyTokenId = 'buy_token_id',
  /** Buy Token type */
  BuyTokenType = 'buy_token_type',
  /** Buyer */
  Buyer = 'buyer',
  /** Contract Type */
  ContractType = 'contract_type',
  /** Date */
  Date = 'date',
  /** Exchange ID */
  ExchangeId = 'exchange_id',
  /** Buy Token address */
  SellCurrencyAddress = 'sell_currency_address',
  /** Buy Currency name */
  SellCurrencyName = 'sell_currency_name',
  /** Buy Currency symbol */
  SellCurrencySymbol = 'sell_currency_symbol',
  /** Buy Token address */
  SellTokenId = 'sell_token_id',
  /** Buy Token type */
  SellTokenType = 'sell_token_type',
  /** Seller */
  Seller = 'seller',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum TronTradesUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Buy currencies */
  BuyCurrencies = 'buy_currencies',
  /** Buyers count */
  Buyers = 'buyers',
  /** Unique date count */
  Dates = 'dates',
  /** Exchange IDs */
  Exchanges = 'exchanges',
  /** Sell currencies */
  SellCurrencies = 'sell_currencies',
  /** Sellers count */
  Sellers = 'sellers'
}

export type TronTransactionFilter = {
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};

/** Blockchain Transaction Extended info */
export type TronTransactionInfoExtended = {
  __typename?: 'TronTransactionInfoExtended';
  /** Contract Address */
  contractAddress?: Maybe<Address>;
  /** Expiration */
  expiration: Scalars['Int'];
  /** Fee Limit */
  feeLimit: Scalars['Int'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String'];
  /** Result message */
  result?: Maybe<Scalars['String']>;
  /** Signatures */
  signatures: Scalars['String'];
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};

/** Transactions in Tron blockchain */
export type TronTransactions = {
  __typename?: 'TronTransactions';
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  /** Contract Address */
  contractAddress?: Maybe<Address>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyFee?: Maybe<Scalars['Float']>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** Expiration */
  expiration: Scalars['Int'];
  fee?: Maybe<Scalars['Float']>;
  /** Fee Limit */
  feeLimit: Scalars['Int'];
  /** Hash hex representation */
  hash: Scalars['String'];
  /** Transaction index in block, 0 based */
  index?: Maybe<Scalars['Int']>;
  internalTransactionsCount?: Maybe<Scalars['Int']>;
  internalTransactionsCountBigInt?: Maybe<Scalars['BigInt']>;
  logsCount?: Maybe<Scalars['Int']>;
  logsCountBigInt?: Maybe<Scalars['BigInt']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netFee?: Maybe<Scalars['Float']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Ref block Hash hex representation */
  refBlockHash: Scalars['String'];
  /** Result message */
  result?: Maybe<Scalars['String']>;
  /** Signatures */
  signatures: Scalars['String'];
  /** Success */
  success?: Maybe<Scalars['Boolean']>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsAnyArgs = {
  of: TronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type TronTransactionsBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsContractAddressArgs = {
  contractAddress?: Maybe<AddressSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsCountArgs = {
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  uniq?: Maybe<TronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsCountBigIntArgs = {
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
  uniq?: Maybe<TronTransactionsUniq>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsEnergyFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsEnergyUsageTotalArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsHashArgs = {
  txHash?: Maybe<Array<HashSelector>>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsIndexArgs = {
  txIndex?: Maybe<Array<TxIndexSelector>>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsInternalTransactionsCountArgs = {
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsInternalTransactionsCountBigIntArgs = {
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsLogsCountArgs = {
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsLogsCountBigIntArgs = {
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsMaximumArgs = {
  get?: Maybe<TronTransactionsMeasureable>;
  of: TronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type TronTransactionsMinimumArgs = {
  get?: Maybe<TronTransactionsMeasureable>;
  of: TronTransactionsMeasureable;
};


/** Transactions in Tron blockchain */
export type TronTransactionsNetFeeArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsNetUsageArgs = {
  calculate?: Maybe<AmountAggregateFunction>;
  contractAddress?: Maybe<AddressSelector>;
  date?: Maybe<DateSelector>;
  height?: Maybe<BlockSelector>;
  refBlockHash?: Maybe<Array<HashSelector>>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txHash?: Maybe<HashSelector>;
  txIndex?: Maybe<TxIndexSelector>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsRefBlockHashArgs = {
  refBlockHash?: Maybe<Array<HashSelector>>;
};


/** Transactions in Tron blockchain */
export type TronTransactionsSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};

export enum TronTransactionsMeasureable {
  /** Block */
  Block = 'block',
  /** Date */
  Date = 'date',
  /** Energy Fee */
  EnergyFee = 'energy_fee',
  /** Fee */
  Fee = 'fee',
  /** Fee Limit */
  FeeLimit = 'fee_limit',
  /** Internal transactions count */
  InternalTransactionsCount = 'internal_transactions_count',
  /** Net usage */
  NetUsage = 'net_usage',
  /** Time */
  Time = 'time',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

export enum TronTransactionsUniq {
  /** Unique blocks */
  Blocks = 'blocks',
  /** Unique date count */
  Dates = 'dates'
}

export type TronTransferFilter = {
  amount?: Maybe<Array<AmountSelector>>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};

/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfers = {
  __typename?: 'TronTransfers';
  amount?: Maybe<Scalars['Float']>;
  any?: Maybe<Scalars['String']>;
  /** Block where transfer transaction is included */
  block?: Maybe<Block>;
  /** Contract type */
  contractType?: Maybe<TronContractType>;
  count?: Maybe<Scalars['Int']>;
  countBigInt?: Maybe<Scalars['BigInt']>;
  /** Currency of transfer */
  currency?: Maybe<Currency>;
  /** Calendar date */
  date?: Maybe<Date>;
  energyUsageTotal?: Maybe<Scalars['Float']>;
  /** Entity identifier ( for ERC-721 NFT tokens ) */
  entityId?: Maybe<Scalars['String']>;
  /** External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts. */
  external?: Maybe<Scalars['Boolean']>;
  fee?: Maybe<Scalars['Float']>;
  maximum?: Maybe<Scalars['String']>;
  minimum?: Maybe<Scalars['String']>;
  netUsage?: Maybe<Scalars['Float']>;
  /** Transfer receiver */
  receiver?: Maybe<Address>;
  /** Transfer sender */
  sender?: Maybe<Address>;
  /** Transfer succeeded */
  success?: Maybe<Scalars['Boolean']>;
  /** Action from address */
  txFrom?: Maybe<Address>;
  /** Transaction hash where transfer happened */
  txHash?: Maybe<Scalars['String']>;
  /** Action to address */
  txTo?: Maybe<Address>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersAmountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersAnyArgs = {
  of: TronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersBlockArgs = {
  height?: Maybe<BlockSelector>;
  time?: Maybe<DateTimeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersContractTypeArgs = {
  contractType?: Maybe<TronContractTypeSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersCountArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersCountBigIntArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
  uniq?: Maybe<TransfersUniq>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersCurrencyArgs = {
  currency?: Maybe<TronCurrencySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersEnergyUsageTotalArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersEntityIdArgs = {
  entityId?: Maybe<EntitySelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersExternalArgs = {
  external?: Maybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersFeeArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  in?: Maybe<BaseCurrencyEnum>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersMaximumArgs = {
  get?: Maybe<TronTransfersMeasureable>;
  of: TronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersMinimumArgs = {
  get?: Maybe<TronTransfersMeasureable>;
  of: TronTransfersMeasureable;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersNetUsageArgs = {
  amount?: Maybe<Array<AmountSelector>>;
  calculate?: Maybe<AmountAggregateFunction>;
  contractType?: Maybe<TronContractTypeSelector>;
  currency?: Maybe<TronCurrencySelector>;
  date?: Maybe<DateSelector>;
  entityId?: Maybe<EntitySelector>;
  external?: Maybe<Scalars['Boolean']>;
  height?: Maybe<BlockSelector>;
  receiver?: Maybe<AddressSelector>;
  sender?: Maybe<AddressSelector>;
  success?: Maybe<Scalars['Boolean']>;
  time?: Maybe<DateTimeSelector>;
  txFrom?: Maybe<AddressSelector>;
  txHash?: Maybe<HashSelector>;
  txTo?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersReceiverArgs = {
  receiver?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersSenderArgs = {
  sender?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersSuccessArgs = {
  success?: Maybe<Scalars['Boolean']>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersTxFromArgs = {
  txFrom?: Maybe<AddressSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersTxHashArgs = {
  txHash?: Maybe<HashSelector>;
};


/** Currency transfers from/to addresses in crypto currencies */
export type TronTransfersTxToArgs = {
  txTo?: Maybe<AddressSelector>;
};

export enum TronTransfersMeasureable {
  /** Amount */
  Amount = 'amount',
  /** Block */
  Block = 'block',
  /** Token address */
  CurrencyAddress = 'currency_address',
  /** Currency symbol */
  CurrencySymbol = 'currency_symbol',
  /** Date */
  Date = 'date',
  /** Receiver */
  Receiver = 'receiver',
  /** Sender */
  Sender = 'sender',
  /** Time */
  Time = 'time',
  /** Token ID */
  TokenId = 'token_id',
  /** Token type */
  TokenType = 'token_type',
  /** Transaction hash */
  TxHash = 'tx_hash'
}

/** Selector of index of transaction in block */
export type TxIndexSelector = {
  /** Tx index in the list */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Tx index is */
  is?: Maybe<Scalars['Int']>;
  /** Tx index not */
  not?: Maybe<Scalars['Int']>;
  /** Tx index not in the list */
  notIn?: Maybe<Array<Scalars['Int']>>;
};

/** Select transactions by subtype */
export type TxSubtypeSelector = {
  /** Transaction SubType in the list */
  in?: Maybe<Array<AlgorandTxSubType>>;
  /** Transaction SubType is */
  is?: Maybe<AlgorandTxSubType>;
  /** Transaction SubType not */
  not?: Maybe<AlgorandTxSubType>;
  /** Transaction SubType not in the list */
  notIn?: Maybe<Array<AlgorandTxSubType>>;
};

/** Select transactions by type */
export type TxTypeSelector = {
  /** Transaction Type in the list */
  in?: Maybe<Array<AlgorandTxType>>;
  /** Transaction Type is */
  is?: Maybe<AlgorandTxType>;
  /** Transaction Type not */
  not?: Maybe<AlgorandTxType>;
  /** Transaction Type not in the list */
  notIn?: Maybe<Array<AlgorandTxType>>;
};

/** Select by type */
export type TypeSelector = {
  /** Type in the list */
  in?: Maybe<Array<Scalars['String']>>;
  /** Type is */
  is?: Maybe<Scalars['String']>;
  /** Type not */
  not?: Maybe<Scalars['String']>;
  /** Type not in the list */
  notIn?: Maybe<Array<Scalars['String']>>;
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AdditionalEntityFields: AdditionalEntityFields;
  String: ResolverTypeWrapper<Scalars['String']>;
  Account: ResolverTypeWrapper<Account>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  Action: ResolverTypeWrapper<Action>;
  Address: ResolverTypeWrapper<Address>;
  AddressSelector: AddressSelector;
  AddressSelectorIn: AddressSelectorIn;
  AddressWithAccount: ResolverTypeWrapper<AddressWithAccount>;
  Algorand: ResolverTypeWrapper<Algorand>;
  AlgorandAddressInfo: ResolverTypeWrapper<AlgorandAddressInfo>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  AlgorandArgumentFilter: AlgorandArgumentFilter;
  AlgorandArguments: ResolverTypeWrapper<AlgorandArguments>;
  AlgorandArgumentsMeasureable: AlgorandArgumentsMeasureable;
  AlgorandBlockFilter: AlgorandBlockFilter;
  AlgorandBlocks: ResolverTypeWrapper<AlgorandBlocks>;
  AlgorandBlocksMeasureable: AlgorandBlocksMeasureable;
  AlgorandBlocksUniq: AlgorandBlocksUniq;
  AlgorandCallsMeasureable: AlgorandCallsMeasureable;
  AlgorandCoinpath: ResolverTypeWrapper<AlgorandCoinpath>;
  AlgorandCurrencySelector: AlgorandCurrencySelector;
  AlgorandNetwork: AlgorandNetwork;
  AlgorandSmartContract: ResolverTypeWrapper<AlgorandSmartContract>;
  AlgorandSmartContractCallFilter: AlgorandSmartContractCallFilter;
  AlgorandSmartContractCalls: ResolverTypeWrapper<AlgorandSmartContractCalls>;
  AlgorandTransactionFilter: AlgorandTransactionFilter;
  AlgorandTransactionWithAttributes: ResolverTypeWrapper<AlgorandTransactionWithAttributes>;
  AlgorandTransactions: ResolverTypeWrapper<AlgorandTransactions>;
  AlgorandTransactionsMeasureable: AlgorandTransactionsMeasureable;
  AlgorandTransactionsUniq: AlgorandTransactionsUniq;
  AlgorandTransferFilter: AlgorandTransferFilter;
  AlgorandTransferType: AlgorandTransferType;
  AlgorandTransferTypeSelector: AlgorandTransferTypeSelector;
  AlgorandTransfers: ResolverTypeWrapper<AlgorandTransfers>;
  AlgorandTransfersMeasureable: AlgorandTransfersMeasureable;
  AlgorandTxSubType: AlgorandTxSubType;
  AlgorandTxType: AlgorandTxType;
  AmountAggregateFunction: AmountAggregateFunction;
  AmountSelector: AmountSelector;
  ArgumentIndexSelector: ArgumentIndexSelector;
  ArgumentName: ResolverTypeWrapper<ArgumentName>;
  ArgumentNameValue: ResolverTypeWrapper<ArgumentNameValue>;
  ArgumentSelector: ArgumentSelector;
  ArgumentTypeSelector: ArgumentTypeSelector;
  ArgumentValue: ResolverTypeWrapper<ArgumentValue>;
  ArgumentValueSelector: ArgumentValueSelector;
  BaseCurrencyEnum: BaseCurrencyEnum;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  BigIntIdSelector: BigIntIdSelector;
  Binance: ResolverTypeWrapper<Binance>;
  BinanceAddressSelector: BinanceAddressSelector;
  BinanceBlock: ResolverTypeWrapper<BinanceBlock>;
  BinanceBlockFilter: BinanceBlockFilter;
  BinanceBlockUniq: BinanceBlockUniq;
  BinanceBlocksMeasureable: BinanceBlocksMeasureable;
  BinanceCoinpath: ResolverTypeWrapper<BinanceCoinpath>;
  BinanceCurrencySelector: BinanceCurrencySelector;
  BinanceOrderFilter: BinanceOrderFilter;
  BinanceOrderSide: BinanceOrderSide;
  BinanceOrderStatus: BinanceOrderStatus;
  BinanceOrderTimeInForce: BinanceOrderTimeInForce;
  BinanceOrderType: BinanceOrderType;
  BinanceOrders: ResolverTypeWrapper<BinanceOrders>;
  BinanceOrdersMeasureable: BinanceOrdersMeasureable;
  BinanceOrdersUniq: BinanceOrdersUniq;
  BinanceTradeFilter: BinanceTradeFilter;
  BinanceTrades: ResolverTypeWrapper<BinanceTrades>;
  BinanceTradesMeasureable: BinanceTradesMeasureable;
  BinanceTradesUniq: BinanceTradesUniq;
  BinanceTransactionFilter: BinanceTransactionFilter;
  BinanceTransactionType: BinanceTransactionType;
  BinanceTransactionTypeSelector: BinanceTransactionTypeSelector;
  BinanceTransactions: ResolverTypeWrapper<BinanceTransactions>;
  BinanceTransactionsMeasureable: BinanceTransactionsMeasureable;
  BinanceTransactionsUniq: BinanceTransactionsUniq;
  BinanceTransferFilter: BinanceTransferFilter;
  BinanceTransferType: BinanceTransferType;
  BinanceTransferTypeSelector: BinanceTransferTypeSelector;
  BinanceTransfers: ResolverTypeWrapper<BinanceTransfers>;
  BinanceTransfersMeasureable: BinanceTransfersMeasureable;
  Bitcoin: ResolverTypeWrapper<Bitcoin>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  BitcoinBlock: ResolverTypeWrapper<BitcoinBlock>;
  BitcoinBlockFilter: BitcoinBlockFilter;
  BitcoinBlockUniq: BitcoinBlockUniq;
  BitcoinBlocksMeasureable: BitcoinBlocksMeasureable;
  BitcoinCoinpath: ResolverTypeWrapper<BitcoinCoinpath>;
  BitcoinCoinpathMethod: BitcoinCoinpathMethod;
  BitcoinCoinpathOptions: BitcoinCoinpathOptions;
  BitcoinInputFilter: BitcoinInputFilter;
  BitcoinInputScriptType: BitcoinInputScriptType;
  BitcoinInputScriptTypeSelector: BitcoinInputScriptTypeSelector;
  BitcoinInputUniq: BitcoinInputUniq;
  BitcoinInputsMeasureable: BitcoinInputsMeasureable;
  BitcoinNetwork: BitcoinNetwork;
  BitcoinOmniTransactionsFilter: BitcoinOmniTransactionsFilter;
  BitcoinOmniTransactionsMeasureablse: BitcoinOmniTransactionsMeasureablse;
  BitcoinOmniTransactionsUniq: BitcoinOmniTransactionsUniq;
  BitcoinOmniTransactiosn: ResolverTypeWrapper<BitcoinOmniTransactiosn>;
  BitcoinOmniTransfers: ResolverTypeWrapper<BitcoinOmniTransfers>;
  BitcoinOmniTransfersFilter: BitcoinOmniTransfersFilter;
  BitcoinOmniTransfersMeasureablse: BitcoinOmniTransfersMeasureablse;
  BitcoinOmniTransfersUniq: BitcoinOmniTransfersUniq;
  BitcoinOutputDirection: BitcoinOutputDirection;
  BitcoinOutputDirectionSelector: BitcoinOutputDirectionSelector;
  BitcoinOutputFilter: BitcoinOutputFilter;
  BitcoinOutputScriptType: BitcoinOutputScriptType;
  BitcoinOutputScriptTypeSelector: BitcoinOutputScriptTypeSelector;
  BitcoinOutputUniq: BitcoinOutputUniq;
  BitcoinOutputsMeasureable: BitcoinOutputsMeasureable;
  BitcoinTransaction: ResolverTypeWrapper<BitcoinTransaction>;
  BitcoinTransactionFilter: BitcoinTransactionFilter;
  BitcoinTransactionHashIndexValues: ResolverTypeWrapper<BitcoinTransactionHashIndexValues>;
  BitcoinTransactionInput: ResolverTypeWrapper<BitcoinTransactionInput>;
  BitcoinTransactionOutput: ResolverTypeWrapper<BitcoinTransactionOutput>;
  BitcoinTransactionUniq: BitcoinTransactionUniq;
  BitcoinTransactionsMeasureable: BitcoinTransactionsMeasureable;
  Block: ResolverTypeWrapper<Block>;
  BlockExtended: ResolverTypeWrapper<BlockExtended>;
  BlockInfo: ResolverTypeWrapper<BlockInfo>;
  BlockSelector: BlockSelector;
  BlockSelectorRange: BlockSelectorRange;
  BlockchainNetwork: ResolverTypeWrapper<BlockchainNetwork>;
  BooleanSelector: BooleanSelector;
  CallElrond: ResolverTypeWrapper<CallElrond>;
  Cardano: ResolverTypeWrapper<Cardano>;
  CardanoAddressBalance: ResolverTypeWrapper<CardanoAddressBalance>;
  CardanoAddressInfo: ResolverTypeWrapper<CardanoAddressInfo>;
  CardanoBlock: ResolverTypeWrapper<CardanoBlock>;
  CardanoBlockFilter: CardanoBlockFilter;
  CardanoBlockUniq: CardanoBlockUniq;
  CardanoBlocksMeasureable: CardanoBlocksMeasureable;
  CardanoCoinpath: ResolverTypeWrapper<CardanoCoinpath>;
  CardanoCoinpathMethod: CardanoCoinpathMethod;
  CardanoCoinpathOptions: CardanoCoinpathOptions;
  CardanoCurrencySelector: CardanoCurrencySelector;
  CardanoInputFilter: CardanoInputFilter;
  CardanoInputSource: CardanoInputSource;
  CardanoInputUniq: CardanoInputUniq;
  CardanoInputsMeasureable: CardanoInputsMeasureable;
  CardanoMintFilter: CardanoMintFilter;
  CardanoMintUniq: CardanoMintUniq;
  CardanoMintsMeasureable: CardanoMintsMeasureable;
  CardanoNetwork: CardanoNetwork;
  CardanoOutputDirection: CardanoOutputDirection;
  CardanoOutputDirectionSelector: CardanoOutputDirectionSelector;
  CardanoOutputFilter: CardanoOutputFilter;
  CardanoOutputUniq: CardanoOutputUniq;
  CardanoOutputsMeasureable: CardanoOutputsMeasureable;
  CardanoStakingAddress: ResolverTypeWrapper<CardanoStakingAddress>;
  CardanoTransaction: ResolverTypeWrapper<CardanoTransaction>;
  CardanoTransactionFilter: CardanoTransactionFilter;
  CardanoTransactionHashIndexValues: ResolverTypeWrapper<CardanoTransactionHashIndexValues>;
  CardanoTransactionInput: ResolverTypeWrapper<CardanoTransactionInput>;
  CardanoTransactionMint: ResolverTypeWrapper<CardanoTransactionMint>;
  CardanoTransactionOutput: ResolverTypeWrapper<CardanoTransactionOutput>;
  CardanoTransactionUniq: CardanoTransactionUniq;
  CardanoTransactionsMeasureable: CardanoTransactionsMeasureable;
  CoinpathEntry: ResolverTypeWrapper<CoinpathEntry>;
  CoinpathMeasureable: CoinpathMeasureable;
  CoinpathOptions: CoinpathOptions;
  Conflux: ResolverTypeWrapper<Conflux>;
  ConfluxBlockFilter: ConfluxBlockFilter;
  ConfluxBlocks: ResolverTypeWrapper<ConfluxBlocks>;
  ConfluxBlocksMeasureable: ConfluxBlocksMeasureable;
  ConfluxNetwork: ConfluxNetwork;
  ConfluxTransactionFilter: ConfluxTransactionFilter;
  ConfluxTransactions: ResolverTypeWrapper<ConfluxTransactions>;
  ConfluxTransactionsMeasureable: ConfluxTransactionsMeasureable;
  Continent: Continent;
  ContinentSelector: ContinentSelector;
  CountryCode: CountryCode;
  CountrySelector: CountrySelector;
  CovidCountry: ResolverTypeWrapper<CovidCountry>;
  CovidFact: ResolverTypeWrapper<CovidFact>;
  CovidHistory: ResolverTypeWrapper<CovidHistory>;
  CovidLocation: ResolverTypeWrapper<CovidLocation>;
  Currency: ResolverTypeWrapper<Currency>;
  CurrencySelector: CurrencySelector;
  Date: ResolverTypeWrapper<Date>;
  DateInterval: DateInterval;
  DateSelector: DateSelector;
  DateTime: ResolverTypeWrapper<DateTime>;
  DateTimeSelector: DateTimeSelector;
  DecimalNumber: ResolverTypeWrapper<Scalars['DecimalNumber']>;
  DecimalNumberAsDiv: ResolverTypeWrapper<Scalars['DecimalNumberAsDiv']>;
  DiemNetwork: DiemNetwork;
  Elrond: ResolverTypeWrapper<Elrond>;
  ElrondAddressHash: ResolverTypeWrapper<ElrondAddressHash>;
  ElrondArgument: ResolverTypeWrapper<ElrondArgument>;
  ElrondArgumentFilter: ElrondArgumentFilter;
  ElrondArgumentUniq: ElrondArgumentUniq;
  ElrondArgumentsMeasureable: ElrondArgumentsMeasureable;
  ElrondBlock: ResolverTypeWrapper<ElrondBlock>;
  ElrondBlockDimension: ResolverTypeWrapper<ElrondBlockDimension>;
  ElrondBlockFilter: ElrondBlockFilter;
  ElrondBlockUniq: ElrondBlockUniq;
  ElrondBlockValidator: ResolverTypeWrapper<ElrondBlockValidator>;
  ElrondBlockValidatorFilter: ElrondBlockValidatorFilter;
  ElrondBlockValidatorUniq: ElrondBlockValidatorUniq;
  ElrondBlockValidatorsMeasureable: ElrondBlockValidatorsMeasureable;
  ElrondBlocksMeasureable: ElrondBlocksMeasureable;
  ElrondCall: ResolverTypeWrapper<ElrondCall>;
  ElrondCallFilter: ElrondCallFilter;
  ElrondCallResult: ResolverTypeWrapper<ElrondCallResult>;
  ElrondCallResultFilter: ElrondCallResultFilter;
  ElrondCallResultUniq: ElrondCallResultUniq;
  ElrondCallResultsMeasureable: ElrondCallResultsMeasureable;
  ElrondCallsMeasureable: ElrondCallsMeasureable;
  ElrondCallsUni: ElrondCallsUni;
  ElrondCoinpath: ResolverTypeWrapper<ElrondCoinpath>;
  ElrondCoinpathMeasureable: ElrondCoinpathMeasureable;
  ElrondMiniblock: ResolverTypeWrapper<ElrondMiniblock>;
  ElrondMiniblockFilter: ElrondMiniblockFilter;
  ElrondMiniblockUniq: ElrondMiniblockUniq;
  ElrondMiniblocksMeasureable: ElrondMiniblocksMeasureable;
  ElrondNetwork: ElrondNetwork;
  ElrondNotarizedBlock: ResolverTypeWrapper<ElrondNotarizedBlock>;
  ElrondNotarizedBlockFilter: ElrondNotarizedBlockFilter;
  ElrondNotarizedBlockUniq: ElrondNotarizedBlockUniq;
  ElrondNotarizedBlocksMeasureable: ElrondNotarizedBlocksMeasureable;
  ElrondTransaction: ResolverTypeWrapper<ElrondTransaction>;
  ElrondTransactionFilter: ElrondTransactionFilter;
  ElrondTransactionUniq: ElrondTransactionUniq;
  ElrondTransactionValueDimension: ResolverTypeWrapper<ElrondTransactionValueDimension>;
  ElrondTransactionsMeasureable: ElrondTransactionsMeasureable;
  ElrondTransfer: ResolverTypeWrapper<ElrondTransfer>;
  ElrondTransferFilter: ElrondTransferFilter;
  ElrondTransferUniq: ElrondTransferUniq;
  ElrondTransfersMeasureable: ElrondTransfersMeasureable;
  Entity: ResolverTypeWrapper<Entity>;
  EntitySelector: EntitySelector;
  EntityTypeEnum: EntityTypeEnum;
  EntityTypeSelector: EntityTypeSelector;
  Eos: ResolverTypeWrapper<Eos>;
  EosAddressInfo: ResolverTypeWrapper<EosAddressInfo>;
  EosBlockFilter: EosBlockFilter;
  EosBlocks: ResolverTypeWrapper<EosBlocks>;
  EosBlocksMeasureable: EosBlocksMeasureable;
  EosBlocksUniq: EosBlocksUniq;
  EosCallsMeasureable: EosCallsMeasureable;
  EosCoinpath: ResolverTypeWrapper<EosCoinpath>;
  EosCurrencySelector: EosCurrencySelector;
  EosNetwork: EosNetwork;
  EosSmartContract: ResolverTypeWrapper<EosSmartContract>;
  EosSmartContractCallFilter: EosSmartContractCallFilter;
  EosSmartContractCalls: ResolverTypeWrapper<EosSmartContractCalls>;
  EosSmartContractInfo: ResolverTypeWrapper<EosSmartContractInfo>;
  EosTransactionFilter: EosTransactionFilter;
  EosTransactions: ResolverTypeWrapper<EosTransactions>;
  EosTransactionsMeasureable: EosTransactionsMeasureable;
  EosTransactionsUniq: EosTransactionsUniq;
  EosTransferFilter: EosTransferFilter;
  EosTransfers: ResolverTypeWrapper<EosTransfers>;
  EosTransfersMeasureable: EosTransfersMeasureable;
  Ethereum: ResolverTypeWrapper<Ethereum>;
  Ethereum2: ResolverTypeWrapper<Ethereum2>;
  Ethereum2Attestation: ResolverTypeWrapper<Ethereum2Attestation>;
  Ethereum2AttestationFieldInfo: ResolverTypeWrapper<Ethereum2AttestationFieldInfo>;
  Ethereum2AttestationInfo: ResolverTypeWrapper<Ethereum2AttestationInfo>;
  Ethereum2AttestationsMeasureable: Ethereum2AttestationsMeasureable;
  Ethereum2AttestationsUniq: Ethereum2AttestationsUniq;
  Ethereum2AttesterSlashing: ResolverTypeWrapper<Ethereum2AttesterSlashing>;
  Ethereum2AttesterSlashingMeasureable: Ethereum2AttesterSlashingMeasureable;
  Ethereum2AttesterSlashingsUniq: Ethereum2AttesterSlashingsUniq;
  Ethereum2Blocks: ResolverTypeWrapper<Ethereum2Blocks>;
  Ethereum2BlocksMeasureable: Ethereum2BlocksMeasureable;
  Ethereum2BlocksUniq: Ethereum2BlocksUniq;
  Ethereum2Deposit: ResolverTypeWrapper<Ethereum2Deposit>;
  Ethereum2DepositsMeasureable: Ethereum2DepositsMeasureable;
  Ethereum2DepositsUniq: Ethereum2DepositsUniq;
  Ethereum2Eth1Info: ResolverTypeWrapper<Ethereum2Eth1Info>;
  Ethereum2Filter: Ethereum2Filter;
  Ethereum2Network: Ethereum2Network;
  Ethereum2ProposerSlashing: ResolverTypeWrapper<Ethereum2ProposerSlashing>;
  Ethereum2ProposerSlashingMeasureable: Ethereum2ProposerSlashingMeasureable;
  Ethereum2ProposerSlashingsUniq: Ethereum2ProposerSlashingsUniq;
  Ethereum2SlashingInfo: ResolverTypeWrapper<Ethereum2SlashingInfo>;
  Ethereum2ValidatorInfo: ResolverTypeWrapper<Ethereum2ValidatorInfo>;
  Ethereum2VoluntaryExit: ResolverTypeWrapper<Ethereum2VoluntaryExit>;
  Ethereum2VoluntaryExitsMeasureable: Ethereum2VoluntaryExitsMeasureable;
  Ethereum2VoluntaryExitsUniq: Ethereum2VoluntaryExitsUniq;
  EthereumAddressInfo: ResolverTypeWrapper<EthereumAddressInfo>;
  EthereumAddressInfoWithBalance: ResolverTypeWrapper<EthereumAddressInfoWithBalance>;
  EthereumAddressSelector: EthereumAddressSelector;
  EthereumAddressSelectorIn: EthereumAddressSelectorIn;
  EthereumArgumentFilter: EthereumArgumentFilter;
  EthereumArguments: ResolverTypeWrapper<Omit<EthereumArguments, 'smartContractSignature'> & { smartContractSignature?: Maybe<ResolversTypes['Signature']> }>;
  EthereumArgumentsConvertable: EthereumArgumentsConvertable;
  EthereumArgumentsMeasureable: EthereumArgumentsMeasureable;
  EthereumBalance: ResolverTypeWrapper<EthereumBalance>;
  EthereumBalanceChange: ResolverTypeWrapper<EthereumBalanceChange>;
  EthereumBlockFilter: EthereumBlockFilter;
  EthereumBlocks: ResolverTypeWrapper<EthereumBlocks>;
  EthereumBlocksMeasureable: EthereumBlocksMeasureable;
  EthereumBlocksUniq: EthereumBlocksUniq;
  EthereumCallsMeasureable: EthereumCallsMeasureable;
  EthereumCoinpath: ResolverTypeWrapper<EthereumCoinpath>;
  EthereumCurrencySelector: EthereumCurrencySelector;
  EthereumDex: ResolverTypeWrapper<EthereumDex>;
  EthereumDexTradeFilter: EthereumDexTradeFilter;
  EthereumDexTrades: ResolverTypeWrapper<EthereumDexTrades>;
  EthereumDexTradesMeasureable: EthereumDexTradesMeasureable;
  EthereumDexTradesUniq: EthereumDexTradesUniq;
  EthereumEventsMeasureable: EthereumEventsMeasureable;
  EthereumNetwork: EthereumNetwork;
  EthereumSmartContract: ResolverTypeWrapper<EthereumSmartContract>;
  EthereumSmartContractCallFilter: EthereumSmartContractCallFilter;
  EthereumSmartContractCalls: ResolverTypeWrapper<EthereumSmartContractCalls>;
  EthereumSmartContractEvent: ResolverTypeWrapper<EthereumSmartContractEvent>;
  EthereumSmartContractEventFilter: EthereumSmartContractEventFilter;
  EthereumSmartContractInfo: ResolverTypeWrapper<EthereumSmartContractInfo>;
  EthereumSmartContractInfoWithAttributes: ResolverTypeWrapper<EthereumSmartContractInfoWithAttributes>;
  EthereumTransactionFilter: EthereumTransactionFilter;
  EthereumTransactionInfo: ResolverTypeWrapper<EthereumTransactionInfo>;
  EthereumTransactionInfoExtended: ResolverTypeWrapper<EthereumTransactionInfoExtended>;
  EthereumTransactions: ResolverTypeWrapper<EthereumTransactions>;
  EthereumTransactionsMeasureable: EthereumTransactionsMeasureable;
  EthereumTransactionsUniq: EthereumTransactionsUniq;
  EthereumTransferFilter: EthereumTransferFilter;
  EthereumTransfers: ResolverTypeWrapper<EthereumTransfers>;
  EthereumTransfersMeasureable: EthereumTransfersMeasureable;
  Event: ResolverTypeWrapper<Event>;
  EventSelector: EventSelector;
  ExternalAction: ResolverTypeWrapper<ExternalAction>;
  Filecoin: ResolverTypeWrapper<Filecoin>;
  FilecoinBlock: ResolverTypeWrapper<FilecoinBlock>;
  FilecoinBlockFilter: FilecoinBlockFilter;
  FilecoinBlockUniq: FilecoinBlockUniq;
  FilecoinBlocksMeasureable: FilecoinBlocksMeasureable;
  FilecoinCallFilter: FilecoinCallFilter;
  FilecoinCalls: ResolverTypeWrapper<FilecoinCalls>;
  FilecoinCallsMeasureable: FilecoinCallsMeasureable;
  FilecoinCoinpath: ResolverTypeWrapper<FilecoinCoinpath>;
  FilecoinMessageFilter: FilecoinMessageFilter;
  FilecoinMessages: ResolverTypeWrapper<FilecoinMessages>;
  FilecoinMessagesMeasureable: FilecoinMessagesMeasureable;
  FilecoinMessagesUniq: FilecoinMessagesUniq;
  FilecoinMinedBlock: ResolverTypeWrapper<FilecoinMinedBlock>;
  FilecoinNetwork: FilecoinNetwork;
  FilecoinTransferFilter: FilecoinTransferFilter;
  FilecoinTransferType: FilecoinTransferType;
  FilecoinTransfers: ResolverTypeWrapper<FilecoinTransfers>;
  FilecoinTransfersMeasureable: FilecoinTransfersMeasureable;
  FloatSelector: FloatSelector;
  FlowDirection: FlowDirection;
  Harmony: ResolverTypeWrapper<Harmony>;
  HarmonyArguments: ResolverTypeWrapper<HarmonyArguments>;
  HarmonyArgumentsFilter: HarmonyArgumentsFilter;
  HarmonyArgumentsMeasureable: HarmonyArgumentsMeasureable;
  HarmonyArgumentsUniq: HarmonyArgumentsUniq;
  HarmonyBlocks: ResolverTypeWrapper<HarmonyBlocks>;
  HarmonyBlocksFilter: HarmonyBlocksFilter;
  HarmonyBlocksMeasureable: HarmonyBlocksMeasureable;
  HarmonyBlocksUniq: HarmonyBlocksUniq;
  HarmonyEventsMeasureable: HarmonyEventsMeasureable;
  HarmonyNetwork: HarmonyNetwork;
  HarmonySmartContractCalls: ResolverTypeWrapper<HarmonySmartContractCalls>;
  HarmonySmartContractCallsFilter: HarmonySmartContractCallsFilter;
  HarmonySmartContractCallsMeasureable: HarmonySmartContractCallsMeasureable;
  HarmonySmartContractCallsUniq: HarmonySmartContractCallsUniq;
  HarmonySmartContractEvents: ResolverTypeWrapper<HarmonySmartContractEvents>;
  HarmonySmartContractEventsFilter: HarmonySmartContractEventsFilter;
  HarmonyStakingTransactions: ResolverTypeWrapper<HarmonyStakingTransactions>;
  HarmonyStakingTransactionsFilter: HarmonyStakingTransactionsFilter;
  HarmonyStakingTransactionsMeasureable: HarmonyStakingTransactionsMeasureable;
  HarmonyStakingTransactionsUniq: HarmonyStakingTransactionsUniq;
  HarmonyTransactions: ResolverTypeWrapper<HarmonyTransactions>;
  HarmonyTransactionsFilter: HarmonyTransactionsFilter;
  HarmonyTransactionsMeasureable: HarmonyTransactionsMeasureable;
  HarmonyTransactionsUniq: HarmonyTransactionsUniq;
  HarmonyTransfers: ResolverTypeWrapper<HarmonyTransfers>;
  HarmonyTransfersFilter: HarmonyTransfersFilter;
  HarmonyTransfersMeasureable: HarmonyTransfersMeasureable;
  HarmonyTransfersUniq: HarmonyTransfersUniq;
  HashSelector: HashSelector;
  Hedera: ResolverTypeWrapper<Hedera>;
  HederaArgument: ResolverTypeWrapper<HederaArgument>;
  HederaArgumentFilter: HederaArgumentFilter;
  HederaArgumentsMeasureable: HederaArgumentsMeasureable;
  HederaArgumentsUniq: HederaArgumentsUniq;
  HederaCall: ResolverTypeWrapper<HederaCall>;
  HederaCallFilter: HederaCallFilter;
  HederaCallsMeasureable: HederaCallsMeasureable;
  HederaCallsUniq: HederaCallsUniq;
  HederaCoinpath: ResolverTypeWrapper<HederaCoinpath>;
  HederaCurrencySelector: HederaCurrencySelector;
  HederaInput: ResolverTypeWrapper<HederaInput>;
  HederaInputFilter: HederaInputFilter;
  HederaInputMeasureable: HederaInputMeasureable;
  HederaInputsUniq: HederaInputsUniq;
  HederaMessage: ResolverTypeWrapper<HederaMessage>;
  HederaMessageFilter: HederaMessageFilter;
  HederaMessageMeasureable: HederaMessageMeasureable;
  HederaMessagesUniq: HederaMessagesUniq;
  HederaNetwork: HederaNetwork;
  HederaOutput: ResolverTypeWrapper<HederaOutput>;
  HederaOutputFilter: HederaOutputFilter;
  HederaOutputMeasureable: HederaOutputMeasureable;
  HederaOutputUniq: HederaOutputUniq;
  HederaTransaction: ResolverTypeWrapper<HederaTransaction>;
  HederaTransactionFilter: HederaTransactionFilter;
  HederaTransactionMeasureable: HederaTransactionMeasureable;
  HederaTransactionsUniq: HederaTransactionsUniq;
  ISO8601Date: ResolverTypeWrapper<Scalars['ISO8601Date']>;
  ISO8601DateTime: ResolverTypeWrapper<Scalars['ISO8601DateTime']>;
  InputScript: ResolverTypeWrapper<InputScript>;
  IntIdSelector: IntIdSelector;
  IntegerLimitedSelector: IntegerLimitedSelector;
  IntegerSelector: IntegerSelector;
  Libra: ResolverTypeWrapper<Libra>;
  LibraBlock: ResolverTypeWrapper<LibraBlock>;
  LibraBlockFilter: LibraBlockFilter;
  LibraBlockUniq: LibraBlockUniq;
  LibraBlocksMeasureable: LibraBlocksMeasureable;
  LibraCoinpath: ResolverTypeWrapper<LibraCoinpath>;
  LibraCoinpathMeasureable: LibraCoinpathMeasureable;
  LibraCurrencySelector: LibraCurrencySelector;
  LibraMintFilter: LibraMintFilter;
  LibraMints: ResolverTypeWrapper<LibraMints>;
  LibraMintsMeasureable: LibraMintsMeasureable;
  LibraMintsUniq: LibraMintsUniq;
  LibraTransactionFilter: LibraTransactionFilter;
  LibraTransactionValue: ResolverTypeWrapper<LibraTransactionValue>;
  LibraTransactions: ResolverTypeWrapper<LibraTransactions>;
  LibraTransactionsMeasureable: LibraTransactionsMeasureable;
  LibraTransactionsUniq: LibraTransactionsUniq;
  LibraTransferFilter: LibraTransferFilter;
  LibraTransfers: ResolverTypeWrapper<LibraTransfers>;
  LibraTransfersMeasureable: LibraTransfersMeasureable;
  LimitByOption: LimitByOption;
  Log: ResolverTypeWrapper<Log>;
  Method: ResolverTypeWrapper<Method>;
  MethodSelector: MethodSelector;
  MiniblockElrond: ResolverTypeWrapper<MiniblockElrond>;
  NameWithId: ResolverTypeWrapper<NameWithId>;
  Network: Network;
  Offchain: ResolverTypeWrapper<Offchain>;
  OrderIdSelector: OrderIdSelector;
  OrderSideSelector: OrderSideSelector;
  OrderStatusSelector: OrderStatusSelector;
  OrderTimeInForceSelector: OrderTimeInForceSelector;
  OrderTypeSelector: OrderTypeSelector;
  OutputIndexSelector: OutputIndexSelector;
  OutputScript: ResolverTypeWrapper<OutputScript>;
  PriceAggregateFunction: PriceAggregateFunction;
  Program: ResolverTypeWrapper<Program>;
  Protocol: Protocol;
  Query: ResolverTypeWrapper<{}>;
  QueryOptions: QueryOptions;
  Receiver: ResolverTypeWrapper<Receiver>;
  Result: ResolverTypeWrapper<Omit<Result, 'subject'> & { subject: ResolversTypes['Subject'] }>;
  RewardTypeSelector: RewardTypeSelector;
  Ripple: ResolverTypeWrapper<Ripple>;
  RippleAccountRoots: ResolverTypeWrapper<RippleAccountRoots>;
  RippleAccountRootsFilter: RippleAccountRootsFilter;
  RippleAccountRootsUniq: RippleAccountRootsUniq;
  RippleBalances: ResolverTypeWrapper<RippleBalances>;
  RippleBalancesFilter: RippleBalancesFilter;
  RippleBalancesMeasureable: RippleBalancesMeasureable;
  RippleBalancesUniq: RippleBalancesUniq;
  RippleBlocks: ResolverTypeWrapper<RippleBlocks>;
  RippleBlocksFilter: RippleBlocksFilter;
  RippleBlocksMeasureable: RippleBlocksMeasureable;
  RippleBlocksUniq: RippleBlocksUniq;
  RippleChecks: ResolverTypeWrapper<RippleChecks>;
  RippleChecksFilter: RippleChecksFilter;
  RippleChecksMeasureable: RippleChecksMeasureable;
  RippleChecksUniq: RippleChecksUniq;
  RippleEscrows: ResolverTypeWrapper<RippleEscrows>;
  RippleEscrowsFilter: RippleEscrowsFilter;
  RippleEscrowsMeasureable: RippleEscrowsMeasureable;
  RippleEscrowsUniq: RippleEscrowsUniq;
  RippleNetwork: RippleNetwork;
  RippleOffers: ResolverTypeWrapper<RippleOffers>;
  RippleOffersFilter: RippleOffersFilter;
  RippleOffersMeasureable: RippleOffersMeasureable;
  RippleOffersUniq: RippleOffersUniq;
  RipplePayments: ResolverTypeWrapper<RipplePayments>;
  RipplePaymentsFilter: RipplePaymentsFilter;
  RipplePaymentsMeasureable: RipplePaymentsMeasureable;
  RipplePaymentsUniq: RipplePaymentsUniq;
  RippleRippleStates: ResolverTypeWrapper<RippleRippleStates>;
  RippleRippleStatesMeasureable: RippleRippleStatesMeasureable;
  RippleRippleStatesUniq: RippleRippleStatesUniq;
  RippleStatesFilter: RippleStatesFilter;
  RippleTransactions: ResolverTypeWrapper<RippleTransactions>;
  RippleTransactionsFilter: RippleTransactionsFilter;
  RippleTransactionsMeasureable: RippleTransactionsMeasureable;
  RippleTransactionsUniq: RippleTransactionsUniq;
  RippleTransfers: ResolverTypeWrapper<RippleTransfers>;
  RippleTransfersFilter: RippleTransfersFilter;
  RippleTransfersMeasureable: RippleTransfersMeasureable;
  RippleTransfersUniq: RippleTransfersUniq;
  RippleccountRootsMeasureable: RippleccountRootsMeasureable;
  ScriptTypeSelectorSelector: ScriptTypeSelectorSelector;
  Sender: ResolverTypeWrapper<Sender>;
  Signature: ResolversTypes['Event'] | ResolversTypes['Method'];
  SignatureTypeSelector: SignatureTypeSelector;
  SmartContract: ResolverTypeWrapper<SmartContract>;
  SmartContractArgumentsUniq: SmartContractArgumentsUniq;
  SmartContractCallsUniq: SmartContractCallsUniq;
  SmartContractEventsUniq: SmartContractEventsUniq;
  SmartContractReadonlyAttribute: ResolverTypeWrapper<SmartContractReadonlyAttribute>;
  SmartContractType: SmartContractType;
  SmartContractTypeSelector: SmartContractTypeSelector;
  Solana: ResolverTypeWrapper<Solana>;
  SolanaBlockRewards: ResolverTypeWrapper<SolanaBlockRewards>;
  SolanaBlockRewardsFilter: SolanaBlockRewardsFilter;
  SolanaBlockRewardsMeasureable: SolanaBlockRewardsMeasureable;
  SolanaBlockRewardsUniq: SolanaBlockRewardsUniq;
  SolanaBlocks: ResolverTypeWrapper<SolanaBlocks>;
  SolanaBlocksFilter: SolanaBlocksFilter;
  SolanaBlocksMeasureable: SolanaBlocksMeasureable;
  SolanaBlocksUniq: SolanaBlocksUniq;
  SolanaCurrencySelector: SolanaCurrencySelector;
  SolanaInstructions: ResolverTypeWrapper<SolanaInstructions>;
  SolanaInstructionsFilter: SolanaInstructionsFilter;
  SolanaInstructionsMeasureable: SolanaInstructionsMeasureable;
  SolanaInstructionsUniq: SolanaInstructionsUniq;
  SolanaNetwork: SolanaNetwork;
  SolanaRewardType: SolanaRewardType;
  SolanaTransactions: ResolverTypeWrapper<SolanaTransactions>;
  SolanaTransactionsFilter: SolanaTransactionsFilter;
  SolanaTransactionsMeasureable: SolanaTransactionsMeasureable;
  SolanaTransactionsUniq: SolanaTransactionsUniq;
  SolanaTransferType: SolanaTransferType;
  SolanaTransferTypeSelector: SolanaTransferTypeSelector;
  SolanaTransfers: ResolverTypeWrapper<SolanaTransfers>;
  SolanaTransfersFilter: SolanaTransfersFilter;
  SolanaTransfersMeasureable: SolanaTransfersMeasureable;
  SolanaTransfersUniq: SolanaTransfersUniq;
  StakingTransactionsTypeEnum: StakingTransactionsTypeEnum;
  StakingTransactionsTypeSelector: StakingTransactionsTypeSelector;
  Stellar: ResolverTypeWrapper<Stellar>;
  StellarNetwork: StellarNetwork;
  StellarTransfers: ResolverTypeWrapper<StellarTransfers>;
  StellarTransfersFilter: StellarTransfersFilter;
  StellarTransfersMeasureable: StellarTransfersMeasureable;
  StellarTransfersUniq: StellarTransfersUniq;
  StringIdSelector: StringIdSelector;
  StringSelector: StringSelector;
  Subject: ResolversTypes['Address'] | ResolversTypes['Currency'] | ResolversTypes['SmartContract'] | ResolversTypes['TransactionHash'];
  Subscription: ResolverTypeWrapper<{}>;
  TimeInterval: ResolverTypeWrapper<TimeInterval>;
  Timestamp: ResolverTypeWrapper<Timestamp>;
  TradeIdSelector: TradeIdSelector;
  TradeSide: TradeSide;
  TransactionElrond: ResolverTypeWrapper<TransactionElrond>;
  TransactionHash: ResolverTypeWrapper<TransactionHash>;
  TransactionHashIndex: ResolverTypeWrapper<TransactionHashIndex>;
  TransactionHashValue: ResolverTypeWrapper<TransactionHashValue>;
  TransactionResult: ResolverTypeWrapper<TransactionResult>;
  TransactionSource: ResolverTypeWrapper<TransactionSource>;
  TransactionTypeEnum: TransactionTypeEnum;
  TransactionTypeSelector: TransactionTypeSelector;
  TransferReasonEnum: TransferReasonEnum;
  TransferReasonSelector: TransferReasonSelector;
  TransferTypeSelector: TransferTypeSelector;
  TransfersUniq: TransfersUniq;
  Tron: ResolverTypeWrapper<Tron>;
  TronAddressInfo: ResolverTypeWrapper<TronAddressInfo>;
  TronBlockFilter: TronBlockFilter;
  TronBlocks: ResolverTypeWrapper<TronBlocks>;
  TronBlocksMeasureable: TronBlocksMeasureable;
  TronBlocksUniq: TronBlocksUniq;
  TronCallsMeasureable: TronCallsMeasureable;
  TronCoinpath: ResolverTypeWrapper<TronCoinpath>;
  TronContractFilter: TronContractFilter;
  TronContractType: TronContractType;
  TronContractTypeSelector: TronContractTypeSelector;
  TronContractsMeasureable: TronContractsMeasureable;
  TronCurrencySelector: TronCurrencySelector;
  TronDex: ResolverTypeWrapper<TronDex>;
  TronDexTradeFilter: TronDexTradeFilter;
  TronDexTrades: ResolverTypeWrapper<TronDexTrades>;
  TronDexTradesMeasureable: TronDexTradesMeasureable;
  TronDexTradesUniq: TronDexTradesUniq;
  TronEventsMeasureable: TronEventsMeasureable;
  TronNetwork: TronNetwork;
  TronSmartContract: ResolverTypeWrapper<TronSmartContract>;
  TronSmartContractCallFilter: TronSmartContractCallFilter;
  TronSmartContractCalls: ResolverTypeWrapper<TronSmartContractCalls>;
  TronSmartContractEventFilter: TronSmartContractEventFilter;
  TronSmartContractEvents: ResolverTypeWrapper<TronSmartContractEvents>;
  TronSmartContractInfo: ResolverTypeWrapper<TronSmartContractInfo>;
  TronSmartContracts: ResolverTypeWrapper<TronSmartContracts>;
  TronTradeFilter: TronTradeFilter;
  TronTrades: ResolverTypeWrapper<TronTrades>;
  TronTradesMeasureable: TronTradesMeasureable;
  TronTradesUniq: TronTradesUniq;
  TronTransactionFilter: TronTransactionFilter;
  TronTransactionInfoExtended: ResolverTypeWrapper<TronTransactionInfoExtended>;
  TronTransactions: ResolverTypeWrapper<TronTransactions>;
  TronTransactionsMeasureable: TronTransactionsMeasureable;
  TronTransactionsUniq: TronTransactionsUniq;
  TronTransferFilter: TronTransferFilter;
  TronTransfers: ResolverTypeWrapper<TronTransfers>;
  TronTransfersMeasureable: TronTransfersMeasureable;
  TxIndexSelector: TxIndexSelector;
  TxSubtypeSelector: TxSubtypeSelector;
  TxTypeSelector: TxTypeSelector;
  TypeSelector: TypeSelector;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AdditionalEntityFields: AdditionalEntityFields;
  String: Scalars['String'];
  Account: Account;
  Int: Scalars['Int'];
  Action: Action;
  Address: Address;
  AddressSelector: AddressSelector;
  AddressSelectorIn: AddressSelectorIn;
  AddressWithAccount: AddressWithAccount;
  Algorand: Algorand;
  AlgorandAddressInfo: AlgorandAddressInfo;
  Float: Scalars['Float'];
  AlgorandArgumentFilter: AlgorandArgumentFilter;
  AlgorandArguments: AlgorandArguments;
  AlgorandBlockFilter: AlgorandBlockFilter;
  AlgorandBlocks: AlgorandBlocks;
  AlgorandCoinpath: AlgorandCoinpath;
  AlgorandCurrencySelector: AlgorandCurrencySelector;
  AlgorandSmartContract: AlgorandSmartContract;
  AlgorandSmartContractCallFilter: AlgorandSmartContractCallFilter;
  AlgorandSmartContractCalls: AlgorandSmartContractCalls;
  AlgorandTransactionFilter: AlgorandTransactionFilter;
  AlgorandTransactionWithAttributes: AlgorandTransactionWithAttributes;
  AlgorandTransactions: AlgorandTransactions;
  AlgorandTransferFilter: AlgorandTransferFilter;
  AlgorandTransferTypeSelector: AlgorandTransferTypeSelector;
  AlgorandTransfers: AlgorandTransfers;
  AmountSelector: AmountSelector;
  ArgumentIndexSelector: ArgumentIndexSelector;
  ArgumentName: ArgumentName;
  ArgumentNameValue: ArgumentNameValue;
  ArgumentSelector: ArgumentSelector;
  ArgumentTypeSelector: ArgumentTypeSelector;
  ArgumentValue: ArgumentValue;
  ArgumentValueSelector: ArgumentValueSelector;
  BigInt: Scalars['BigInt'];
  BigIntIdSelector: BigIntIdSelector;
  Binance: Binance;
  BinanceAddressSelector: BinanceAddressSelector;
  BinanceBlock: BinanceBlock;
  BinanceBlockFilter: BinanceBlockFilter;
  BinanceCoinpath: BinanceCoinpath;
  BinanceCurrencySelector: BinanceCurrencySelector;
  BinanceOrderFilter: BinanceOrderFilter;
  BinanceOrders: BinanceOrders;
  BinanceTradeFilter: BinanceTradeFilter;
  BinanceTrades: BinanceTrades;
  BinanceTransactionFilter: BinanceTransactionFilter;
  BinanceTransactionTypeSelector: BinanceTransactionTypeSelector;
  BinanceTransactions: BinanceTransactions;
  BinanceTransferFilter: BinanceTransferFilter;
  BinanceTransferTypeSelector: BinanceTransferTypeSelector;
  BinanceTransfers: BinanceTransfers;
  Bitcoin: Bitcoin;
  Boolean: Scalars['Boolean'];
  BitcoinBlock: BitcoinBlock;
  BitcoinBlockFilter: BitcoinBlockFilter;
  BitcoinCoinpath: BitcoinCoinpath;
  BitcoinCoinpathOptions: BitcoinCoinpathOptions;
  BitcoinInputFilter: BitcoinInputFilter;
  BitcoinInputScriptTypeSelector: BitcoinInputScriptTypeSelector;
  BitcoinOmniTransactionsFilter: BitcoinOmniTransactionsFilter;
  BitcoinOmniTransactiosn: BitcoinOmniTransactiosn;
  BitcoinOmniTransfers: BitcoinOmniTransfers;
  BitcoinOmniTransfersFilter: BitcoinOmniTransfersFilter;
  BitcoinOutputDirectionSelector: BitcoinOutputDirectionSelector;
  BitcoinOutputFilter: BitcoinOutputFilter;
  BitcoinOutputScriptTypeSelector: BitcoinOutputScriptTypeSelector;
  BitcoinTransaction: BitcoinTransaction;
  BitcoinTransactionFilter: BitcoinTransactionFilter;
  BitcoinTransactionHashIndexValues: BitcoinTransactionHashIndexValues;
  BitcoinTransactionInput: BitcoinTransactionInput;
  BitcoinTransactionOutput: BitcoinTransactionOutput;
  Block: Block;
  BlockExtended: BlockExtended;
  BlockInfo: BlockInfo;
  BlockSelector: BlockSelector;
  BlockSelectorRange: BlockSelectorRange;
  BlockchainNetwork: BlockchainNetwork;
  BooleanSelector: BooleanSelector;
  CallElrond: CallElrond;
  Cardano: Cardano;
  CardanoAddressBalance: CardanoAddressBalance;
  CardanoAddressInfo: CardanoAddressInfo;
  CardanoBlock: CardanoBlock;
  CardanoBlockFilter: CardanoBlockFilter;
  CardanoCoinpath: CardanoCoinpath;
  CardanoCoinpathOptions: CardanoCoinpathOptions;
  CardanoCurrencySelector: CardanoCurrencySelector;
  CardanoInputFilter: CardanoInputFilter;
  CardanoMintFilter: CardanoMintFilter;
  CardanoOutputDirectionSelector: CardanoOutputDirectionSelector;
  CardanoOutputFilter: CardanoOutputFilter;
  CardanoStakingAddress: CardanoStakingAddress;
  CardanoTransaction: CardanoTransaction;
  CardanoTransactionFilter: CardanoTransactionFilter;
  CardanoTransactionHashIndexValues: CardanoTransactionHashIndexValues;
  CardanoTransactionInput: CardanoTransactionInput;
  CardanoTransactionMint: CardanoTransactionMint;
  CardanoTransactionOutput: CardanoTransactionOutput;
  CoinpathEntry: CoinpathEntry;
  CoinpathOptions: CoinpathOptions;
  Conflux: Conflux;
  ConfluxBlockFilter: ConfluxBlockFilter;
  ConfluxBlocks: ConfluxBlocks;
  ConfluxTransactionFilter: ConfluxTransactionFilter;
  ConfluxTransactions: ConfluxTransactions;
  ContinentSelector: ContinentSelector;
  CountrySelector: CountrySelector;
  CovidCountry: CovidCountry;
  CovidFact: CovidFact;
  CovidHistory: CovidHistory;
  CovidLocation: CovidLocation;
  Currency: Currency;
  CurrencySelector: CurrencySelector;
  Date: Date;
  DateSelector: DateSelector;
  DateTime: DateTime;
  DateTimeSelector: DateTimeSelector;
  DecimalNumber: Scalars['DecimalNumber'];
  DecimalNumberAsDiv: Scalars['DecimalNumberAsDiv'];
  Elrond: Elrond;
  ElrondAddressHash: ElrondAddressHash;
  ElrondArgument: ElrondArgument;
  ElrondArgumentFilter: ElrondArgumentFilter;
  ElrondBlock: ElrondBlock;
  ElrondBlockDimension: ElrondBlockDimension;
  ElrondBlockFilter: ElrondBlockFilter;
  ElrondBlockValidator: ElrondBlockValidator;
  ElrondBlockValidatorFilter: ElrondBlockValidatorFilter;
  ElrondCall: ElrondCall;
  ElrondCallFilter: ElrondCallFilter;
  ElrondCallResult: ElrondCallResult;
  ElrondCallResultFilter: ElrondCallResultFilter;
  ElrondCoinpath: ElrondCoinpath;
  ElrondMiniblock: ElrondMiniblock;
  ElrondMiniblockFilter: ElrondMiniblockFilter;
  ElrondNotarizedBlock: ElrondNotarizedBlock;
  ElrondNotarizedBlockFilter: ElrondNotarizedBlockFilter;
  ElrondTransaction: ElrondTransaction;
  ElrondTransactionFilter: ElrondTransactionFilter;
  ElrondTransactionValueDimension: ElrondTransactionValueDimension;
  ElrondTransfer: ElrondTransfer;
  ElrondTransferFilter: ElrondTransferFilter;
  Entity: Entity;
  EntitySelector: EntitySelector;
  EntityTypeSelector: EntityTypeSelector;
  Eos: Eos;
  EosAddressInfo: EosAddressInfo;
  EosBlockFilter: EosBlockFilter;
  EosBlocks: EosBlocks;
  EosCoinpath: EosCoinpath;
  EosCurrencySelector: EosCurrencySelector;
  EosSmartContract: EosSmartContract;
  EosSmartContractCallFilter: EosSmartContractCallFilter;
  EosSmartContractCalls: EosSmartContractCalls;
  EosSmartContractInfo: EosSmartContractInfo;
  EosTransactionFilter: EosTransactionFilter;
  EosTransactions: EosTransactions;
  EosTransferFilter: EosTransferFilter;
  EosTransfers: EosTransfers;
  Ethereum: Ethereum;
  Ethereum2: Ethereum2;
  Ethereum2Attestation: Ethereum2Attestation;
  Ethereum2AttestationFieldInfo: Ethereum2AttestationFieldInfo;
  Ethereum2AttestationInfo: Ethereum2AttestationInfo;
  Ethereum2AttesterSlashing: Ethereum2AttesterSlashing;
  Ethereum2Blocks: Ethereum2Blocks;
  Ethereum2Deposit: Ethereum2Deposit;
  Ethereum2Eth1Info: Ethereum2Eth1Info;
  Ethereum2Filter: Ethereum2Filter;
  Ethereum2ProposerSlashing: Ethereum2ProposerSlashing;
  Ethereum2SlashingInfo: Ethereum2SlashingInfo;
  Ethereum2ValidatorInfo: Ethereum2ValidatorInfo;
  Ethereum2VoluntaryExit: Ethereum2VoluntaryExit;
  EthereumAddressInfo: EthereumAddressInfo;
  EthereumAddressInfoWithBalance: EthereumAddressInfoWithBalance;
  EthereumAddressSelector: EthereumAddressSelector;
  EthereumAddressSelectorIn: EthereumAddressSelectorIn;
  EthereumArgumentFilter: EthereumArgumentFilter;
  EthereumArguments: Omit<EthereumArguments, 'smartContractSignature'> & { smartContractSignature?: Maybe<ResolversParentTypes['Signature']> };
  EthereumBalance: EthereumBalance;
  EthereumBalanceChange: EthereumBalanceChange;
  EthereumBlockFilter: EthereumBlockFilter;
  EthereumBlocks: EthereumBlocks;
  EthereumCoinpath: EthereumCoinpath;
  EthereumCurrencySelector: EthereumCurrencySelector;
  EthereumDex: EthereumDex;
  EthereumDexTradeFilter: EthereumDexTradeFilter;
  EthereumDexTrades: EthereumDexTrades;
  EthereumSmartContract: EthereumSmartContract;
  EthereumSmartContractCallFilter: EthereumSmartContractCallFilter;
  EthereumSmartContractCalls: EthereumSmartContractCalls;
  EthereumSmartContractEvent: EthereumSmartContractEvent;
  EthereumSmartContractEventFilter: EthereumSmartContractEventFilter;
  EthereumSmartContractInfo: EthereumSmartContractInfo;
  EthereumSmartContractInfoWithAttributes: EthereumSmartContractInfoWithAttributes;
  EthereumTransactionFilter: EthereumTransactionFilter;
  EthereumTransactionInfo: EthereumTransactionInfo;
  EthereumTransactionInfoExtended: EthereumTransactionInfoExtended;
  EthereumTransactions: EthereumTransactions;
  EthereumTransferFilter: EthereumTransferFilter;
  EthereumTransfers: EthereumTransfers;
  Event: Event;
  EventSelector: EventSelector;
  ExternalAction: ExternalAction;
  Filecoin: Filecoin;
  FilecoinBlock: FilecoinBlock;
  FilecoinBlockFilter: FilecoinBlockFilter;
  FilecoinCallFilter: FilecoinCallFilter;
  FilecoinCalls: FilecoinCalls;
  FilecoinCoinpath: FilecoinCoinpath;
  FilecoinMessageFilter: FilecoinMessageFilter;
  FilecoinMessages: FilecoinMessages;
  FilecoinMinedBlock: FilecoinMinedBlock;
  FilecoinTransferFilter: FilecoinTransferFilter;
  FilecoinTransfers: FilecoinTransfers;
  FloatSelector: FloatSelector;
  Harmony: Harmony;
  HarmonyArguments: HarmonyArguments;
  HarmonyArgumentsFilter: HarmonyArgumentsFilter;
  HarmonyBlocks: HarmonyBlocks;
  HarmonyBlocksFilter: HarmonyBlocksFilter;
  HarmonySmartContractCalls: HarmonySmartContractCalls;
  HarmonySmartContractCallsFilter: HarmonySmartContractCallsFilter;
  HarmonySmartContractEvents: HarmonySmartContractEvents;
  HarmonySmartContractEventsFilter: HarmonySmartContractEventsFilter;
  HarmonyStakingTransactions: HarmonyStakingTransactions;
  HarmonyStakingTransactionsFilter: HarmonyStakingTransactionsFilter;
  HarmonyTransactions: HarmonyTransactions;
  HarmonyTransactionsFilter: HarmonyTransactionsFilter;
  HarmonyTransfers: HarmonyTransfers;
  HarmonyTransfersFilter: HarmonyTransfersFilter;
  HashSelector: HashSelector;
  Hedera: Hedera;
  HederaArgument: HederaArgument;
  HederaArgumentFilter: HederaArgumentFilter;
  HederaCall: HederaCall;
  HederaCallFilter: HederaCallFilter;
  HederaCoinpath: HederaCoinpath;
  HederaCurrencySelector: HederaCurrencySelector;
  HederaInput: HederaInput;
  HederaInputFilter: HederaInputFilter;
  HederaMessage: HederaMessage;
  HederaMessageFilter: HederaMessageFilter;
  HederaOutput: HederaOutput;
  HederaOutputFilter: HederaOutputFilter;
  HederaTransaction: HederaTransaction;
  HederaTransactionFilter: HederaTransactionFilter;
  ISO8601Date: Scalars['ISO8601Date'];
  ISO8601DateTime: Scalars['ISO8601DateTime'];
  InputScript: InputScript;
  IntIdSelector: IntIdSelector;
  IntegerLimitedSelector: IntegerLimitedSelector;
  IntegerSelector: IntegerSelector;
  Libra: Libra;
  LibraBlock: LibraBlock;
  LibraBlockFilter: LibraBlockFilter;
  LibraCoinpath: LibraCoinpath;
  LibraCurrencySelector: LibraCurrencySelector;
  LibraMintFilter: LibraMintFilter;
  LibraMints: LibraMints;
  LibraTransactionFilter: LibraTransactionFilter;
  LibraTransactionValue: LibraTransactionValue;
  LibraTransactions: LibraTransactions;
  LibraTransferFilter: LibraTransferFilter;
  LibraTransfers: LibraTransfers;
  LimitByOption: LimitByOption;
  Log: Log;
  Method: Method;
  MethodSelector: MethodSelector;
  MiniblockElrond: MiniblockElrond;
  NameWithId: NameWithId;
  Offchain: Offchain;
  OrderIdSelector: OrderIdSelector;
  OrderSideSelector: OrderSideSelector;
  OrderStatusSelector: OrderStatusSelector;
  OrderTimeInForceSelector: OrderTimeInForceSelector;
  OrderTypeSelector: OrderTypeSelector;
  OutputIndexSelector: OutputIndexSelector;
  OutputScript: OutputScript;
  Program: Program;
  Query: {};
  QueryOptions: QueryOptions;
  Receiver: Receiver;
  Result: Omit<Result, 'subject'> & { subject: ResolversParentTypes['Subject'] };
  RewardTypeSelector: RewardTypeSelector;
  Ripple: Ripple;
  RippleAccountRoots: RippleAccountRoots;
  RippleAccountRootsFilter: RippleAccountRootsFilter;
  RippleBalances: RippleBalances;
  RippleBalancesFilter: RippleBalancesFilter;
  RippleBlocks: RippleBlocks;
  RippleBlocksFilter: RippleBlocksFilter;
  RippleChecks: RippleChecks;
  RippleChecksFilter: RippleChecksFilter;
  RippleEscrows: RippleEscrows;
  RippleEscrowsFilter: RippleEscrowsFilter;
  RippleOffers: RippleOffers;
  RippleOffersFilter: RippleOffersFilter;
  RipplePayments: RipplePayments;
  RipplePaymentsFilter: RipplePaymentsFilter;
  RippleRippleStates: RippleRippleStates;
  RippleStatesFilter: RippleStatesFilter;
  RippleTransactions: RippleTransactions;
  RippleTransactionsFilter: RippleTransactionsFilter;
  RippleTransfers: RippleTransfers;
  RippleTransfersFilter: RippleTransfersFilter;
  Sender: Sender;
  Signature: ResolversParentTypes['Event'] | ResolversParentTypes['Method'];
  SmartContract: SmartContract;
  SmartContractReadonlyAttribute: SmartContractReadonlyAttribute;
  SmartContractTypeSelector: SmartContractTypeSelector;
  Solana: Solana;
  SolanaBlockRewards: SolanaBlockRewards;
  SolanaBlockRewardsFilter: SolanaBlockRewardsFilter;
  SolanaBlocks: SolanaBlocks;
  SolanaBlocksFilter: SolanaBlocksFilter;
  SolanaCurrencySelector: SolanaCurrencySelector;
  SolanaInstructions: SolanaInstructions;
  SolanaInstructionsFilter: SolanaInstructionsFilter;
  SolanaTransactions: SolanaTransactions;
  SolanaTransactionsFilter: SolanaTransactionsFilter;
  SolanaTransferTypeSelector: SolanaTransferTypeSelector;
  SolanaTransfers: SolanaTransfers;
  SolanaTransfersFilter: SolanaTransfersFilter;
  StakingTransactionsTypeSelector: StakingTransactionsTypeSelector;
  Stellar: Stellar;
  StellarTransfers: StellarTransfers;
  StellarTransfersFilter: StellarTransfersFilter;
  StringIdSelector: StringIdSelector;
  StringSelector: StringSelector;
  Subject: ResolversParentTypes['Address'] | ResolversParentTypes['Currency'] | ResolversParentTypes['SmartContract'] | ResolversParentTypes['TransactionHash'];
  Subscription: {};
  TimeInterval: TimeInterval;
  Timestamp: Timestamp;
  TradeIdSelector: TradeIdSelector;
  TransactionElrond: TransactionElrond;
  TransactionHash: TransactionHash;
  TransactionHashIndex: TransactionHashIndex;
  TransactionHashValue: TransactionHashValue;
  TransactionResult: TransactionResult;
  TransactionSource: TransactionSource;
  TransactionTypeSelector: TransactionTypeSelector;
  TransferReasonSelector: TransferReasonSelector;
  TransferTypeSelector: TransferTypeSelector;
  Tron: Tron;
  TronAddressInfo: TronAddressInfo;
  TronBlockFilter: TronBlockFilter;
  TronBlocks: TronBlocks;
  TronCoinpath: TronCoinpath;
  TronContractFilter: TronContractFilter;
  TronContractTypeSelector: TronContractTypeSelector;
  TronCurrencySelector: TronCurrencySelector;
  TronDex: TronDex;
  TronDexTradeFilter: TronDexTradeFilter;
  TronDexTrades: TronDexTrades;
  TronSmartContract: TronSmartContract;
  TronSmartContractCallFilter: TronSmartContractCallFilter;
  TronSmartContractCalls: TronSmartContractCalls;
  TronSmartContractEventFilter: TronSmartContractEventFilter;
  TronSmartContractEvents: TronSmartContractEvents;
  TronSmartContractInfo: TronSmartContractInfo;
  TronSmartContracts: TronSmartContracts;
  TronTradeFilter: TronTradeFilter;
  TronTrades: TronTrades;
  TronTransactionFilter: TronTransactionFilter;
  TronTransactionInfoExtended: TronTransactionInfoExtended;
  TronTransactions: TronTransactions;
  TronTransferFilter: TronTransferFilter;
  TronTransfers: TronTransfers;
  TxIndexSelector: TxIndexSelector;
  TxSubtypeSelector: TxSubtypeSelector;
  TxTypeSelector: TxTypeSelector;
  TypeSelector: TypeSelector;
};

export type UnionDirectiveArgs = {
  discriminatorField?: Maybe<Scalars['String']>;
  additionalFields?: Maybe<Array<Maybe<AdditionalEntityFields>>>;
};

export type UnionDirectiveResolver<Result, Parent, ContextType = any, Args = UnionDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AbstractEntityDirectiveArgs = {
  discriminatorField: Scalars['String'];
  additionalFields?: Maybe<Array<Maybe<AdditionalEntityFields>>>;
};

export type AbstractEntityDirectiveResolver<Result, Parent, ContextType = any, Args = AbstractEntityDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type EntityDirectiveArgs = {
  embedded?: Maybe<Scalars['Boolean']>;
  additionalFields?: Maybe<Array<Maybe<AdditionalEntityFields>>>;
};

export type EntityDirectiveResolver<Result, Parent, ContextType = any, Args = EntityDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type ColumnDirectiveArgs = {
  overrideType?: Maybe<Scalars['String']>;
};

export type ColumnDirectiveResolver<Result, Parent, ContextType = any, Args = ColumnDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type IdDirectiveArgs = { };

export type IdDirectiveResolver<Result, Parent, ContextType = any, Args = IdDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type LinkDirectiveArgs = {
  overrideType?: Maybe<Scalars['String']>;
};

export type LinkDirectiveResolver<Result, Parent, ContextType = any, Args = LinkDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type EmbeddedDirectiveArgs = { };

export type EmbeddedDirectiveResolver<Result, Parent, ContextType = any, Args = EmbeddedDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type MapDirectiveArgs = {
  path: Scalars['String'];
};

export type MapDirectiveResolver<Result, Parent, ContextType = any, Args = MapDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  num?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  realmId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  shardId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Action'] = ResolversParentTypes['Action']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressResolvers<ContextType = any, ParentType extends ResolversParentTypes['Address'] = ResolversParentTypes['Address']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressWithAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddressWithAccount'] = ResolversParentTypes['AddressWithAccount']> = {
  account?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandResolvers<ContextType = any, ParentType extends ResolversParentTypes['Algorand'] = ResolversParentTypes['Algorand']> = {
  address?: Resolver<Array<ResolversTypes['AlgorandAddressInfo']>, ParentType, ContextType, RequireFields<AlgorandAddressArgs, 'address'>>;
  arguments?: Resolver<Maybe<Array<ResolversTypes['AlgorandArguments']>>, ParentType, ContextType, RequireFields<AlgorandArgumentsArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['AlgorandBlocks']>>, ParentType, ContextType, RequireFields<AlgorandBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['AlgorandCoinpath']>>, ParentType, ContextType, RequireFields<AlgorandCoinpathArgs, never>>;
  smartContractCalls?: Resolver<Maybe<Array<ResolversTypes['AlgorandSmartContractCalls']>>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['AlgorandTransactions']>>, ParentType, ContextType, RequireFields<AlgorandTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['AlgorandTransfers']>>, ParentType, ContextType, RequireFields<AlgorandTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandAddressInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandAddressInfo'] = ResolversParentTypes['AlgorandAddressInfo']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  balance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  pendingRewards?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  rewards?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  round?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['AlgorandSmartContract']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandArgumentsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandArguments'] = ResolversParentTypes['AlgorandArguments']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandArgumentsAnyArgs, 'of'>>;
  argindex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<AlgorandArgumentsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<AlgorandArgumentsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<AlgorandArgumentsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  firstRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  genesisHash64?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  genesisId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandArgumentsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandArgumentsMinimumArgs, 'of'>>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  poolerror?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['AlgorandSmartContract']>, ParentType, ContextType, RequireFields<AlgorandArgumentsSmartContractArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<AlgorandArgumentsTransactionArgs, never>>;
  txSender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<AlgorandArgumentsTxSenderArgs, never>>;
  txType?: Resolver<Maybe<ResolversTypes['AlgorandTxType']>, ParentType, ContextType, RequireFields<AlgorandArgumentsTxTypeArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandArgumentsValueArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandBlocks'] = ResolversParentTypes['AlgorandBlocks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandBlocksAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<AlgorandBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<AlgorandBlocksCountBigIntArgs, never>>;
  currentProtocol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  frac?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<AlgorandBlocksHashArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<AlgorandBlocksHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandBlocksMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandBlocksMinimumArgs, 'of'>>;
  nextProtocol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nextProtocolApprovals?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  nextProtocolSwitchOn?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  nextProtocolVoteBefore?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  previousBlockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<AlgorandBlocksProposerArgs, never>>;
  rate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<AlgorandBlocksRateArgs, never>>;
  reward?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<AlgorandBlocksRewardArgs, never>>;
  seed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<AlgorandBlocksTimestampArgs, never>>;
  txnRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  upgradeApprove?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  upgradePropose?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandCoinpath'] = ResolversParentTypes['AlgorandCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<AlgorandCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandSmartContractResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandSmartContract'] = ResolversParentTypes['AlgorandSmartContract']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  bytecode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  source?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandSmartContractCallsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandSmartContractCalls'] = ResolversParentTypes['AlgorandSmartContractCalls']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsFeeArgs, never>>;
  firstRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  genesisHash64?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  genesisId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsMinimumArgs, 'of'>>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  poolerror?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['AlgorandSmartContract']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsSmartContractArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsTransactionArgs, never>>;
  txSender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsTxSenderArgs, never>>;
  txType?: Resolver<Maybe<ResolversTypes['AlgorandTxType']>, ParentType, ContextType, RequireFields<AlgorandSmartContractCallsTxTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandTransactionWithAttributesResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandTransactionWithAttributes'] = ResolversParentTypes['AlgorandTransactionWithAttributes']> = {
  block?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  firstRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  fromrewards?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  lease?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  poolerror?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  subtype?: Resolver<Maybe<ResolversTypes['AlgorandTxSubType']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['AlgorandTxType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandTransactions'] = ResolversParentTypes['AlgorandTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<AlgorandTransactionsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<AlgorandTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<AlgorandTransactionsCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<AlgorandTransactionsCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<AlgorandTransactionsFeeArgs, never>>;
  firstRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  genesisHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  genesisId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<AlgorandTransactionsHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<AlgorandTransactionsIndexArgs, never>>;
  lastRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandTransactionsMinimumArgs, 'of'>>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  poolerror?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<AlgorandTransactionsSenderArgs, never>>;
  subtype?: Resolver<Maybe<ResolversTypes['AlgorandTxSubType']>, ParentType, ContextType, RequireFields<AlgorandTransactionsSubtypeArgs, never>>;
  type?: Resolver<Maybe<ResolversTypes['AlgorandTxType']>, ParentType, ContextType, RequireFields<AlgorandTransactionsTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AlgorandTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['AlgorandTransfers'] = ResolversParentTypes['AlgorandTransfers']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<AlgorandTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<AlgorandTransfersBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<AlgorandTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<AlgorandTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<AlgorandTransfersCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  firstRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  lastRound?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandTransfersMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AlgorandTransfersMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<AlgorandTransfersReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<AlgorandTransfersSenderArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['AlgorandTransactionWithAttributes']>, ParentType, ContextType, RequireFields<AlgorandTransfersTransactionArgs, never>>;
  transferType?: Resolver<Maybe<ResolversTypes['AlgorandTransferType']>, ParentType, ContextType, RequireFields<AlgorandTransfersTransferTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ArgumentNameResolvers<ContextType = any, ParentType extends ResolversParentTypes['ArgumentName'] = ResolversParentTypes['ArgumentName']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ArgumentNameValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ArgumentNameValue'] = ResolversParentTypes['ArgumentNameValue']> = {
  argument?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  argumentType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ArgumentValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ArgumentValue'] = ResolversParentTypes['ArgumentValue']> = {
  address?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type BinanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Binance'] = ResolversParentTypes['Binance']> = {
  blocks?: Resolver<Maybe<Array<ResolversTypes['BinanceBlock']>>, ParentType, ContextType, RequireFields<BinanceBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['BinanceCoinpath']>>, ParentType, ContextType, RequireFields<BinanceCoinpathArgs, never>>;
  orders?: Resolver<Maybe<Array<ResolversTypes['BinanceOrders']>>, ParentType, ContextType, RequireFields<BinanceOrdersArgs, never>>;
  trades?: Resolver<Maybe<Array<ResolversTypes['BinanceTrades']>>, ParentType, ContextType, RequireFields<BinanceTradesArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['BinanceTransactions']>>, ParentType, ContextType, RequireFields<BinanceTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['BinanceTransfers']>>, ParentType, ContextType, RequireFields<BinanceTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BinanceBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['BinanceBlock'] = ResolversParentTypes['BinanceBlock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceBlockAnyArgs, 'of'>>;
  blockId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceBlockBlockIdArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceBlockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BinanceBlockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<BinanceBlockHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceBlockMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceBlockMinimumArgs, 'of'>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<BinanceBlockTimestampArgs, never>>;
  validatorConsensusPubkey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceBlockValidatorConsensusPubkeyArgs, never>>;
  validatorFeeAddr?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceBlockValidatorFeeAddrArgs, never>>;
  validatorMoniker?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceBlockValidatorMonikerArgs, never>>;
  validatorOperaHrAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceBlockValidatorOperaHrAddressArgs, never>>;
  validatorOperatorAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceBlockValidatorOperatorAddressArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BinanceCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['BinanceCoinpath'] = ResolversParentTypes['BinanceCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BinanceCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BinanceOrdersResolvers<ContextType = any, ParentType extends ResolversParentTypes['BinanceOrders'] = ResolversParentTypes['BinanceOrders']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceOrdersAnyArgs, 'of'>>;
  baseAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BinanceOrdersBaseAmountArgs, never>>;
  baseCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<BinanceOrdersBaseCurrencyArgs, never>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BinanceOrdersBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceOrdersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BinanceOrdersCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceOrdersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceOrdersMinimumArgs, 'of'>>;
  orderId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceOrdersOrderIdArgs, never>>;
  orderOwner?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceOrdersOrderOwnerArgs, never>>;
  orderSide?: Resolver<Maybe<ResolversTypes['BinanceOrderSide']>, ParentType, ContextType, RequireFields<BinanceOrdersOrderSideArgs, never>>;
  orderStatus?: Resolver<Maybe<ResolversTypes['BinanceOrderStatus']>, ParentType, ContextType, RequireFields<BinanceOrdersOrderStatusArgs, never>>;
  orderTimeInForce?: Resolver<Maybe<ResolversTypes['BinanceOrderTimeInForce']>, ParentType, ContextType, RequireFields<BinanceOrdersOrderTimeInForceArgs, never>>;
  orderType?: Resolver<Maybe<ResolversTypes['BinanceOrderType']>, ParentType, ContextType, RequireFields<BinanceOrdersOrderTypeArgs, never>>;
  price?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  quoteAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BinanceOrdersQuoteAmountArgs, never>>;
  quoteCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<BinanceOrdersQuoteCurrencyArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHash']>, ParentType, ContextType, RequireFields<BinanceOrdersTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BinanceTradesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BinanceTrades'] = ResolversParentTypes['BinanceTrades']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTradesAnyArgs, 'of'>>;
  baseAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BinanceTradesBaseAmountArgs, never>>;
  baseCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<BinanceTradesBaseCurrencyArgs, never>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BinanceTradesBlockArgs, never>>;
  buyOrderId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTradesBuyOrderIdArgs, never>>;
  buyer?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceTradesBuyerArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceTradesCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BinanceTradesCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTradesMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTradesMinimumArgs, 'of'>>;
  price?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  quoteAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BinanceTradesQuoteAmountArgs, never>>;
  quoteCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<BinanceTradesQuoteCurrencyArgs, never>>;
  sellOrderId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTradesSellOrderIdArgs, never>>;
  seller?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceTradesSellerArgs, never>>;
  tradeId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTradesTradeIdArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<BinanceTradesTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BinanceTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['BinanceTransactions'] = ResolversParentTypes['BinanceTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BinanceTransactionsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BinanceTransactionsCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<BinanceTransactionsCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  deposit?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BinanceTransactionsDepositArgs, never>>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BinanceTransactionsHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  log?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransactionsMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransactionsMinimumArgs, 'of'>>;
  proposalId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceTransactionsProposalIdArgs, never>>;
  transactionCode?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceTransactionsTransactionCodeArgs, never>>;
  transactionSource?: Resolver<Maybe<ResolversTypes['TransactionSource']>, ParentType, ContextType, RequireFields<BinanceTransactionsTransactionSourceArgs, never>>;
  transactionType?: Resolver<Maybe<ResolversTypes['BinanceTransactionType']>, ParentType, ContextType, RequireFields<BinanceTransactionsTransactionTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BinanceTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['BinanceTransfers'] = ResolversParentTypes['BinanceTransfers']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BinanceTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BinanceTransfersBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BinanceTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<BinanceTransfersCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransfersMinimumArgs, 'of'>>;
  orderId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransfersOrderIdArgs, never>>;
  outputIndex?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BinanceTransfersOutputIndexArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceTransfersReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BinanceTransfersSenderArgs, never>>;
  tradeId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BinanceTransfersTradeIdArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<BinanceTransfersTransactionArgs, never>>;
  transferType?: Resolver<Maybe<ResolversTypes['BinanceTransferType']>, ParentType, ContextType, RequireFields<BinanceTransfersTransferTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['Bitcoin'] = ResolversParentTypes['Bitcoin']> = {
  blocks?: Resolver<Maybe<Array<ResolversTypes['BitcoinBlock']>>, ParentType, ContextType, RequireFields<BitcoinBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['BitcoinCoinpath']>>, ParentType, ContextType, RequireFields<BitcoinCoinpathArgs, never>>;
  inputs?: Resolver<Maybe<Array<ResolversTypes['BitcoinTransactionInput']>>, ParentType, ContextType, RequireFields<BitcoinInputsArgs, never>>;
  omniTransactions?: Resolver<Maybe<Array<ResolversTypes['BitcoinOmniTransactiosn']>>, ParentType, ContextType, RequireFields<BitcoinOmniTransactionsArgs, never>>;
  omniTransfers?: Resolver<Maybe<Array<ResolversTypes['BitcoinOmniTransfers']>>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersArgs, never>>;
  outputs?: Resolver<Maybe<Array<ResolversTypes['BitcoinTransactionOutput']>>, ParentType, ContextType, RequireFields<BitcoinOutputsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['BitcoinTransaction']>>, ParentType, ContextType, RequireFields<BitcoinTransactionsArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinBlock'] = ResolversParentTypes['BitcoinBlock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinBlockAnyArgs, 'of'>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinBlockBlockHashArgs, never>>;
  blockSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinBlockBlockSizeArgs, never>>;
  blockStrippedSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinBlockBlockStrippedSizeArgs, never>>;
  blockVersion?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinBlockBlockVersionArgs, never>>;
  blockWeight?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinBlockBlockWeightArgs, never>>;
  chainwork?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinBlockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinBlockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  difficulty?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinBlockDifficultyArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<BitcoinBlockHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinBlockMaximumArgs, 'of'>>;
  medianTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinBlockMinimumArgs, 'of'>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<BitcoinBlockTimestampArgs, never>>;
  transactionCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinBlockTransactionCountArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinCoinpath'] = ResolversParentTypes['BitcoinCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['BitcoinTransactionHashIndexValues']>, ParentType, ContextType>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['CoinpathEntry']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinOmniTransactiosnResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinOmniTransactiosn'] = ResolversParentTypes['BitcoinOmniTransactiosn']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnBlockArgs, never>>;
  blockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnBlockHashArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  feeValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnFeeValueArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnHashArgs, never>>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnIndexArgs, never>>;
  invalidReason?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnInvalidReasonArgs, never>>;
  json?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnJsonArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnMinimumArgs, 'of'>>;
  txSender?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnTxSenderArgs, never>>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnTypeArgs, never>>;
  typeInt?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnTypeIntArgs, never>>;
  valid?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnValidArgs, never>>;
  version?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<BitcoinOmniTransactiosnVersionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinOmniTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinOmniTransfers'] = ResolversParentTypes['BitcoinOmniTransfers']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersBlockArgs, never>>;
  blockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersBlockHashArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  direction?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersDirectionArgs, never>>;
  divisible?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersDivisibleArgs, never>>;
  feeValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersFeeValueArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersHashArgs, never>>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersIndexArgs, never>>;
  ismine?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersIsmineArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersMinimumArgs, 'of'>>;
  transferFrom?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersTransferFromArgs, never>>;
  transferTo?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersTransferToArgs, never>>;
  txSender?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersTxSenderArgs, never>>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersTypeArgs, never>>;
  typeInt?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<BitcoinOmniTransfersTypeIntArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinOmniTransfersValueArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinTransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinTransaction'] = ResolversParentTypes['BitcoinTransaction']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BitcoinTransactionBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinTransactionCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  feeValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinTransactionFeeValueArgs, never>>;
  feeValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumber']>, ParentType, ContextType, RequireFields<BitcoinTransactionFeeValueDecimalArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinTransactionHashArgs, never>>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<BitcoinTransactionIndexArgs, never>>;
  inputCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputCountArgs, never>>;
  inputCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputCountBigIntArgs, never>>;
  inputValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputValueArgs, never>>;
  inputValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumber']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputValueDecimalArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionMaximumArgs, 'of'>>;
  minedValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinTransactionMinedValueArgs, never>>;
  minedValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumber']>, ParentType, ContextType, RequireFields<BitcoinTransactionMinedValueDecimalArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionMinimumArgs, 'of'>>;
  outputCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputCountArgs, never>>;
  outputCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputCountBigIntArgs, never>>;
  outputValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputValueArgs, never>>;
  outputValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumber']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputValueDecimalArgs, never>>;
  txCoinbase?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<BitcoinTransactionTxCoinbaseArgs, never>>;
  txLocktime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinTransactionTxLocktimeArgs, never>>;
  txSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionTxSizeArgs, never>>;
  txVersion?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionTxVersionArgs, never>>;
  txVsize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionTxVsizeArgs, never>>;
  txWeight?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionTxWeightArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinTransactionHashIndexValuesResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinTransactionHashIndexValues'] = ResolversParentTypes['BitcoinTransactionHashIndexValues']> = {
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  valueIn?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  valueInDecimal?: Resolver<ResolversTypes['DecimalNumber'], ParentType, ContextType>;
  valueOut?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  valueOutDecimal?: Resolver<ResolversTypes['DecimalNumber'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinTransactionInputResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinTransactionInput'] = ResolversParentTypes['BitcoinTransactionInput']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  inputAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputInputAddressArgs, never>>;
  inputIndex?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputInputIndexArgs, never>>;
  inputScript?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  inputScriptType?: Resolver<Maybe<ResolversTypes['InputScript']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputInputScriptTypeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputMinimumArgs, 'of'>>;
  outputTransaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputOutputTransactionArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputTransactionArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputValueArgs, never>>;
  valueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumber']>, ParentType, ContextType, RequireFields<BitcoinTransactionInputValueDecimalArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BitcoinTransactionOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['BitcoinTransactionOutput'] = ResolversParentTypes['BitcoinTransactionOutput']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputMinimumArgs, 'of'>>;
  outputAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputOutputAddressArgs, never>>;
  outputDirection?: Resolver<Maybe<ResolversTypes['BitcoinOutputDirection']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputOutputDirectionArgs, never>>;
  outputIndex?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputOutputIndexArgs, never>>;
  outputScript?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  outputScriptType?: Resolver<Maybe<ResolversTypes['OutputScript']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputOutputScriptTypeArgs, never>>;
  reqSigs?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputTransactionArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputValueArgs, never>>;
  valueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumber']>, ParentType, ContextType, RequireFields<BitcoinTransactionOutputValueDecimalArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['Block'] = ResolversParentTypes['Block']> = {
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BlockExtendedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BlockExtended'] = ResolversParentTypes['BlockExtended']> = {
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BlockInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['BlockInfo'] = ResolversParentTypes['BlockInfo']> = {
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BlockchainNetworkResolvers<ContextType = any, ParentType extends ResolversParentTypes['BlockchainNetwork'] = ResolversParentTypes['BlockchainNetwork']> = {
  network?: Resolver<ResolversTypes['Network'], ParentType, ContextType>;
  protocol?: Resolver<ResolversTypes['Protocol'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CallElrondResolvers<ContextType = any, ParentType extends ResolversParentTypes['CallElrond'] = ResolversParentTypes['CallElrond']> = {
  callDepth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  smartContractAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CallElrondSmartContractAddressArgs, never>>;
  smartContractName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CallElrondSmartContractNameArgs, never>>;
  smartContractSignature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CallElrondSmartContractSignatureArgs, never>>;
  smartContractSignatureHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CallElrondSmartContractSignatureHashArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoResolvers<ContextType = any, ParentType extends ResolversParentTypes['Cardano'] = ResolversParentTypes['Cardano']> = {
  address?: Resolver<Array<ResolversTypes['CardanoAddressInfo']>, ParentType, ContextType, RequireFields<CardanoAddressArgs, 'address'>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['CardanoBlock']>>, ParentType, ContextType, RequireFields<CardanoBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['CardanoCoinpath']>>, ParentType, ContextType, RequireFields<CardanoCoinpathArgs, never>>;
  inputs?: Resolver<Maybe<Array<ResolversTypes['CardanoTransactionInput']>>, ParentType, ContextType, RequireFields<CardanoInputsArgs, never>>;
  mints?: Resolver<Maybe<Array<ResolversTypes['CardanoTransactionMint']>>, ParentType, ContextType, RequireFields<CardanoMintsArgs, never>>;
  outputs?: Resolver<Maybe<Array<ResolversTypes['CardanoTransactionOutput']>>, ParentType, ContextType, RequireFields<CardanoOutputsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['CardanoTransaction']>>, ParentType, ContextType, RequireFields<CardanoTransactionsArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoAddressBalanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoAddressBalance'] = ResolversParentTypes['CardanoAddressBalance']> = {
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoAddressInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoAddressInfo'] = ResolversParentTypes['CardanoAddressInfo']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  balance?: Resolver<Maybe<Array<ResolversTypes['CardanoAddressBalance']>>, ParentType, ContextType>;
  staking?: Resolver<Maybe<Array<ResolversTypes['CardanoStakingAddress']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoBlock'] = ResolversParentTypes['CardanoBlock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoBlockAnyArgs, 'of'>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoBlockBlockHashArgs, never>>;
  blockSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoBlockBlockSizeArgs, never>>;
  blockVersion?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoBlockBlockVersionArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoBlockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoBlockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  epoch?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<CardanoBlockHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoBlockMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoBlockMinimumArgs, 'of'>>;
  opCert?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slot?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  slotInEpoch?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  slotLeaderDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slotLeaderHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<CardanoBlockTimestampArgs, never>>;
  transactionCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoBlockTransactionCountArgs, never>>;
  vrfKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoCoinpath'] = ResolversParentTypes['CardanoCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['CardanoTransactionHashIndexValues']>, ParentType, ContextType>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['CoinpathEntry']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoStakingAddressResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoStakingAddress'] = ResolversParentTypes['CardanoStakingAddress']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  rewardsAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  stakedAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  stakedAmountWithRewards?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  withdrawnAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoTransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoTransaction'] = ResolversParentTypes['CardanoTransaction']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<CardanoTransactionBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  depositValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionDepositValueArgs, never>>;
  depositValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumberAsDiv']>, ParentType, ContextType, RequireFields<CardanoTransactionDepositValueDecimalArgs, never>>;
  feeValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionFeeValueArgs, never>>;
  feeValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumberAsDiv']>, ParentType, ContextType, RequireFields<CardanoTransactionFeeValueDecimalArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<CardanoTransactionHashArgs, never>>;
  includedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<CardanoTransactionIndexArgs, never>>;
  inputCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionInputCountArgs, never>>;
  inputCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionInputCountBigIntArgs, never>>;
  inputValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionInputValueArgs, never>>;
  inputValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumberAsDiv']>, ParentType, ContextType, RequireFields<CardanoTransactionInputValueDecimalArgs, never>>;
  invalidBefore?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  invalidHereafter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionMaximumArgs, 'of'>>;
  metadata?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionMinimumArgs, 'of'>>;
  mintCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionMintCountArgs, never>>;
  mintCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionMintCountBigIntArgs, never>>;
  outputCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputCountArgs, never>>;
  outputCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputCountBigIntArgs, never>>;
  outputValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputValueArgs, never>>;
  outputValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumberAsDiv']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputValueDecimalArgs, never>>;
  txSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionTxSizeArgs, never>>;
  withdrawalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionWithdrawalCountArgs, never>>;
  withdrawalCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionWithdrawalCountBigIntArgs, never>>;
  withdrawalValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionWithdrawalValueArgs, never>>;
  withdrawalValueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumberAsDiv']>, ParentType, ContextType, RequireFields<CardanoTransactionWithdrawalValueDecimalArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoTransactionHashIndexValuesResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoTransactionHashIndexValues'] = ResolversParentTypes['CardanoTransactionHashIndexValues']> = {
  depositValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  depositValueDecimal?: Resolver<ResolversTypes['DecimalNumberAsDiv'], ParentType, ContextType>;
  feeValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  feeValueDecimal?: Resolver<ResolversTypes['DecimalNumberAsDiv'], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  includedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  invalidBefore?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  invalidHereafter?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metadata?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  txSize?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  valueIn?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  valueInDecimal?: Resolver<ResolversTypes['DecimalNumberAsDiv'], ParentType, ContextType>;
  valueOut?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  valueOutDecimal?: Resolver<ResolversTypes['DecimalNumberAsDiv'], ParentType, ContextType>;
  withdrawalValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  withdrawalValueDecimal?: Resolver<ResolversTypes['DecimalNumberAsDiv'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoTransactionInputResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoTransactionInput'] = ResolversParentTypes['CardanoTransactionInput']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionInputAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<CardanoTransactionInputBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionInputCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionInputCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  inputAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<CardanoTransactionInputInputAddressArgs, never>>;
  inputIndex?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionInputInputIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionInputMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionInputMinimumArgs, 'of'>>;
  outputTransaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<CardanoTransactionInputOutputTransactionArgs, never>>;
  source?: Resolver<Maybe<ResolversTypes['CardanoInputSource']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<CardanoTransactionInputTransactionArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionInputValueArgs, never>>;
  valueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumberAsDiv']>, ParentType, ContextType, RequireFields<CardanoTransactionInputValueDecimalArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoTransactionMintResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoTransactionMint'] = ResolversParentTypes['CardanoTransactionMint']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionMintAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<CardanoTransactionMintBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionMintCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionMintCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionMintMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionMintMinimumArgs, 'of'>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<CardanoTransactionMintTransactionArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionMintValueArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CardanoTransactionOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['CardanoTransactionOutput'] = ResolversParentTypes['CardanoTransactionOutput']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputMinimumArgs, 'of'>>;
  outputAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputOutputAddressArgs, never>>;
  outputDirection?: Resolver<Maybe<ResolversTypes['CardanoOutputDirection']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputOutputDirectionArgs, never>>;
  outputIndex?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputOutputIndexArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashIndex']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputTransactionArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputValueArgs, never>>;
  valueDecimal?: Resolver<Maybe<ResolversTypes['DecimalNumberAsDiv']>, ParentType, ContextType, RequireFields<CardanoTransactionOutputValueDecimalArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CoinpathEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['CoinpathEntry'] = ResolversParentTypes['CoinpathEntry']> = {
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  txHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  txValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfluxResolvers<ContextType = any, ParentType extends ResolversParentTypes['Conflux'] = ResolversParentTypes['Conflux']> = {
  address?: Resolver<Array<ResolversTypes['EthereumAddressInfoWithBalance']>, ParentType, ContextType, RequireFields<ConfluxAddressArgs, 'address'>>;
  arguments?: Resolver<Maybe<Array<ResolversTypes['EthereumArguments']>>, ParentType, ContextType, RequireFields<ConfluxArgumentsArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['ConfluxBlocks']>>, ParentType, ContextType, RequireFields<ConfluxBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['EthereumCoinpath']>>, ParentType, ContextType, RequireFields<ConfluxCoinpathArgs, never>>;
  dexTrades?: Resolver<Maybe<Array<ResolversTypes['EthereumDexTrades']>>, ParentType, ContextType, RequireFields<ConfluxDexTradesArgs, never>>;
  smartContractCalls?: Resolver<Maybe<Array<ResolversTypes['EthereumSmartContractCalls']>>, ParentType, ContextType, RequireFields<ConfluxSmartContractCallsArgs, never>>;
  smartContractEvents?: Resolver<Maybe<Array<ResolversTypes['EthereumSmartContractEvent']>>, ParentType, ContextType, RequireFields<ConfluxSmartContractEventsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['ConfluxTransactions']>>, ParentType, ContextType, RequireFields<ConfluxTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['EthereumTransfers']>>, ParentType, ContextType, RequireFields<ConfluxTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfluxBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConfluxBlocks'] = ResolversParentTypes['ConfluxBlocks']> = {
  adaptive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ConfluxBlocksAnyArgs, 'of'>>;
  blame?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  blockPosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ConfluxBlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  epoch?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ConfluxBlocksEpochArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ConfluxBlocksHashArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<ConfluxBlocksHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ConfluxBlocksMaximumArgs, 'of'>>;
  miner?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<ConfluxBlocksMinerArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ConfluxBlocksMinimumArgs, 'of'>>;
  nonce?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  parentHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pivot?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  powerQuality?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  refereeCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxBlocksRefereeCountArgs, never>>;
  refereeCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ConfluxBlocksRefereeCountBigIntArgs, never>>;
  referenceBlockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ConfluxBlocksReferenceBlockHashArgs, never>>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxBlocksSizeArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<ConfluxBlocksTimestampArgs, never>>;
  totalDifficulty?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ConfluxBlocksTotalDifficultyArgs, never>>;
  transactionCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxBlocksTransactionCountArgs, never>>;
  transactionCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ConfluxBlocksTransactionCountBigIntArgs, never>>;
  txHash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ConfluxBlocksTxHashArgs, never>>;
  uncleCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxBlocksUncleCountArgs, never>>;
  uncleCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ConfluxBlocksUncleCountBigIntArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfluxTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConfluxTransactions'] = ResolversParentTypes['ConfluxTransactions']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ConfluxTransactionsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ConfluxTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['BlockInfo']>, ParentType, ContextType, RequireFields<ConfluxTransactionsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ConfluxTransactionsCountBigIntArgs, never>>;
  creates?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<ConfluxTransactionsCreatesArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxTransactionsGasArgs, never>>;
  gasCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<ConfluxTransactionsGasCurrencyArgs, never>>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType, RequireFields<ConfluxTransactionsGasPriceArgs, never>>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ConfluxTransactionsGasValueArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ConfluxTransactionsHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ConfluxTransactionsIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ConfluxTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ConfluxTransactionsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<ConfluxTransactionsSenderArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<ConfluxTransactionsSuccessArgs, never>>;
  to?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<ConfluxTransactionsToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CovidCountryResolvers<ContextType = any, ParentType extends ResolversParentTypes['CovidCountry'] = ResolversParentTypes['CovidCountry']> = {
  areaKm2?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  continent?: Resolver<Maybe<ResolversTypes['Continent']>, ParentType, ContextType>;
  gdp?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  iso2?: Resolver<Maybe<ResolversTypes['CountryCode']>, ParentType, ContextType>;
  iso3?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isoNumeric?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  populationPerKm2?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  populationTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CovidFactResolvers<ContextType = any, ParentType extends ResolversParentTypes['CovidFact'] = ResolversParentTypes['CovidFact']> = {
  confirmed?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CovidFactConfirmedArgs, never>>;
  country?: Resolver<Maybe<ResolversTypes['CovidCountry']>, ParentType, ContextType, RequireFields<CovidFactCountryArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  deaths?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CovidFactDeathsArgs, never>>;
  location?: Resolver<Maybe<ResolversTypes['CovidLocation']>, ParentType, ContextType>;
  recovered?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<CovidFactRecoveredArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CovidHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['CovidHistory'] = ResolversParentTypes['CovidHistory']> = {
  facts?: Resolver<Maybe<Array<ResolversTypes['CovidFact']>>, ParentType, ContextType, RequireFields<CovidHistoryFactsArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CovidLocationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CovidLocation'] = ResolversParentTypes['CovidLocation']> = {
  adminCenter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fipsCode?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  latitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  longitude?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  province?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CurrencyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Currency'] = ResolversParentTypes['Currency']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tokenId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tokenType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateResolvers<ContextType = any, ParentType extends ResolversParentTypes['Date'] = ResolversParentTypes['Date']> = {
  date?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<DateDateArgs, never>>;
  dayOfMonth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dayOfWeek?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  month?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  startOfInterval?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<DateStartOfIntervalArgs, 'unit'>>;
  year?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateTimeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateTime'] = ResolversParentTypes['DateTime']> = {
  dayOfMonth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dayOfWeek?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hour?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  iso8601?: Resolver<ResolversTypes['ISO8601DateTime'], ParentType, ContextType>;
  minute?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  month?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  second?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  time?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<DateTimeTimeArgs, never>>;
  unixtime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  year?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DecimalNumberScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DecimalNumber'], any> {
  name: 'DecimalNumber';
}

export interface DecimalNumberAsDivScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DecimalNumberAsDiv'], any> {
  name: 'DecimalNumberAsDiv';
}

export type ElrondResolvers<ContextType = any, ParentType extends ResolversParentTypes['Elrond'] = ResolversParentTypes['Elrond']> = {
  arguments?: Resolver<Maybe<Array<ResolversTypes['ElrondArgument']>>, ParentType, ContextType, RequireFields<ElrondArgumentsArgs, never>>;
  blockValidators?: Resolver<Maybe<Array<ResolversTypes['ElrondBlockValidator']>>, ParentType, ContextType, RequireFields<ElrondBlockValidatorsArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['ElrondBlock']>>, ParentType, ContextType, RequireFields<ElrondBlocksArgs, never>>;
  callResults?: Resolver<Maybe<Array<ResolversTypes['ElrondCallResult']>>, ParentType, ContextType, RequireFields<ElrondCallResultsArgs, never>>;
  calls?: Resolver<Maybe<Array<ResolversTypes['ElrondCall']>>, ParentType, ContextType, RequireFields<ElrondCallsArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['ElrondCoinpath']>>, ParentType, ContextType, RequireFields<ElrondCoinpathArgs, never>>;
  miniblocks?: Resolver<Maybe<Array<ResolversTypes['ElrondMiniblock']>>, ParentType, ContextType, RequireFields<ElrondMiniblocksArgs, never>>;
  notarizedBlock?: Resolver<Maybe<Array<ResolversTypes['ElrondNotarizedBlock']>>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['ElrondTransaction']>>, ParentType, ContextType, RequireFields<ElrondTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['ElrondTransfer']>>, ParentType, ContextType, RequireFields<ElrondTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondAddressHashResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondAddressHash'] = ResolversParentTypes['ElrondAddressHash']> = {
  hex?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondArgumentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondArgument'] = ResolversParentTypes['ElrondArgument']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondArgumentAnyArgs, 'of'>>;
  call?: Resolver<Maybe<ResolversTypes['CallElrond']>, ParentType, ContextType, RequireFields<ElrondArgumentCallArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondArgumentCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondArgumentCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondArgumentIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondArgumentMaximumArgs, 'of'>>;
  miniblock?: Resolver<Maybe<ResolversTypes['MiniblockElrond']>, ParentType, ContextType, RequireFields<ElrondArgumentMiniblockArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondArgumentMinimumArgs, 'of'>>;
  senderBlock?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondArgumentSenderBlockArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionElrond']>, ParentType, ContextType, RequireFields<ElrondArgumentTransactionArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondArgumentValueArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondBlock'] = ResolversParentTypes['ElrondBlock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  epoch?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockEpochArgs, never>>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockHashArgs, never>>;
  height?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockNonceArgs, never>>;
  previousBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockPreviousBlockHashArgs, never>>;
  proposer?: Resolver<Maybe<ResolversTypes['ElrondAddressHash']>, ParentType, ContextType, RequireFields<ElrondBlockProposerArgs, never>>;
  publicKeyBitmap?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockPublicKeyBitmapArgs, never>>;
  round?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockRoundArgs, never>>;
  shard?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockShardArgs, never>>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockSizeArgs, never>>;
  sizeTxs?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockSizeTxsArgs, never>>;
  stateRootHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockStateRootHashArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockTransactionCountArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondBlockDimensionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondBlockDimension'] = ResolversParentTypes['ElrondBlockDimension']> = {
  epoch?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionEpochArgs, never>>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionHashArgs, never>>;
  height?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionHeightArgs, never>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionNonceArgs, never>>;
  previousBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionPreviousBlockHashArgs, never>>;
  proposer?: Resolver<Maybe<ResolversTypes['ElrondAddressHash']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionProposerArgs, never>>;
  publicKeyBitmap?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionPublicKeyBitmapArgs, never>>;
  round?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionRoundArgs, never>>;
  shard?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionShardArgs, never>>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionSizeArgs, never>>;
  sizeTxs?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionSizeTxsArgs, never>>;
  stateRootHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionStateRootHashArgs, never>>;
  transactionCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockDimensionTransactionCountArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondBlockValidatorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondBlockValidator'] = ResolversParentTypes['ElrondBlockValidator']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockValidatorAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondBlockValidatorBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondBlockValidatorCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondBlockValidatorCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockValidatorMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondBlockValidatorMinimumArgs, 'of'>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validator?: Resolver<Maybe<ResolversTypes['ElrondAddressHash']>, ParentType, ContextType, RequireFields<ElrondBlockValidatorValidatorArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondCallResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondCall'] = ResolversParentTypes['ElrondCall']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallAnyArgs, 'of'>>;
  callDepth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallCallDepthArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondCallCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondCallCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallMaximumArgs, 'of'>>;
  miniblock?: Resolver<Maybe<ResolversTypes['MiniblockElrond']>, ParentType, ContextType, RequireFields<ElrondCallMiniblockArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallMinimumArgs, 'of'>>;
  senderBlock?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondCallSenderBlockArgs, never>>;
  smartContractAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<ElrondCallSmartContractAddressArgs, never>>;
  smartContractMethod?: Resolver<Maybe<ResolversTypes['Method']>, ParentType, ContextType, RequireFields<ElrondCallSmartContractMethodArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionElrond']>, ParentType, ContextType, RequireFields<ElrondCallTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondCallResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondCallResult'] = ResolversParentTypes['ElrondCallResult']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondCallResultCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondCallResultCountBigIntArgs, never>>;
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultDataArgs, never>>;
  dataOperation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultDataOperationArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  gasLimit?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondCallResultGasLimitArgs, never>>;
  gasPrice?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondCallResultGasPriceArgs, never>>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondCallResultIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultMaximumArgs, 'of'>>;
  miniblock?: Resolver<Maybe<ResolversTypes['MiniblockElrond']>, ParentType, ContextType, RequireFields<ElrondCallResultMiniblockArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondCallResultNonceArgs, never>>;
  originTxHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultOriginTxHashArgs, never>>;
  previousTxHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultPreviousTxHashArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<ElrondCallResultReceiverArgs, never>>;
  relayed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultRelayedArgs, never>>;
  relayedValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ElrondCallResultRelayedValueArgs, never>>;
  returnMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultReturnMessageArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<ElrondCallResultSenderArgs, never>>;
  senderBlock?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondCallResultSenderBlockArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionElrond']>, ParentType, ContextType, RequireFields<ElrondCallResultTransactionArgs, never>>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCallResultTypeArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ElrondCallResultValueArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondCoinpath'] = ResolversParentTypes['ElrondCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ElrondCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['ElrondTransactionValueDimension']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondMiniblockResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondMiniblock'] = ResolversParentTypes['ElrondMiniblock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondMiniblockAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondMiniblockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondMiniblockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondMiniblockHashArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondMiniblockMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondMiniblockMinimumArgs, 'of'>>;
  receiverBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondMiniblockReceiverBlockHashArgs, never>>;
  receiverShard?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondMiniblockReceiverShardArgs, never>>;
  senderBlock?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondMiniblockSenderBlockArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondMiniblockTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondNotarizedBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondNotarizedBlock'] = ResolversParentTypes['ElrondNotarizedBlock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockMinimumArgs, 'of'>>;
  notarizedBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondNotarizedBlockNotarizedBlockHashArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondTransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondTransaction'] = ResolversParentTypes['ElrondTransaction']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondTransactionCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondTransactionCountBigIntArgs, never>>;
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionDataArgs, never>>;
  dataOperation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionDataOperationArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ElrondTransactionFeeArgs, never>>;
  gasLimit?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondTransactionGasLimitArgs, never>>;
  gasPrice?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondTransactionGasPriceArgs, never>>;
  gasUsed?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondTransactionGasUsedArgs, never>>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondTransactionIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionMaximumArgs, 'of'>>;
  miniblock?: Resolver<Maybe<ResolversTypes['MiniblockElrond']>, ParentType, ContextType, RequireFields<ElrondTransactionMiniblockArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondTransactionNonceArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<ElrondTransactionReceiverArgs, never>>;
  receiverShard?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondTransactionReceiverShardArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<ElrondTransactionSenderArgs, never>>;
  senderBlock?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondTransactionSenderBlockArgs, never>>;
  senderShard?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondTransactionSenderShardArgs, never>>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionSignatureArgs, never>>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransactionStatusArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ElrondTransactionValueArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondTransactionValueDimensionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondTransactionValueDimension'] = ResolversParentTypes['ElrondTransactionValueDimension']> = {
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElrondTransferResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElrondTransfer'] = ResolversParentTypes['ElrondTransfer']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<ElrondTransferAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransferAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<ElrondTransferCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<ElrondTransferCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<ElrondTransferCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransferMaximumArgs, 'of'>>;
  metadata?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransferMetadataArgs, never>>;
  miniblock?: Resolver<Maybe<ResolversTypes['MiniblockElrond']>, ParentType, ContextType, RequireFields<ElrondTransferMiniblockArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransferMinimumArgs, 'of'>>;
  nftNonce?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransferNftNonceArgs, never>>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ElrondTransferReasonArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<ElrondTransferReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<ElrondTransferSenderArgs, never>>;
  senderBlock?: Resolver<Maybe<ResolversTypes['ElrondBlockDimension']>, ParentType, ContextType, RequireFields<ElrondTransferSenderBlockArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionElrond']>, ParentType, ContextType, RequireFields<ElrondTransferTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EntityResolvers<ContextType = any, ParentType extends ResolversParentTypes['Entity'] = ResolversParentTypes['Entity']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<EntityIdArgs, never>>;
  num?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  realmId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  shardId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosResolvers<ContextType = any, ParentType extends ResolversParentTypes['Eos'] = ResolversParentTypes['Eos']> = {
  address?: Resolver<Array<ResolversTypes['EosAddressInfo']>, ParentType, ContextType, RequireFields<EosAddressArgs, 'address'>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['EosBlocks']>>, ParentType, ContextType, RequireFields<EosBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['EosCoinpath']>>, ParentType, ContextType, RequireFields<EosCoinpathArgs, never>>;
  smartContractCalls?: Resolver<Maybe<Array<ResolversTypes['EosSmartContractCalls']>>, ParentType, ContextType, RequireFields<EosSmartContractCallsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['EosTransactions']>>, ParentType, ContextType, RequireFields<EosTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['EosTransfers']>>, ParentType, ContextType, RequireFields<EosTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosAddressInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosAddressInfo'] = ResolversParentTypes['EosAddressInfo']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['EosSmartContractInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosBlocks'] = ResolversParentTypes['EosBlocks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosBlocksAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EosBlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<EosBlocksHashArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<EosBlocksHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosBlocksMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosBlocksMinimumArgs, 'of'>>;
  producer?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<EosBlocksProducerArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<EosBlocksTimestampArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosCoinpath'] = ResolversParentTypes['EosCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EosCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['EosAddressInfo']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['EosAddressInfo']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosSmartContractResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosSmartContract'] = ResolversParentTypes['EosSmartContract']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  contractType?: Resolver<Maybe<ResolversTypes['SmartContractType']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  protocolType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosSmartContractCallsResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosSmartContractCalls'] = ResolversParentTypes['EosSmartContractCalls']> = {
  actors?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosSmartContractCallsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EosSmartContractCallsBlockArgs, never>>;
  callDepth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  console?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosSmartContractCallsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EosSmartContractCallsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  errorCode?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosSmartContractCallsErrorCodeArgs, never>>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EosSmartContractCallsExternalArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosSmartContractCallsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosSmartContractCallsMinimumArgs, 'of'>>;
  permissions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  receivers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scheduled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EosSmartContractCallsScheduledArgs, never>>;
  smartContract?: Resolver<Maybe<ResolversTypes['EosSmartContract']>, ParentType, ContextType, RequireFields<EosSmartContractCallsSmartContractArgs, never>>;
  smartContractMethod?: Resolver<Maybe<ResolversTypes['Method']>, ParentType, ContextType, RequireFields<EosSmartContractCallsSmartContractMethodArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EosSmartContractCallsSuccessArgs, never>>;
  txFrom?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<EosSmartContractCallsTxFromArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosSmartContractCallsTxHashArgs, never>>;
  txTo?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<EosSmartContractCallsTxToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosSmartContractInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosSmartContractInfo'] = ResolversParentTypes['EosSmartContractInfo']> = {
  contractType?: Resolver<Maybe<ResolversTypes['SmartContractType']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  protocolType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosTransactions'] = ResolversParentTypes['EosTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EosTransactionsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EosTransactionsCountBigIntArgs, never>>;
  cpuUsageUs?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosTransactionsCpuUsageUsArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<EosTransactionsHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosTransactionsIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransactionsMinimumArgs, 'of'>>;
  netUsageWords?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosTransactionsNetUsageWordsArgs, never>>;
  scheduled?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EosTransactionsScheduledArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EosTransactionsSuccessArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EosTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['EosTransfers'] = ResolversParentTypes['EosTransfers']> = {
  actors?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EosTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EosTransfersBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EosTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EosTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<EosTransfersCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  entityId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransfersEntityIdArgs, never>>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EosTransfersExternalArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransfersMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransfersMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<EosTransfersReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<EosTransfersSenderArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EosTransfersSuccessArgs, never>>;
  txFrom?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<EosTransfersTxFromArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EosTransfersTxHashArgs, never>>;
  txTo?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<EosTransfersTxToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum'] = ResolversParentTypes['Ethereum']> = {
  address?: Resolver<Array<ResolversTypes['EthereumAddressInfoWithBalance']>, ParentType, ContextType, RequireFields<EthereumAddressArgs, 'address'>>;
  arguments?: Resolver<Maybe<Array<ResolversTypes['EthereumArguments']>>, ParentType, ContextType, RequireFields<EthereumArgumentsArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['EthereumBlocks']>>, ParentType, ContextType, RequireFields<EthereumBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['EthereumCoinpath']>>, ParentType, ContextType, RequireFields<EthereumCoinpathArgs, never>>;
  dexTrades?: Resolver<Maybe<Array<ResolversTypes['EthereumDexTrades']>>, ParentType, ContextType, RequireFields<EthereumDexTradesArgs, never>>;
  smartContractCalls?: Resolver<Maybe<Array<ResolversTypes['EthereumSmartContractCalls']>>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsArgs, never>>;
  smartContractEvents?: Resolver<Maybe<Array<ResolversTypes['EthereumSmartContractEvent']>>, ParentType, ContextType, RequireFields<EthereumSmartContractEventsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['EthereumTransactions']>>, ParentType, ContextType, RequireFields<EthereumTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['EthereumTransfers']>>, ParentType, ContextType, RequireFields<EthereumTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2Resolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2'] = ResolversParentTypes['Ethereum2']> = {
  attestations?: Resolver<Maybe<Array<ResolversTypes['Ethereum2Attestation']>>, ParentType, ContextType, RequireFields<Ethereum2AttestationsArgs, never>>;
  attesterSlashings?: Resolver<Maybe<Array<ResolversTypes['Ethereum2AttesterSlashing']>>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingsArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['Ethereum2Blocks']>>, ParentType, ContextType, RequireFields<Ethereum2BlocksArgs, never>>;
  deposits?: Resolver<Maybe<Array<ResolversTypes['Ethereum2Deposit']>>, ParentType, ContextType, RequireFields<Ethereum2DepositsArgs, never>>;
  proposerSlashings?: Resolver<Maybe<Array<ResolversTypes['Ethereum2ProposerSlashing']>>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingsArgs, never>>;
  voluntaryExits?: Resolver<Maybe<Array<ResolversTypes['Ethereum2VoluntaryExit']>>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitsArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2AttestationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2Attestation'] = ResolversParentTypes['Ethereum2Attestation']> = {
  aggregationBits?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2AttestationAnyArgs, 'of'>>;
  attestation?: Resolver<ResolversTypes['Ethereum2AttestationInfo'], ParentType, ContextType>;
  attestationIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<Ethereum2AttestationBlockArgs, never>>;
  blockRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<Ethereum2AttestationBlockRootArgs, never>>;
  committeeIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2AttestationCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2AttestationCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  eth1?: Resolver<ResolversTypes['Ethereum2Eth1Info'], ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2AttestationMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2AttestationMinimumArgs, 'of'>>;
  parentRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Ethereum2ValidatorInfo']>, ParentType, ContextType, RequireFields<Ethereum2AttestationProposerArgs, never>>;
  stateRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validator?: Resolver<ResolversTypes['Ethereum2ValidatorInfo'], ParentType, ContextType>;
  validatorInCommitteeIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2AttestationFieldInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2AttestationFieldInfo'] = ResolversParentTypes['Ethereum2AttestationFieldInfo']> = {
  epoch?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  root?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2AttestationInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2AttestationInfo'] = ResolversParentTypes['Ethereum2AttestationInfo']> = {
  beaconBlockRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  epoch?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slot?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['Ethereum2AttestationFieldInfo'], ParentType, ContextType>;
  target?: Resolver<ResolversTypes['Ethereum2AttestationFieldInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2AttesterSlashingResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2AttesterSlashing'] = ResolversParentTypes['Ethereum2AttesterSlashing']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingAnyArgs, 'of'>>;
  attestation?: Resolver<ResolversTypes['Ethereum2AttestationInfo'], ParentType, ContextType>;
  attestationOrder?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  attesterSlashingIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingBlockArgs, never>>;
  blockRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingBlockRootArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  eth1?: Resolver<ResolversTypes['Ethereum2Eth1Info'], ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingMinimumArgs, 'of'>>;
  parentRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Ethereum2ValidatorInfo']>, ParentType, ContextType, RequireFields<Ethereum2AttesterSlashingProposerArgs, never>>;
  stateRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validator?: Resolver<ResolversTypes['Ethereum2ValidatorInfo'], ParentType, ContextType>;
  validatorInAttestationIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2BlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2Blocks'] = ResolversParentTypes['Ethereum2Blocks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2BlocksAnyArgs, 'of'>>;
  attestationsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2BlocksAttestationsCountArgs, never>>;
  attestationsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2BlocksAttestationsCountBigIntArgs, never>>;
  attesterSlashingsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2BlocksAttesterSlashingsCountArgs, never>>;
  attesterSlashingsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2BlocksAttesterSlashingsCountBigIntArgs, never>>;
  blockRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<Ethereum2BlocksBlockRootArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2BlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2BlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  depositsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2BlocksDepositsCountArgs, never>>;
  depositsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2BlocksDepositsCountBigIntArgs, never>>;
  eth1?: Resolver<ResolversTypes['Ethereum2Eth1Info'], ParentType, ContextType>;
  graffiti?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<Ethereum2BlocksHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2BlocksMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2BlocksMinimumArgs, 'of'>>;
  parentRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Ethereum2ValidatorInfo']>, ParentType, ContextType, RequireFields<Ethereum2BlocksProposerArgs, never>>;
  proposerSlashingsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2BlocksProposerSlashingsCountArgs, never>>;
  proposerSlashingsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2BlocksProposerSlashingsCountBigIntArgs, never>>;
  randaoReveal?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stateRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<Ethereum2BlocksTimestampArgs, never>>;
  voluntaryExitsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2BlocksVoluntaryExitsCountArgs, never>>;
  voluntaryExitsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2BlocksVoluntaryExitsCountBigIntArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2DepositResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2Deposit'] = ResolversParentTypes['Ethereum2Deposit']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<Ethereum2DepositAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2DepositAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<Ethereum2DepositBlockArgs, never>>;
  blockRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<Ethereum2DepositBlockRootArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2DepositCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2DepositCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  depositIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  eth1?: Resolver<ResolversTypes['Ethereum2Eth1Info'], ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2DepositMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2DepositMinimumArgs, 'of'>>;
  parentRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proof?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Ethereum2ValidatorInfo']>, ParentType, ContextType, RequireFields<Ethereum2DepositProposerArgs, never>>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stateRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validator?: Resolver<ResolversTypes['Ethereum2ValidatorInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2Eth1InfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2Eth1Info'] = ResolversParentTypes['Ethereum2Eth1Info']> = {
  blockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  depositCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  depositRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2ProposerSlashingResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2ProposerSlashing'] = ResolversParentTypes['Ethereum2ProposerSlashing']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingBlockArgs, never>>;
  blockRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingBlockRootArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  eth1?: Resolver<ResolversTypes['Ethereum2Eth1Info'], ParentType, ContextType>;
  headerOrder?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingMinimumArgs, 'of'>>;
  parentRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Ethereum2ValidatorInfo']>, ParentType, ContextType, RequireFields<Ethereum2ProposerSlashingProposerArgs, never>>;
  proposerSlashingIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slashing?: Resolver<ResolversTypes['Ethereum2SlashingInfo'], ParentType, ContextType>;
  stateRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2SlashingInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2SlashingInfo'] = ResolversParentTypes['Ethereum2SlashingInfo']> = {
  bodyRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  epoch?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  parentRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Ethereum2ValidatorInfo']>, ParentType, ContextType>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slot?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stateRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2ValidatorInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2ValidatorInfo'] = ResolversParentTypes['Ethereum2ValidatorInfo']> = {
  index?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pubkey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  withdrawalCredentials?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Ethereum2VoluntaryExitResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ethereum2VoluntaryExit'] = ResolversParentTypes['Ethereum2VoluntaryExit']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitBlockArgs, never>>;
  blockRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitBlockRootArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  eth1?: Resolver<ResolversTypes['Ethereum2Eth1Info'], ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitMinimumArgs, 'of'>>;
  parentRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  proposer?: Resolver<Maybe<ResolversTypes['Ethereum2ValidatorInfo']>, ParentType, ContextType, RequireFields<Ethereum2VoluntaryExitProposerArgs, never>>;
  signature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stateRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validator?: Resolver<ResolversTypes['Ethereum2ValidatorInfo'], ParentType, ContextType>;
  voluntaryExitEpoch?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  voluntaryExitIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumAddressInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumAddressInfo'] = ResolversParentTypes['EthereumAddressInfo']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['EthereumSmartContractInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumAddressInfoWithBalanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumAddressInfoWithBalance'] = ResolversParentTypes['EthereumAddressInfoWithBalance']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  balance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  balances?: Resolver<Maybe<Array<ResolversTypes['EthereumBalance']>>, ParentType, ContextType, RequireFields<EthereumAddressInfoWithBalanceBalancesArgs, never>>;
  smartContract?: Resolver<Maybe<ResolversTypes['EthereumSmartContractInfoWithAttributes']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumArgumentsResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumArguments'] = ResolversParentTypes['EthereumArguments']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumArgumentsAnyArgs, 'of'>>;
  argument?: Resolver<Maybe<ResolversTypes['ArgumentName']>, ParentType, ContextType, RequireFields<EthereumArgumentsArgumentArgs, never>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EthereumArgumentsBlockArgs, never>>;
  callDepth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  caller?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumArgumentsCallerArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumArgumentsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumArgumentsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EthereumArgumentsExternalArgs, never>>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumArgumentsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumArgumentsMinimumArgs, 'of'>>;
  number?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumArgumentsNumberArgs, never>>;
  reference?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumArgumentsReferenceArgs, never>>;
  smartContract?: Resolver<Maybe<ResolversTypes['EthereumSmartContract']>, ParentType, ContextType, RequireFields<EthereumArgumentsSmartContractArgs, never>>;
  smartContractSignature?: Resolver<Maybe<ResolversTypes['Signature']>, ParentType, ContextType, RequireFields<EthereumArgumentsSmartContractSignatureArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EthereumArgumentsSuccessArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['EthereumTransactionInfo']>, ParentType, ContextType, RequireFields<EthereumArgumentsTransactionArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['ArgumentValue']>, ParentType, ContextType, RequireFields<EthereumArgumentsValueArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumBalanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumBalance'] = ResolversParentTypes['EthereumBalance']> = {
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  history?: Resolver<Maybe<Array<ResolversTypes['EthereumBalanceChange']>>, ParentType, ContextType, RequireFields<EthereumBalanceHistoryArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumBalanceChangeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumBalanceChange'] = ResolversParentTypes['EthereumBalanceChange']> = {
  block?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['ISO8601DateTime']>, ParentType, ContextType>;
  transferAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumBlocks'] = ResolversParentTypes['EthereumBlocks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumBlocksAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumBlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  difficulty?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumBlocksDifficultyArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<EthereumBlocksHashArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<EthereumBlocksHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumBlocksMaximumArgs, 'of'>>;
  miner?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumBlocksMinerArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumBlocksMinimumArgs, 'of'>>;
  nonce?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  parentHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reward?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumBlocksRewardArgs, never>>;
  rewardCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumBlocksSizeArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<EthereumBlocksTimestampArgs, never>>;
  totalDifficulty?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumBlocksTotalDifficultyArgs, never>>;
  transactionCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumBlocksTransactionCountArgs, never>>;
  transactionCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumBlocksTransactionCountBigIntArgs, never>>;
  uncleCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumBlocksUncleCountArgs, never>>;
  uncleCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumBlocksUncleCountBigIntArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumCoinpath'] = ResolversParentTypes['EthereumCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashValue']>, ParentType, ContextType>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['CoinpathEntry']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumDexResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumDex'] = ResolversParentTypes['EthereumDex']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullNameWithId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumDexTradesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumDexTrades'] = ResolversParentTypes['EthereumDexTrades']> = {
  address?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumDexTradesAddressArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumDexTradesAnyArgs, 'of'>>;
  baseAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesBaseAmountArgs, never>>;
  baseCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<EthereumDexTradesBaseCurrencyArgs, never>>;
  block?: Resolver<Maybe<ResolversTypes['BlockExtended']>, ParentType, ContextType, RequireFields<EthereumDexTradesBlockArgs, never>>;
  buyAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesBuyAmountArgs, never>>;
  buyCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<EthereumDexTradesBuyCurrencyArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumDexTradesCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumDexTradesCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  exchange?: Resolver<Maybe<ResolversTypes['EthereumDex']>, ParentType, ContextType, RequireFields<EthereumDexTradesExchangeArgs, never>>;
  gas?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesGasArgs, never>>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType, RequireFields<EthereumDexTradesGasPriceArgs, never>>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesGasValueArgs, never>>;
  maker?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumDexTradesMakerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumDexTradesMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumDexTradesMinimumArgs, 'of'>>;
  price?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesPriceArgs, never>>;
  protocol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumDexTradesProtocolArgs, never>>;
  quoteAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesQuoteAmountArgs, never>>;
  quoteCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<EthereumDexTradesQuoteCurrencyArgs, never>>;
  quotePrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesQuotePriceArgs, never>>;
  sellAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesSellAmountArgs, never>>;
  sellCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<EthereumDexTradesSellCurrencyArgs, never>>;
  side?: Resolver<Maybe<ResolversTypes['TradeSide']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['EthereumSmartContract']>, ParentType, ContextType, RequireFields<EthereumDexTradesSmartContractArgs, never>>;
  taker?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumDexTradesTakerArgs, never>>;
  timeInterval?: Resolver<Maybe<ResolversTypes['TimeInterval']>, ParentType, ContextType>;
  tradeAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumDexTradesTradeAmountArgs, 'in'>>;
  tradeIndex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumDexTradesTradeIndexArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['EthereumTransactionInfoExtended']>, ParentType, ContextType, RequireFields<EthereumDexTradesTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumSmartContractResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumSmartContract'] = ResolversParentTypes['EthereumSmartContract']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  contractType?: Resolver<Maybe<ResolversTypes['SmartContractType']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  protocolType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumSmartContractCallsResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumSmartContractCalls'] = ResolversParentTypes['EthereumSmartContractCalls']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsAnyArgs, 'of'>>;
  arguments?: Resolver<Maybe<Array<ResolversTypes['ArgumentNameValue']>>, ParentType, ContextType>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsBlockArgs, never>>;
  callDepth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  caller?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsCallerArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsExternalArgs, never>>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsGasValueArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsMinimumArgs, 'of'>>;
  smartContract?: Resolver<Maybe<ResolversTypes['EthereumSmartContract']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsSmartContractArgs, never>>;
  smartContractMethod?: Resolver<Maybe<ResolversTypes['Method']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsSmartContractMethodArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsSuccessArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['EthereumTransactionInfo']>, ParentType, ContextType, RequireFields<EthereumSmartContractCallsTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumSmartContractEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumSmartContractEvent'] = ResolversParentTypes['EthereumSmartContractEvent']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventAnyArgs, 'of'>>;
  arguments?: Resolver<Maybe<Array<ResolversTypes['ArgumentNameValue']>>, ParentType, ContextType>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  eventIndex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventMinimumArgs, 'of'>>;
  smartContract?: Resolver<Maybe<ResolversTypes['EthereumSmartContract']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventSmartContractArgs, never>>;
  smartContractEvent?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventSmartContractEventArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['EthereumTransactionInfo']>, ParentType, ContextType, RequireFields<EthereumSmartContractEventTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumSmartContractInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumSmartContractInfo'] = ResolversParentTypes['EthereumSmartContractInfo']> = {
  contractType?: Resolver<Maybe<ResolversTypes['SmartContractType']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  protocolType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumSmartContractInfoWithAttributesResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumSmartContractInfoWithAttributes'] = ResolversParentTypes['EthereumSmartContractInfoWithAttributes']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['SmartContractReadonlyAttribute']>>, ParentType, ContextType>;
  contractType?: Resolver<Maybe<ResolversTypes['SmartContractType']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  protocolType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumTransactionInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumTransactionInfo'] = ResolversParentTypes['EthereumTransactionInfo']> = {
  gas?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  gasValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  txFrom?: Resolver<ResolversTypes['EthereumAddressInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumTransactionInfoExtendedResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumTransactionInfoExtended'] = ResolversParentTypes['EthereumTransactionInfoExtended']> = {
  gas?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  gasValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  nonce?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType>;
  txFrom?: Resolver<ResolversTypes['EthereumAddressInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumTransactions'] = ResolversParentTypes['EthereumTransactions']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumTransactionsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EthereumTransactionsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumTransactionsCountBigIntArgs, never>>;
  creates?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumTransactionsCreatesArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumTransactionsGasArgs, never>>;
  gasCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<EthereumTransactionsGasCurrencyArgs, never>>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType, RequireFields<EthereumTransactionsGasPriceArgs, never>>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumTransactionsGasValueArgs, never>>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<EthereumTransactionsHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumTransactionsIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumTransactionsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumTransactionsSenderArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EthereumTransactionsSuccessArgs, never>>;
  to?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumTransactionsToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EthereumTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['EthereumTransfers'] = ResolversParentTypes['EthereumTransfers']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<EthereumTransfersBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<EthereumTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<EthereumTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<EthereumTransfersCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  entityId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumTransfersEntityIdArgs, never>>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EthereumTransfersExternalArgs, never>>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<EthereumTransfersGasValueArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<EthereumTransfersMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumTransfersReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType, RequireFields<EthereumTransfersSenderArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<EthereumTransfersSuccessArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['EthereumTransactionInfo']>, ParentType, ContextType, RequireFields<EthereumTransfersTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventResolvers<ContextType = any, ParentType extends ResolversParentTypes['Event'] = ResolversParentTypes['Event']> = {
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signatureHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalAction'] = ResolversParentTypes['ExternalAction']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilecoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['Filecoin'] = ResolversParentTypes['Filecoin']> = {
  blocks?: Resolver<Maybe<Array<ResolversTypes['FilecoinBlock']>>, ParentType, ContextType, RequireFields<FilecoinBlocksArgs, never>>;
  calls?: Resolver<Maybe<Array<ResolversTypes['FilecoinCalls']>>, ParentType, ContextType, RequireFields<FilecoinCallsArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['FilecoinCoinpath']>>, ParentType, ContextType, RequireFields<FilecoinCoinpathArgs, never>>;
  messages?: Resolver<Maybe<Array<ResolversTypes['FilecoinMessages']>>, ParentType, ContextType, RequireFields<FilecoinMessagesArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['FilecoinTransfers']>>, ParentType, ContextType, RequireFields<FilecoinTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilecoinBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilecoinBlock'] = ResolversParentTypes['FilecoinBlock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinBlockAnyArgs, 'of'>>;
  blockSig?: Resolver<Maybe<ResolversTypes['NameWithId']>, ParentType, ContextType>;
  blsAggregate?: Resolver<Maybe<ResolversTypes['NameWithId']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinBlockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<FilecoinBlockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  electionProof?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  forkSignalling?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<FilecoinBlockHashArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<FilecoinBlockHeightArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinBlockIndexArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinBlockMaximumArgs, 'of'>>;
  messageCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinBlockMessageCountArgs, never>>;
  messageCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<FilecoinBlockMessageCountBigIntArgs, never>>;
  messages?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  miner?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<FilecoinBlockMinerArgs, never>>;
  minerTips?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinBlockMinerTipsArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinBlockMinimumArgs, 'of'>>;
  parentMessageReceipts?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentStateRoot?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parentWeight?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  reward?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinBlockRewardArgs, never>>;
  ticket?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<FilecoinBlockTimestampArgs, never>>;
  totalReward?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinBlockTotalRewardArgs, never>>;
  winCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinBlockWinCountArgs, never>>;
  winCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<FilecoinBlockWinCountBigIntArgs, never>>;
  wincount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilecoinCallsResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilecoinCalls'] = ResolversParentTypes['FilecoinCalls']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinCallsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinCallsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<FilecoinCallsBlockArgs, never>>;
  callHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  callPath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinCallsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<FilecoinCallsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  exitCode?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinCallsGasArgs, never>>;
  gasFeeCap?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasLimit?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasPremium?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinCallsHashArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinCallsMaximumArgs, 'of'>>;
  messageMethod?: Resolver<Maybe<ResolversTypes['NameWithId']>, ParentType, ContextType, RequireFields<FilecoinCallsMessageMethodArgs, never>>;
  method?: Resolver<Maybe<ResolversTypes['NameWithId']>, ParentType, ContextType, RequireFields<FilecoinCallsMethodArgs, never>>;
  minedBlock?: Resolver<Maybe<ResolversTypes['FilecoinMinedBlock']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinCallsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  receiver?: Resolver<Maybe<ResolversTypes['AddressWithAccount']>, ParentType, ContextType, RequireFields<FilecoinCallsReceiverArgs, never>>;
  returnValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['AddressWithAccount']>, ParentType, ContextType, RequireFields<FilecoinCallsSenderArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<FilecoinCallsSuccessArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilecoinCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilecoinCoinpath'] = ResolversParentTypes['FilecoinCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinCoinpathMaximumArgs, 'of'>>;
  message?: Resolver<Maybe<ResolversTypes['TransactionHashValue']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilecoinMessagesResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilecoinMessages'] = ResolversParentTypes['FilecoinMessages']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinMessagesAnyArgs, 'of'>>;
  baseFeeBurn?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesBaseFeeBurnArgs, never>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<FilecoinMessagesBlockArgs, never>>;
  burned?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesBurnedArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinMessagesCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<FilecoinMessagesCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  exitCode?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinMessagesGasArgs, never>>;
  gasFeeCap?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasLimit?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasPremium?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinMessagesHashArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinMessagesMaximumArgs, 'of'>>;
  method?: Resolver<Maybe<ResolversTypes['NameWithId']>, ParentType, ContextType, RequireFields<FilecoinMessagesMethodArgs, never>>;
  minedBlock?: Resolver<Maybe<ResolversTypes['FilecoinMinedBlock']>, ParentType, ContextType>;
  minerPenalty?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesMinerPenaltyArgs, never>>;
  minerTip?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesMinerTipArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinMessagesMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  overEstimationBurn?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesOverEstimationBurnArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['AddressWithAccount']>, ParentType, ContextType, RequireFields<FilecoinMessagesReceiverArgs, never>>;
  refund?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesRefundArgs, never>>;
  returnValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['AddressWithAccount']>, ParentType, ContextType, RequireFields<FilecoinMessagesSenderArgs, never>>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signatureType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signedHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<FilecoinMessagesSuccessArgs, never>>;
  totalCost?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinMessagesTotalCostArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilecoinMinedBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilecoinMinedBlock'] = ResolversParentTypes['FilecoinMinedBlock']> = {
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  miner?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilecoinTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilecoinTransfers'] = ResolversParentTypes['FilecoinTransfers']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<FilecoinTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['BlockExtended']>, ParentType, ContextType, RequireFields<FilecoinTransfersBlockArgs, never>>;
  callHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  callPath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<FilecoinTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<FilecoinTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinTransfersHashArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinTransfersMaximumArgs, 'of'>>;
  messageMethod?: Resolver<Maybe<ResolversTypes['NameWithId']>, ParentType, ContextType, RequireFields<FilecoinTransfersMessageMethodArgs, never>>;
  method?: Resolver<Maybe<ResolversTypes['NameWithId']>, ParentType, ContextType, RequireFields<FilecoinTransfersMethodArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FilecoinTransfersMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<FilecoinTransfersReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<FilecoinTransfersSenderArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<FilecoinTransfersTimestampArgs, never>>;
  transferType?: Resolver<Maybe<ResolversTypes['FilecoinTransferType']>, ParentType, ContextType, RequireFields<FilecoinTransfersTransferTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Harmony'] = ResolversParentTypes['Harmony']> = {
  arguments?: Resolver<Maybe<Array<ResolversTypes['HarmonyArguments']>>, ParentType, ContextType, RequireFields<HarmonyArgumentsArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['HarmonyBlocks']>>, ParentType, ContextType, RequireFields<HarmonyBlocksArgs, never>>;
  smartContractCalls?: Resolver<Maybe<Array<ResolversTypes['HarmonySmartContractCalls']>>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsArgs, never>>;
  smartContractEvents?: Resolver<Maybe<Array<ResolversTypes['HarmonySmartContractEvents']>>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsArgs, never>>;
  stakingTransactions?: Resolver<Maybe<Array<ResolversTypes['HarmonyStakingTransactions']>>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['HarmonyTransactions']>>, ParentType, ContextType, RequireFields<HarmonyTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['HarmonyTransfers']>>, ParentType, ContextType, RequireFields<HarmonyTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonyArgumentsResolvers<ContextType = any, ParentType extends ResolversParentTypes['HarmonyArguments'] = ResolversParentTypes['HarmonyArguments']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsAnyArgs, 'of'>>;
  argIndex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  argType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  argument?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsArgumentArgs, never>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsBlockHashArgs, never>>;
  callPath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonyArgumentsCountArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  epoch?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyArgumentsLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  receiver?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsSenderArgs, never>>;
  shardId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  signatureId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  smartContractAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyArgumentsSmartContractAddressArgs, never>>;
  smartContractId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyArgumentsSmartContractIdArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonyBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['HarmonyBlocks'] = ResolversParentTypes['HarmonyBlocks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyBlocksAnyArgs, 'of'>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyBlocksBlockHashArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonyBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyBlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  difficulty?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  epoch?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  extraData?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gasLimit?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasUsed?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyBlocksLedgerArgs, never>>;
  logsBloom?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyBlocksMaximumArgs, 'of'>>;
  miner?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyBlocksMinerArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyBlocksMinimumArgs, 'of'>>;
  mixHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  parentHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyBlocksParentHashArgs, never>>;
  receiptsRoot?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shardId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  size?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyBlocksSizeArgs, never>>;
  stakingTransactionsCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyBlocksStakingTransactionsCountArgs, never>>;
  stateRoot?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyBlocksTransactionCountArgs, never>>;
  transactionsRoot?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unclesCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyBlocksUnclesCountArgs, never>>;
  viewId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyBlocksViewIdArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonySmartContractCallsResolvers<ContextType = any, ParentType extends ResolversParentTypes['HarmonySmartContractCalls'] = ResolversParentTypes['HarmonySmartContractCalls']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsBlockArgs, never>>;
  callPath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsExternalArgs, never>>;
  gas?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsGasArgs, never>>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType, RequireFields<HarmonySmartContractCallsGasPriceArgs, never>>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsGasValueArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsNonceArgs, never>>;
  smartContractMethod?: Resolver<Maybe<ResolversTypes['Method']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsSmartContractMethodArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsSuccessArgs, never>>;
  txFrom?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsTxFromArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsTxHashArgs, never>>;
  txSender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsTxSenderArgs, never>>;
  txTo?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<HarmonySmartContractCallsTxToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonySmartContractEventsResolvers<ContextType = any, ParentType extends ResolversParentTypes['HarmonySmartContractEvents'] = ResolversParentTypes['HarmonySmartContractEvents']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  epoch?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsEpochArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsNonceArgs, never>>;
  smartContractEvent?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsSmartContractEventArgs, never>>;
  txFrom?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsTxFromArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsTxHashArgs, never>>;
  txTo?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<HarmonySmartContractEventsTxToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonyStakingTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['HarmonyStakingTransactions'] = ResolversParentTypes['HarmonyStakingTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsCountBigIntArgs, never>>;
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  delegatorAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsDelegatorAddressArgs, never>>;
  epoch?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasPrice?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  shardId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsStatusArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsSuccessArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsTransactionHashArgs, never>>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsTransactionTypeArgs, never>>;
  validatorAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyStakingTransactionsValidatorAddressArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonyTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['HarmonyTransactions'] = ResolversParentTypes['HarmonyTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsAnyArgs, 'of'>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsBlockHashArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonyTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyTransactionsCountBigIntArgs, never>>;
  creates?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsCreatesArgs, never>>;
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  epoch?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasPrice?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gasValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyTransactionsLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  reciever?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsRecieverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsSenderArgs, never>>;
  shardId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonyTransactionsStatusArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonyTransactionsSuccessArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransactionsTransactionHashArgs, never>>;
  transactionIndex?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonyTransactionsTransactionIndexArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HarmonyTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['HarmonyTransfers'] = ResolversParentTypes['HarmonyTransfers']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersAnyArgs, 'of'>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersBlockHashArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonyTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  epoch?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonyTransfersExternalArgs, never>>;
  gas?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  gasPrice?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gasValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HarmonyTransfersLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersMinimumArgs, 'of'>>;
  nonce?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersSenderArgs, never>>;
  shardId?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonyTransfersStatusArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HarmonyTransfersSuccessArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersTransactionHashArgs, never>>;
  transactionIndex?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HarmonyTransfersTransactionIndexArgs, never>>;
  transferFrom?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersTransferFromArgs, never>>;
  transferTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HarmonyTransfersTransferToArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaResolvers<ContextType = any, ParentType extends ResolversParentTypes['Hedera'] = ResolversParentTypes['Hedera']> = {
  arguments?: Resolver<Maybe<Array<ResolversTypes['HederaArgument']>>, ParentType, ContextType, RequireFields<HederaArgumentsArgs, never>>;
  calls?: Resolver<Maybe<Array<ResolversTypes['HederaCall']>>, ParentType, ContextType, RequireFields<HederaCallsArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['HederaCoinpath']>>, ParentType, ContextType, RequireFields<HederaCoinpathArgs, never>>;
  inputs?: Resolver<Maybe<Array<ResolversTypes['HederaInput']>>, ParentType, ContextType, RequireFields<HederaInputsArgs, never>>;
  messages?: Resolver<Maybe<Array<ResolversTypes['HederaMessage']>>, ParentType, ContextType, RequireFields<HederaMessagesArgs, never>>;
  outputs?: Resolver<Maybe<Array<ResolversTypes['HederaOutput']>>, ParentType, ContextType, RequireFields<HederaOutputsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['HederaTransaction']>>, ParentType, ContextType, RequireFields<HederaTransactionsArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaArgumentResolvers<ContextType = any, ParentType extends ResolversParentTypes['HederaArgument'] = ResolversParentTypes['HederaArgument']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaArgumentAnyArgs, 'of'>>;
  argtype?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  argument?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  chargedTxFee?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  consensusTimestamp?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HederaArgumentCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HederaArgumentCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  feeCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaArgumentInitialBalanceArgs, never>>;
  maxFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaArgumentMaxFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaArgumentMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaArgumentMinimumArgs, 'of'>>;
  nodeAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  payerAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['TransactionResult']>, ParentType, ContextType, RequireFields<HederaArgumentResultArgs, never>>;
  smartContractEntity?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HederaArgumentSuccessArgs, never>>;
  transactionBytes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaArgumentTransactionFeeArgs, never>>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaArgumentTransactionHashArgs, never>>;
  transactionValidDurationInSec?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  validStart?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType, RequireFields<HederaArgumentValidStartArgs, never>>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaCallResolvers<ContextType = any, ParentType extends ResolversParentTypes['HederaCall'] = ResolversParentTypes['HederaCall']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCallAnyArgs, 'of'>>;
  callInput?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCallCallInputArgs, never>>;
  callResult?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCallCallResultArgs, never>>;
  chargedTxFee?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  consensusTimestamp?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HederaCallCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HederaCallCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  feeCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HederaCallGasArgs, never>>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaCallInitialBalanceArgs, never>>;
  maxFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaCallMaxFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCallMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCallMinimumArgs, 'of'>>;
  nodeAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  payerAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['TransactionResult']>, ParentType, ContextType, RequireFields<HederaCallResultArgs, never>>;
  smartContractEntity?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HederaCallSuccessArgs, never>>;
  transactionBytes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaCallTransactionFeeArgs, never>>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCallTransactionHashArgs, never>>;
  transactionValidDurationInSec?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  validStart?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType, RequireFields<HederaCallValidStartArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['HederaCoinpath'] = ResolversParentTypes['HederaCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['CoinpathEntry']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaInputResolvers<ContextType = any, ParentType extends ResolversParentTypes['HederaInput'] = ResolversParentTypes['HederaInput']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaInputAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaInputAnyArgs, 'of'>>;
  consensusTimestamp?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HederaInputCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HederaInputCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<HederaInputCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['Entity']>, ParentType, ContextType, RequireFields<HederaInputEntityArgs, never>>;
  feeCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaInputInitialBalanceArgs, never>>;
  maxFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaInputMaxFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaInputMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaInputMinimumArgs, 'of'>>;
  nodeAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  payerAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['TransactionResult']>, ParentType, ContextType, RequireFields<HederaInputResultArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HederaInputSuccessArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaInputTransactionFeeArgs, never>>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaInputTransactionHashArgs, never>>;
  transactionValidDurationInSec?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  transferEntity?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  validStart?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType, RequireFields<HederaInputValidStartArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['HederaMessage'] = ResolversParentTypes['HederaMessage']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaMessageAnyArgs, 'of'>>;
  consensusTimestamp?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HederaMessageCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HederaMessageCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['Entity']>, ParentType, ContextType, RequireFields<HederaMessageEntityArgs, never>>;
  feeCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaMessageInitialBalanceArgs, never>>;
  maxFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaMessageMaxFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaMessageMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaMessageMinimumArgs, 'of'>>;
  nodeAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  payerAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['TransactionResult']>, ParentType, ContextType, RequireFields<HederaMessageResultArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HederaMessageSuccessArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  topicRunningHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaMessageTopicRunningHashArgs, never>>;
  topicSequenceNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaMessageTopicSequenceNumberArgs, never>>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaMessageTransactionFeeArgs, never>>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaMessageTransactionHashArgs, never>>;
  transactionValidDurationInSec?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  validStart?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType, RequireFields<HederaMessageValidStartArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['HederaOutput'] = ResolversParentTypes['HederaOutput']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaOutputAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaOutputAnyArgs, 'of'>>;
  consensusTimestamp?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HederaOutputCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HederaOutputCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<HederaOutputCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['Entity']>, ParentType, ContextType, RequireFields<HederaOutputEntityArgs, never>>;
  feeCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaOutputInitialBalanceArgs, never>>;
  maxFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaOutputMaxFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaOutputMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaOutputMinimumArgs, 'of'>>;
  nodeAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  payerAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['TransactionResult']>, ParentType, ContextType, RequireFields<HederaOutputResultArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HederaOutputSuccessArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaOutputTransactionFeeArgs, never>>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaOutputTransactionHashArgs, never>>;
  transactionValidDurationInSec?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  transferEntity?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  validStart?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType, RequireFields<HederaOutputValidStartArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HederaTransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['HederaTransaction'] = ResolversParentTypes['HederaTransaction']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaTransactionAnyArgs, 'of'>>;
  consensusTimestamp?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<HederaTransactionCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<HederaTransactionCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  entity?: Resolver<Maybe<ResolversTypes['Entity']>, ParentType, ContextType, RequireFields<HederaTransactionEntityArgs, never>>;
  feeCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaTransactionInitialBalanceArgs, never>>;
  maxFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaTransactionMaxFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaTransactionMaximumArgs, 'of'>>;
  memo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaTransactionMinimumArgs, 'of'>>;
  nodeAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  payerAccount?: Resolver<Maybe<ResolversTypes['Account']>, ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['TransactionResult']>, ParentType, ContextType, RequireFields<HederaTransactionResultArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<HederaTransactionSuccessArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionBytes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<HederaTransactionTransactionFeeArgs, never>>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<HederaTransactionTransactionHashArgs, never>>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  transactionValidDurationInSec?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  validStart?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType, RequireFields<HederaTransactionValidStartArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface Iso8601DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601Date'], any> {
  name: 'ISO8601Date';
}

export interface Iso8601DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601DateTime'], any> {
  name: 'ISO8601DateTime';
}

export type InputScriptResolvers<ContextType = any, ParentType extends ResolversParentTypes['InputScript'] = ResolversParentTypes['InputScript']> = {
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shortPattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  simplePattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['BitcoinInputScriptType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LibraResolvers<ContextType = any, ParentType extends ResolversParentTypes['Libra'] = ResolversParentTypes['Libra']> = {
  blocks?: Resolver<Maybe<Array<ResolversTypes['LibraBlock']>>, ParentType, ContextType, RequireFields<LibraBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['LibraCoinpath']>>, ParentType, ContextType, RequireFields<LibraCoinpathArgs, never>>;
  mints?: Resolver<Maybe<Array<ResolversTypes['LibraMints']>>, ParentType, ContextType, RequireFields<LibraMintsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['LibraTransactions']>>, ParentType, ContextType, RequireFields<LibraTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['LibraTransfers']>>, ParentType, ContextType, RequireFields<LibraTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LibraBlockResolvers<ContextType = any, ParentType extends ResolversParentTypes['LibraBlock'] = ResolversParentTypes['LibraBlock']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraBlockAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<LibraBlockCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<LibraBlockCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  gasUsed?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<LibraBlockGasUsedArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<LibraBlockHeightArgs, never>>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraBlockMaximumArgs, 'of'>>;
  metadata?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraBlockMetadataArgs, never>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraBlockMinimumArgs, 'of'>>;
  proposer?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<LibraBlockProposerArgs, never>>;
  sequenceNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  statusName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<LibraBlockTimestampArgs, never>>;
  version?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<LibraBlockVersionArgs, never>>;
  versionHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vmStatus?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LibraCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['LibraCoinpath'] = ResolversParentTypes['LibraCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<LibraCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['LibraTransactionValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LibraMintsResolvers<ContextType = any, ParentType extends ResolversParentTypes['LibraMints'] = ResolversParentTypes['LibraMints']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<LibraMintsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraMintsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<LibraMintsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<LibraMintsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<LibraMintsCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<LibraMintsCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraMintsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraMintsMinimumArgs, 'of'>>;
  minter?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<LibraMintsMinterArgs, never>>;
  sequenceNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  statusName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<LibraMintsSuccessArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<LibraMintsTimestampArgs, never>>;
  version?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<LibraMintsVersionArgs, never>>;
  versionHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vmStatus?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LibraTransactionValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['LibraTransactionValue'] = ResolversParentTypes['LibraTransactionValue']> = {
  value?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LibraTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['LibraTransactions'] = ResolversParentTypes['LibraTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<LibraTransactionsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<LibraTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<LibraTransactionsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  expirationTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<LibraTransactionsGasArgs, never>>;
  gasCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<LibraTransactionsGasCurrencyArgs, never>>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType, RequireFields<LibraTransactionsGasPriceArgs, never>>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<LibraTransactionsGasValueArgs, never>>;
  maxGasAmount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransactionsMinimumArgs, 'of'>>;
  publicKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  scriptHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransactionsScriptHashArgs, never>>;
  scriptType?: Resolver<Maybe<ResolversTypes['ScriptTypeSelectorSelector']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<LibraTransactionsSenderArgs, never>>;
  sequenceNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signatureScheme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statusName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<LibraTransactionsSuccessArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<LibraTransactionsTimestampArgs, never>>;
  version?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<LibraTransactionsVersionArgs, never>>;
  versionHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vmStatus?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LibraTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['LibraTransfers'] = ResolversParentTypes['LibraTransfers']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<LibraTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<LibraTransfersBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<LibraTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<LibraTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<LibraTransfersCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  expirationTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  gas?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<LibraTransfersGasArgs, never>>;
  gasCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<LibraTransfersGasCurrencyArgs, never>>;
  gasPrice?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  gasValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<LibraTransfersGasValueArgs, never>>;
  maxGasAmount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransfersMinimumArgs, 'of'>>;
  publicKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<LibraTransfersReceiverArgs, never>>;
  scriptHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LibraTransfersScriptHashArgs, never>>;
  scriptType?: Resolver<Maybe<ResolversTypes['ScriptTypeSelectorSelector']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<LibraTransfersSenderArgs, never>>;
  sequenceNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signatureScheme?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  statusName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<LibraTransfersSuccessArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<LibraTransfersTimestampArgs, never>>;
  txSender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<LibraTransfersTxSenderArgs, never>>;
  version?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<LibraTransfersVersionArgs, never>>;
  versionHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vmStatus?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LogResolvers<ContextType = any, ParentType extends ResolversParentTypes['Log'] = ResolversParentTypes['Log']> = {
  consumed?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  instruction?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  logs?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  result?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  totalGas?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MethodResolvers<ContextType = any, ParentType extends ResolversParentTypes['Method'] = ResolversParentTypes['Method']> = {
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signatureHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MiniblockElrondResolvers<ContextType = any, ParentType extends ResolversParentTypes['MiniblockElrond'] = ResolversParentTypes['MiniblockElrond']> = {
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MiniblockElrondHashArgs, never>>;
  receiverBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MiniblockElrondReceiverBlockHashArgs, never>>;
  receiverShard?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MiniblockElrondReceiverShardArgs, never>>;
  type?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MiniblockElrondTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NameWithIdResolvers<ContextType = any, ParentType extends ResolversParentTypes['NameWithId'] = ResolversParentTypes['NameWithId']> = {
  id?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OffchainResolvers<ContextType = any, ParentType extends ResolversParentTypes['Offchain'] = ResolversParentTypes['Offchain']> = {
  covid?: Resolver<Maybe<ResolversTypes['CovidHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OutputScriptResolvers<ContextType = any, ParentType extends ResolversParentTypes['OutputScript'] = ResolversParentTypes['OutputScript']> = {
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  short?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  simplePattern?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['BitcoinOutputScriptType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProgramResolvers<ContextType = any, ParentType extends ResolversParentTypes['Program'] = ResolversParentTypes['Program']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parsedName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  algorand?: Resolver<Maybe<ResolversTypes['Algorand']>, ParentType, ContextType, RequireFields<QueryAlgorandArgs, never>>;
  binance?: Resolver<Maybe<ResolversTypes['Binance']>, ParentType, ContextType>;
  bitcoin?: Resolver<Maybe<ResolversTypes['Bitcoin']>, ParentType, ContextType, RequireFields<QueryBitcoinArgs, never>>;
  cardano?: Resolver<Maybe<ResolversTypes['Cardano']>, ParentType, ContextType, RequireFields<QueryCardanoArgs, never>>;
  conflux?: Resolver<Maybe<ResolversTypes['Conflux']>, ParentType, ContextType, RequireFields<QueryConfluxArgs, never>>;
  diem?: Resolver<Maybe<ResolversTypes['Libra']>, ParentType, ContextType, RequireFields<QueryDiemArgs, never>>;
  elrond?: Resolver<Maybe<ResolversTypes['Elrond']>, ParentType, ContextType, RequireFields<QueryElrondArgs, never>>;
  eos?: Resolver<Maybe<ResolversTypes['Eos']>, ParentType, ContextType, RequireFields<QueryEosArgs, never>>;
  ethereum?: Resolver<Maybe<ResolversTypes['Ethereum']>, ParentType, ContextType, RequireFields<QueryEthereumArgs, never>>;
  ethereum2?: Resolver<Maybe<ResolversTypes['Ethereum2']>, ParentType, ContextType, RequireFields<QueryEthereum2Args, never>>;
  filecoin?: Resolver<Maybe<ResolversTypes['Filecoin']>, ParentType, ContextType, RequireFields<QueryFilecoinArgs, never>>;
  harmony?: Resolver<Maybe<ResolversTypes['Harmony']>, ParentType, ContextType, RequireFields<QueryHarmonyArgs, never>>;
  hedera?: Resolver<Maybe<ResolversTypes['Hedera']>, ParentType, ContextType, RequireFields<QueryHederaArgs, never>>;
  offchain?: Resolver<Maybe<ResolversTypes['Offchain']>, ParentType, ContextType>;
  ripple?: Resolver<Maybe<ResolversTypes['Ripple']>, ParentType, ContextType, RequireFields<QueryRippleArgs, never>>;
  search?: Resolver<Maybe<Array<ResolversTypes['Result']>>, ParentType, ContextType, RequireFields<QuerySearchArgs, 'string'>>;
  solana?: Resolver<Maybe<ResolversTypes['Solana']>, ParentType, ContextType, RequireFields<QuerySolanaArgs, never>>;
  stellar?: Resolver<Maybe<ResolversTypes['Stellar']>, ParentType, ContextType, RequireFields<QueryStellarArgs, never>>;
  tron?: Resolver<Maybe<ResolversTypes['Tron']>, ParentType, ContextType, RequireFields<QueryTronArgs, never>>;
};

export type ReceiverResolvers<ContextType = any, ParentType extends ResolversParentTypes['Receiver'] = ResolversParentTypes['Receiver']> = {
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mintAccount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['Result'] = ResolversParentTypes['Result']> = {
  network?: Resolver<ResolversTypes['BlockchainNetwork'], ParentType, ContextType>;
  subject?: Resolver<ResolversTypes['Subject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ripple'] = ResolversParentTypes['Ripple']> = {
  accountRoots?: Resolver<Maybe<Array<ResolversTypes['RippleAccountRoots']>>, ParentType, ContextType, RequireFields<RippleAccountRootsArgs, never>>;
  balances?: Resolver<Maybe<Array<ResolversTypes['RippleBalances']>>, ParentType, ContextType, RequireFields<RippleBalancesArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['RippleBlocks']>>, ParentType, ContextType, RequireFields<RippleBlocksArgs, never>>;
  checks?: Resolver<Maybe<Array<ResolversTypes['RippleChecks']>>, ParentType, ContextType, RequireFields<RippleChecksArgs, never>>;
  escrows?: Resolver<Maybe<Array<ResolversTypes['RippleEscrows']>>, ParentType, ContextType, RequireFields<RippleEscrowsArgs, never>>;
  offers?: Resolver<Maybe<Array<ResolversTypes['RippleOffers']>>, ParentType, ContextType, RequireFields<RippleOffersArgs, never>>;
  payments?: Resolver<Maybe<Array<ResolversTypes['RipplePayments']>>, ParentType, ContextType, RequireFields<RipplePaymentsArgs, never>>;
  rippleStates?: Resolver<Maybe<Array<ResolversTypes['RippleRippleStates']>>, ParentType, ContextType, RequireFields<RippleRippleStatesArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['RippleTransactions']>>, ParentType, ContextType, RequireFields<RippleTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['RippleTransfers']>>, ParentType, ContextType, RequireFields<RippleTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleAccountRootsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleAccountRoots'] = ResolversParentTypes['RippleAccountRoots']> = {
  account?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsAccountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsAnyArgs, 'of'>>;
  balance?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleAccountRootsBalanceArgs, never>>;
  blockHeight?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleAccountRootsBlockHeightArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleAccountRootsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleAccountRootsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  domain?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsDomainArgs, never>>;
  flags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsFlagsArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsMinimumArgs, 'of'>>;
  operation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsOperationArgs, never>>;
  ownerCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleAccountRootsOwnerCountArgs, never>>;
  prevBalance?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleAccountRootsPrevBalanceArgs, never>>;
  previousTxnId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsPreviousTxnIdArgs, never>>;
  previousTxnLedgerSeq?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleAccountRootsPreviousTxnLedgerSeqArgs, never>>;
  sequence?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleAccountRootsSequenceArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleAccountRootsTransactionTypeArgs, never>>;
  transferRate?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleAccountRootsTransferRateArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleBalancesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleBalances'] = ResolversParentTypes['RippleBalances']> = {
  account?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesAccountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesAnyArgs, 'of'>>;
  balance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleBalancesBalanceArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleBalancesCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleBalancesCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  flags?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleBalancesFlagsArgs, never>>;
  issuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesIssuerArgs, never>>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleBalancesLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesMinimumArgs, 'of'>>;
  prevBalance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleBalancesPrevBalanceArgs, never>>;
  prevLedgerSeq?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleBalancesPrevLedgerSeqArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesTransactionHashArgs, never>>;
  transactionSender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesTransactionSenderArgs, never>>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBalancesTransactionTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleBlocks'] = ResolversParentTypes['RippleBlocks']> = {
  accountHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBlocksAccountHashArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBlocksAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleBlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleBlocksLedgerArgs, never>>;
  ledgerHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBlocksLedgerHashArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBlocksMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBlocksMinimumArgs, 'of'>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  totalCoins?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleBlocksTransactionHashArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleChecksResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleChecks'] = ResolversParentTypes['RippleChecks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksAnyArgs, 'of'>>;
  blockHeight?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksBlockHeightArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleChecksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  destination?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksDestinationArgs, never>>;
  destinationTag?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksDestinationTagArgs, never>>;
  expiration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksExpirationArgs, never>>;
  flags?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksFlagsArgs, never>>;
  invoiceId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksInvoiceIdArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksMinimumArgs, 'of'>>;
  operation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksOperationArgs, never>>;
  previousTxnId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksPreviousTxnIdArgs, never>>;
  previousTxnLedgerSeq?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksPreviousTxnLedgerSeqArgs, never>>;
  sendMax?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksSendMaxArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksSenderArgs, never>>;
  sequence?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksSequenceArgs, never>>;
  sourceTag?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleChecksSourceTagArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleChecksTransactionTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleEscrowsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleEscrows'] = ResolversParentTypes['RippleEscrows']> = {
  amount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsAnyArgs, 'of'>>;
  blockHeight?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsBlockHeightArgs, never>>;
  cancelAfter?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsCancelAfterArgs, never>>;
  condition?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsConditionArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleEscrowsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  destination?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsDestinationArgs, never>>;
  destinationTag?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsDestinationTagArgs, never>>;
  finishedAfter?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsFinishedAfterArgs, never>>;
  flags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsFlagsArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsMinimumArgs, 'of'>>;
  operation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsOperationArgs, never>>;
  previousTxnId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsPreviousTxnIdArgs, never>>;
  previousTxnLedgerSeq?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsPreviousTxnLedgerSeqArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsSenderArgs, never>>;
  sourceTag?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleEscrowsSourceTagArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleEscrowsTransactionTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleOffersResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleOffers'] = ResolversParentTypes['RippleOffers']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleOffersAnyArgs, 'of'>>;
  bookDirectory?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleOffersBookDirectoryArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleOffersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleOffersCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  expiration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  flags?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleOffersLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleOffersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleOffersMinimumArgs, 'of'>>;
  operation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sequence?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleOffersSequenceArgs, never>>;
  takerGets?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleOffersTakerGetsArgs, never>>;
  takerGetsCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  takerPays?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleOffersTakerPaysArgs, never>>;
  takerPaysCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleOffersTransactionHashArgs, never>>;
  transactionSender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleOffersTransactionSenderArgs, never>>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleOffersTransactionTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RipplePaymentsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RipplePayments'] = ResolversParentTypes['RipplePayments']> = {
  amountCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  amountIssuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsAmountIssuerArgs, never>>;
  amountValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RipplePaymentsAmountValueArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RipplePaymentsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RipplePaymentsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  deliverMinCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  deliverMinIssuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsDeliverMinIssuerArgs, never>>;
  deliverMinValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RipplePaymentsDeliverMinValueArgs, never>>;
  deliveredCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  deliveredIssuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsDeliveredIssuerArgs, never>>;
  deliveredValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RipplePaymentsDeliveredValueArgs, never>>;
  flags?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RipplePaymentsLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsMinimumArgs, 'of'>>;
  partial?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  sendMaxCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  sendMaxIssuer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsSendMaxIssuerArgs, never>>;
  sendMaxValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RipplePaymentsSendMaxValueArgs, never>>;
  tag?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RipplePaymentsTagArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsTransactionHashArgs, never>>;
  transferFrom?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsTransferFromArgs, never>>;
  transferTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RipplePaymentsTransferToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleRippleStatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleRippleStates'] = ResolversParentTypes['RippleRippleStates']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesAnyArgs, 'of'>>;
  balance?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleRippleStatesBalanceArgs, never>>;
  blockHeight?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleRippleStatesBlockHeightArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleRippleStatesCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleRippleStatesCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  flags?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesFlagsArgs, never>>;
  highAccount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesHighAccountArgs, never>>;
  lowAccount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesLowAccountArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesMinimumArgs, 'of'>>;
  operation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesOperationArgs, never>>;
  preBalance?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleRippleStatesPreBalanceArgs, never>>;
  previousTxnId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesPreviousTxnIdArgs, never>>;
  previousTxnLedgerSeq?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleRippleStatesPreviousTxnLedgerSeqArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesSenderArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleRippleStatesTransactionTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleTransactions'] = ResolversParentTypes['RippleTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransactionsAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleTransactionsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  flags?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  indexInLedger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  lastLedgerSequence?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleTransactionsLastLedgerSequenceArgs, never>>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleTransactionsLedgerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransactionsMaximumArgs, 'of'>>;
  memos?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransactionsMinimumArgs, 'of'>>;
  result?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransactionsResultArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransactionsSenderArgs, never>>;
  sequence?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleTransactionsSequenceArgs, never>>;
  status?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<RippleTransactionsStatusArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleTransactionsTransactionFeeArgs, never>>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransactionsTransactionHashArgs, never>>;
  transactionType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransactionsTransactionTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RippleTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['RippleTransfers'] = ResolversParentTypes['RippleTransfers']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransfersAnyArgs, 'of'>>;
  blockHeight?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleTransfersBlockHeightArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<RippleTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<RippleTransfersCountBigIntArgs, never>>;
  currencyFrom?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  currencyTo?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransfersMinimumArgs, 'of'>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransfersSenderArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransfersTransactionHashArgs, never>>;
  transferFrom?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransfersTransferFromArgs, never>>;
  transferTo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<RippleTransfersTransferToArgs, never>>;
  valueFrom?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleTransfersValueFromArgs, never>>;
  valueTo?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<RippleTransfersValueToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SenderResolvers<ContextType = any, ParentType extends ResolversParentTypes['Sender'] = ResolversParentTypes['Sender']> = {
  address?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mintAccount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SignatureResolvers<ContextType = any, ParentType extends ResolversParentTypes['Signature'] = ResolversParentTypes['Signature']> = {
  __resolveType: TypeResolveFn<'Event' | 'Method', ParentType, ContextType>;
};

export type SmartContractResolvers<ContextType = any, ParentType extends ResolversParentTypes['SmartContract'] = ResolversParentTypes['SmartContract']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contractType?: Resolver<ResolversTypes['SmartContractType'], ParentType, ContextType>;
  protocol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SmartContractReadonlyAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SmartContractReadonlyAttribute'] = ResolversParentTypes['SmartContractReadonlyAttribute']> = {
  address?: Resolver<Maybe<ResolversTypes['EthereumAddressInfo']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SolanaResolvers<ContextType = any, ParentType extends ResolversParentTypes['Solana'] = ResolversParentTypes['Solana']> = {
  blockRewards?: Resolver<Maybe<Array<ResolversTypes['SolanaBlockRewards']>>, ParentType, ContextType, RequireFields<SolanaBlockRewardsArgs, never>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['SolanaBlocks']>>, ParentType, ContextType, RequireFields<SolanaBlocksArgs, never>>;
  instructions?: Resolver<Maybe<Array<ResolversTypes['SolanaInstructions']>>, ParentType, ContextType, RequireFields<SolanaInstructionsArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['SolanaTransactions']>>, ParentType, ContextType, RequireFields<SolanaTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['SolanaTransfers']>>, ParentType, ContextType, RequireFields<SolanaTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SolanaBlockRewardsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SolanaBlockRewards'] = ResolversParentTypes['SolanaBlockRewards']> = {
  account?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsAccountArgs, never>>;
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsAnyArgs, 'of'>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsBlockHashArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  height?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsMinimumArgs, 'of'>>;
  parentSlot?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsParentSlotArgs, never>>;
  postBalance?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsPostBalanceArgs, never>>;
  previousBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsPreviousBlockHashArgs, never>>;
  rewardType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlockRewardsRewardTypeArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SolanaBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['SolanaBlocks'] = ResolversParentTypes['SolanaBlocks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlocksAnyArgs, 'of'>>;
  blockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlocksBlockHashArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SolanaBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaBlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  height?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaBlocksHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlocksMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlocksMinimumArgs, 'of'>>;
  parentSlot?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaBlocksParentSlotArgs, never>>;
  previousBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaBlocksPreviousBlockHashArgs, never>>;
  rewards?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<SolanaBlocksRewardsArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SolanaBlocksTransactionCountArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SolanaInstructionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SolanaInstructions'] = ResolversParentTypes['SolanaInstructions']> = {
  accountsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  action?: Resolver<Maybe<ResolversTypes['Action']>, ParentType, ContextType, RequireFields<SolanaInstructionsActionArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaInstructionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['BlockExtended']>, ParentType, ContextType, RequireFields<SolanaInstructionsBlockArgs, never>>;
  callPath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaInstructionsCallPathArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SolanaInstructionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaInstructionsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  external?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaInstructionsExternalArgs, never>>;
  externalAction?: Resolver<Maybe<ResolversTypes['ExternalAction']>, ParentType, ContextType, RequireFields<SolanaInstructionsExternalActionArgs, never>>;
  externalProgram?: Resolver<Maybe<ResolversTypes['Program']>, ParentType, ContextType, RequireFields<SolanaInstructionsExternalProgramArgs, never>>;
  feePayer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaInstructionsFeePayerArgs, never>>;
  log?: Resolver<Maybe<ResolversTypes['Log']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaInstructionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaInstructionsMinimumArgs, 'of'>>;
  previousBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaInstructionsPreviousBlockHashArgs, never>>;
  program?: Resolver<Maybe<ResolversTypes['Program']>, ParentType, ContextType, RequireFields<SolanaInstructionsProgramArgs, never>>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaInstructionsSignatureArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<SolanaInstructionsSuccessArgs, never>>;
  transactionIndex?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaInstructionsTransactionIndexArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SolanaTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SolanaTransactions'] = ResolversParentTypes['SolanaTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['BlockExtended']>, ParentType, ContextType, RequireFields<SolanaTransactionsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SolanaTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaTransactionsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsErrorArgs, never>>;
  feePayer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsFeePayerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsMinimumArgs, 'of'>>;
  parentSlot?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaTransactionsParentSlotArgs, never>>;
  previousBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsPreviousBlockHashArgs, never>>;
  recentBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsRecentBlockHashArgs, never>>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsSignatureArgs, never>>;
  signer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransactionsSignerArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<SolanaTransactionsSuccessArgs, never>>;
  transactionFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<SolanaTransactionsTransactionFeeArgs, never>>;
  transactionIndex?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaTransactionsTransactionIndexArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SolanaTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['SolanaTransfers'] = ResolversParentTypes['SolanaTransfers']> = {
  action?: Resolver<Maybe<ResolversTypes['Action']>, ParentType, ContextType, RequireFields<SolanaTransfersActionArgs, never>>;
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<SolanaTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['BlockExtended']>, ParentType, ContextType, RequireFields<SolanaTransfersBlockArgs, never>>;
  callPath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersCallPathArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SolanaTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  externalAction?: Resolver<Maybe<ResolversTypes['ExternalAction']>, ParentType, ContextType, RequireFields<SolanaTransfersExternalActionArgs, never>>;
  externalParsed?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<SolanaTransfersExternalParsedArgs, never>>;
  externalParsedType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersExternalParsedTypeArgs, never>>;
  externalProgram?: Resolver<Maybe<ResolversTypes['Program']>, ParentType, ContextType, RequireFields<SolanaTransfersExternalProgramArgs, never>>;
  feePayer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersFeePayerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersMinimumArgs, 'of'>>;
  parsedActionName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersParsedActionNameArgs, never>>;
  previousBlockHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersPreviousBlockHashArgs, never>>;
  program?: Resolver<Maybe<ResolversTypes['Program']>, ParentType, ContextType, RequireFields<SolanaTransfersProgramArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['Receiver']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['Sender']>, ParentType, ContextType>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersSignatureArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<SolanaTransfersSuccessArgs, never>>;
  transactionIndex?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<SolanaTransfersTransactionIndexArgs, never>>;
  transferType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SolanaTransfersTransferTypeArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StellarResolvers<ContextType = any, ParentType extends ResolversParentTypes['Stellar'] = ResolversParentTypes['Stellar']> = {
  transfers?: Resolver<Maybe<Array<ResolversTypes['StellarTransfers']>>, ParentType, ContextType, RequireFields<StellarTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StellarTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['StellarTransfers'] = ResolversParentTypes['StellarTransfers']> = {
  amountFrom?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<StellarTransfersAmountFromArgs, never>>;
  amountTo?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<StellarTransfersAmountToArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<StellarTransfersAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<StellarTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<StellarTransfersCountBigIntArgs, never>>;
  currencyFrom?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  currencyTo?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  direction?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<StellarTransfersDirectionArgs, never>>;
  ledger?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<StellarTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<StellarTransfersMinimumArgs, 'of'>>;
  operation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  operationCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  receiver?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<StellarTransfersReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<StellarTransfersSenderArgs, never>>;
  time?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<StellarTransfersTransactionHashArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subject'] = ResolversParentTypes['Subject']> = {
  __resolveType: TypeResolveFn<'Address' | 'Currency' | 'SmartContract' | 'TransactionHash', ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {
  ethereum?: SubscriptionResolver<Maybe<ResolversTypes['Ethereum']>, "ethereum", ParentType, ContextType, RequireFields<SubscriptionEthereumArgs, never>>;
};

export type TimeIntervalResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeInterval'] = ResolversParentTypes['TimeInterval']> = {
  day?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TimeIntervalDayArgs, never>>;
  hour?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TimeIntervalHourArgs, never>>;
  minute?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TimeIntervalMinuteArgs, never>>;
  month?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TimeIntervalMonthArgs, never>>;
  second?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TimeIntervalSecondArgs, never>>;
  year?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TimeIntervalYearArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimestampResolvers<ContextType = any, ParentType extends ResolversParentTypes['Timestamp'] = ResolversParentTypes['Timestamp']> = {
  nanoseconds?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  time?: Resolver<ResolversTypes['ISO8601Date'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionElrondResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionElrond'] = ResolversParentTypes['TransactionElrond']> = {
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TransactionElrondDataArgs, never>>;
  dataOperation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TransactionElrondDataOperationArgs, never>>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TransactionElrondFeeArgs, never>>;
  hash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TransactionElrondHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TransactionElrondIndexArgs, never>>;
  nonce?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TransactionElrondNonceArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TransactionElrondReceiverArgs, never>>;
  receiverShard?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TransactionElrondReceiverShardArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TransactionElrondSenderArgs, never>>;
  senderShard?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TransactionElrondSenderShardArgs, never>>;
  signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TransactionElrondSignatureArgs, never>>;
  status?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TransactionElrondStatusArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionHashResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionHash'] = ResolversParentTypes['TransactionHash']> = {
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionHashIndexResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionHashIndex'] = ResolversParentTypes['TransactionHashIndex']> = {
  block?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  index?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionHashValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionHashValue'] = ResolversParentTypes['TransactionHashValue']> = {
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionResult'] = ResolversParentTypes['TransactionResult']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionSourceResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionSource'] = ResolversParentTypes['TransactionSource']> = {
  code?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronResolvers<ContextType = any, ParentType extends ResolversParentTypes['Tron'] = ResolversParentTypes['Tron']> = {
  address?: Resolver<Array<ResolversTypes['TronAddressInfo']>, ParentType, ContextType, RequireFields<TronAddressArgs, 'address'>>;
  blocks?: Resolver<Maybe<Array<ResolversTypes['TronBlocks']>>, ParentType, ContextType, RequireFields<TronBlocksArgs, never>>;
  coinpath?: Resolver<Maybe<Array<ResolversTypes['TronCoinpath']>>, ParentType, ContextType, RequireFields<TronCoinpathArgs, never>>;
  contracts?: Resolver<Maybe<Array<ResolversTypes['TronSmartContracts']>>, ParentType, ContextType, RequireFields<TronContractsArgs, never>>;
  dexTrades?: Resolver<Maybe<Array<ResolversTypes['TronDexTrades']>>, ParentType, ContextType, RequireFields<TronDexTradesArgs, never>>;
  smartContractCalls?: Resolver<Maybe<Array<ResolversTypes['TronSmartContractCalls']>>, ParentType, ContextType, RequireFields<TronSmartContractCallsArgs, never>>;
  smartContractEvents?: Resolver<Maybe<Array<ResolversTypes['TronSmartContractEvents']>>, ParentType, ContextType, RequireFields<TronSmartContractEventsArgs, never>>;
  trades?: Resolver<Maybe<Array<ResolversTypes['TronTrades']>>, ParentType, ContextType, RequireFields<TronTradesArgs, never>>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['TronTransactions']>>, ParentType, ContextType, RequireFields<TronTransactionsArgs, never>>;
  transfers?: Resolver<Maybe<Array<ResolversTypes['TronTransfers']>>, ParentType, ContextType, RequireFields<TronTransfersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronAddressInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronAddressInfo'] = ResolversParentTypes['TronAddressInfo']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  annotation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['TronSmartContractInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronBlocksResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronBlocks'] = ResolversParentTypes['TronBlocks']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronBlocksAnyArgs, 'of'>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronBlocksCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronBlocksCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TronBlocksHashArgs, never>>;
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType, RequireFields<TronBlocksHeightArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronBlocksMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronBlocksMinimumArgs, 'of'>>;
  parentBlockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TronBlocksParentBlockHashArgs, never>>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType, RequireFields<TronBlocksTimestampArgs, never>>;
  txTrieRoot?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronBlocksVersionArgs, never>>;
  witness?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronBlocksWitnessArgs, never>>;
  witnessSignature?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronCoinpathResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronCoinpath'] = ResolversParentTypes['TronCoinpath']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronCoinpathAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronCoinpathAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  depth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronCoinpathMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronCoinpathMinimumArgs, 'of'>>;
  receiver?: Resolver<Maybe<ResolversTypes['TronAddressInfo']>, ParentType, ContextType>;
  sender?: Resolver<Maybe<ResolversTypes['TronAddressInfo']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['TransactionHashValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronDexResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronDex'] = ResolversParentTypes['TronDex']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  fullName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fullNameWithId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronDexTradesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronDexTrades'] = ResolversParentTypes['TronDexTrades']> = {
  address?: Resolver<Maybe<ResolversTypes['TronAddressInfo']>, ParentType, ContextType, RequireFields<TronDexTradesAddressArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronDexTradesAnyArgs, 'of'>>;
  baseAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesBaseAmountArgs, never>>;
  baseCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronDexTradesBaseCurrencyArgs, never>>;
  block?: Resolver<Maybe<ResolversTypes['BlockExtended']>, ParentType, ContextType, RequireFields<TronDexTradesBlockArgs, never>>;
  buyAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesBuyAmountArgs, never>>;
  buyCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronDexTradesBuyCurrencyArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronDexTradesCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronDexTradesCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  energyFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesEnergyFeeArgs, never>>;
  energyUsageTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesEnergyUsageTotalArgs, never>>;
  exchange?: Resolver<Maybe<ResolversTypes['TronDex']>, ParentType, ContextType, RequireFields<TronDexTradesExchangeArgs, never>>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesFeeArgs, never>>;
  internalTransactionsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronDexTradesInternalTransactionsCountArgs, never>>;
  internalTransactionsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronDexTradesInternalTransactionsCountBigIntArgs, never>>;
  logsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronDexTradesLogsCountArgs, never>>;
  logsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronDexTradesLogsCountBigIntArgs, never>>;
  maker?: Resolver<Maybe<ResolversTypes['TronAddressInfo']>, ParentType, ContextType, RequireFields<TronDexTradesMakerArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronDexTradesMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronDexTradesMinimumArgs, 'of'>>;
  netFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesNetFeeArgs, never>>;
  netUsage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesNetUsageArgs, never>>;
  price?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesPriceArgs, never>>;
  protocol?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronDexTradesProtocolArgs, never>>;
  quoteAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesQuoteAmountArgs, never>>;
  quoteCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronDexTradesQuoteCurrencyArgs, never>>;
  quotePrice?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesQuotePriceArgs, never>>;
  sellAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesSellAmountArgs, never>>;
  sellCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronDexTradesSellCurrencyArgs, never>>;
  side?: Resolver<Maybe<ResolversTypes['TradeSide']>, ParentType, ContextType>;
  smartContract?: Resolver<Maybe<ResolversTypes['TronSmartContract']>, ParentType, ContextType, RequireFields<TronDexTradesSmartContractArgs, never>>;
  taker?: Resolver<Maybe<ResolversTypes['TronAddressInfo']>, ParentType, ContextType, RequireFields<TronDexTradesTakerArgs, never>>;
  timeInterval?: Resolver<Maybe<ResolversTypes['TimeInterval']>, ParentType, ContextType>;
  tradeAmount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronDexTradesTradeAmountArgs, 'in'>>;
  tradeIndex?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronDexTradesTradeIndexArgs, never>>;
  transaction?: Resolver<Maybe<ResolversTypes['TronTransactionInfoExtended']>, ParentType, ContextType, RequireFields<TronDexTradesTransactionArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronSmartContractResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronSmartContract'] = ResolversParentTypes['TronSmartContract']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  contractType?: Resolver<Maybe<ResolversTypes['SmartContractType']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  protocolType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronSmartContractCallsResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronSmartContractCalls'] = ResolversParentTypes['TronSmartContractCalls']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractCallsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractCallsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<TronSmartContractCallsBlockArgs, never>>;
  callDepth?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronSmartContractCallsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronSmartContractCallsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  energyUsageTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractCallsEnergyUsageTotalArgs, never>>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<TronSmartContractCallsExternalArgs, never>>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractCallsFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractCallsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractCallsMinimumArgs, 'of'>>;
  netUsage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractCallsNetUsageArgs, never>>;
  smartContract?: Resolver<Maybe<ResolversTypes['TronSmartContract']>, ParentType, ContextType, RequireFields<TronSmartContractCallsSmartContractArgs, never>>;
  smartContractMethod?: Resolver<Maybe<ResolversTypes['Method']>, ParentType, ContextType, RequireFields<TronSmartContractCallsSmartContractMethodArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<TronSmartContractCallsSuccessArgs, never>>;
  txFrom?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronSmartContractCallsTxFromArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractCallsTxHashArgs, never>>;
  txTo?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronSmartContractCallsTxToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronSmartContractEventsResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronSmartContractEvents'] = ResolversParentTypes['TronSmartContractEvents']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractEventsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<TronSmartContractEventsBlockArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronSmartContractEventsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronSmartContractEventsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractEventsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractEventsMinimumArgs, 'of'>>;
  smartContract?: Resolver<Maybe<ResolversTypes['TronSmartContract']>, ParentType, ContextType, RequireFields<TronSmartContractEventsSmartContractArgs, never>>;
  smartContractEvent?: Resolver<Maybe<ResolversTypes['Event']>, ParentType, ContextType, RequireFields<TronSmartContractEventsSmartContractEventArgs, never>>;
  txFrom?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronSmartContractEventsTxFromArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractEventsTxHashArgs, never>>;
  txTo?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronSmartContractEventsTxToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronSmartContractInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronSmartContractInfo'] = ResolversParentTypes['TronSmartContractInfo']> = {
  contractType?: Resolver<Maybe<ResolversTypes['SmartContractType']>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType>;
  protocolType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronSmartContractsResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronSmartContracts'] = ResolversParentTypes['TronSmartContracts']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractsAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<TronSmartContractsBlockArgs, never>>;
  contractType?: Resolver<Maybe<ResolversTypes['TronContractType']>, ParentType, ContextType, RequireFields<TronSmartContractsContractTypeArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronSmartContractsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronSmartContractsCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronSmartContractsCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  energyUsageTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractsEnergyUsageTotalArgs, never>>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractsFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractsMinimumArgs, 'of'>>;
  netUsage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronSmartContractsNetUsageArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<TronSmartContractsSuccessArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronSmartContractsTxHashArgs, never>>;
  txOwner?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronSmartContractsTxOwnerArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronTradesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronTrades'] = ResolversParentTypes['TronTrades']> = {
  amountBuy?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTradesAmountBuyArgs, never>>;
  amountSell?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTradesAmountSellArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTradesAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<TronTradesBlockArgs, never>>;
  buyCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronTradesBuyCurrencyArgs, never>>;
  buyer?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronTradesBuyerArgs, never>>;
  contractType?: Resolver<Maybe<ResolversTypes['TronContractType']>, ParentType, ContextType, RequireFields<TronTradesContractTypeArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronTradesCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronTradesCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  energyUsageTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTradesEnergyUsageTotalArgs, never>>;
  exchangeId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronTradesExchangeIdArgs, never>>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTradesFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTradesMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTradesMinimumArgs, 'of'>>;
  netUsage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTradesNetUsageArgs, never>>;
  sellCurrency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronTradesSellCurrencyArgs, never>>;
  seller?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronTradesSellerArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<TronTradesSuccessArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTradesTxHashArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronTransactionInfoExtendedResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronTransactionInfoExtended'] = ResolversParentTypes['TronTransactionInfoExtended']> = {
  contractAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  expiration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  feeLimit?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  refBlockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signatures?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronTransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronTransactions'] = ResolversParentTypes['TronTransactions']> = {
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransactionsAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<TronTransactionsBlockArgs, never>>;
  contractAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronTransactionsContractAddressArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronTransactionsCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronTransactionsCountBigIntArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  energyFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransactionsEnergyFeeArgs, never>>;
  energyUsageTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransactionsEnergyUsageTotalArgs, never>>;
  expiration?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransactionsFeeArgs, never>>;
  feeLimit?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TronTransactionsHashArgs, never>>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronTransactionsIndexArgs, never>>;
  internalTransactionsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronTransactionsInternalTransactionsCountArgs, never>>;
  internalTransactionsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronTransactionsInternalTransactionsCountBigIntArgs, never>>;
  logsCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronTransactionsLogsCountArgs, never>>;
  logsCountBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronTransactionsLogsCountBigIntArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransactionsMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransactionsMinimumArgs, 'of'>>;
  netFee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransactionsNetFeeArgs, never>>;
  netUsage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransactionsNetUsageArgs, never>>;
  refBlockHash?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<TronTransactionsRefBlockHashArgs, never>>;
  result?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  signatures?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<TronTransactionsSuccessArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TronTransfersResolvers<ContextType = any, ParentType extends ResolversParentTypes['TronTransfers'] = ResolversParentTypes['TronTransfers']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransfersAmountArgs, never>>;
  any?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransfersAnyArgs, 'of'>>;
  block?: Resolver<Maybe<ResolversTypes['Block']>, ParentType, ContextType, RequireFields<TronTransfersBlockArgs, never>>;
  contractType?: Resolver<Maybe<ResolversTypes['TronContractType']>, ParentType, ContextType, RequireFields<TronTransfersContractTypeArgs, never>>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<TronTransfersCountArgs, never>>;
  countBigInt?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<TronTransfersCountBigIntArgs, never>>;
  currency?: Resolver<Maybe<ResolversTypes['Currency']>, ParentType, ContextType, RequireFields<TronTransfersCurrencyArgs, never>>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  energyUsageTotal?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransfersEnergyUsageTotalArgs, never>>;
  entityId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransfersEntityIdArgs, never>>;
  external?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<TronTransfersExternalArgs, never>>;
  fee?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransfersFeeArgs, never>>;
  maximum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransfersMaximumArgs, 'of'>>;
  minimum?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransfersMinimumArgs, 'of'>>;
  netUsage?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType, RequireFields<TronTransfersNetUsageArgs, never>>;
  receiver?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronTransfersReceiverArgs, never>>;
  sender?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronTransfersSenderArgs, never>>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<TronTransfersSuccessArgs, never>>;
  txFrom?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronTransfersTxFromArgs, never>>;
  txHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<TronTransfersTxHashArgs, never>>;
  txTo?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<TronTransfersTxToArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  Account?: AccountResolvers<ContextType>;
  Action?: ActionResolvers<ContextType>;
  Address?: AddressResolvers<ContextType>;
  AddressWithAccount?: AddressWithAccountResolvers<ContextType>;
  Algorand?: AlgorandResolvers<ContextType>;
  AlgorandAddressInfo?: AlgorandAddressInfoResolvers<ContextType>;
  AlgorandArguments?: AlgorandArgumentsResolvers<ContextType>;
  AlgorandBlocks?: AlgorandBlocksResolvers<ContextType>;
  AlgorandCoinpath?: AlgorandCoinpathResolvers<ContextType>;
  AlgorandSmartContract?: AlgorandSmartContractResolvers<ContextType>;
  AlgorandSmartContractCalls?: AlgorandSmartContractCallsResolvers<ContextType>;
  AlgorandTransactionWithAttributes?: AlgorandTransactionWithAttributesResolvers<ContextType>;
  AlgorandTransactions?: AlgorandTransactionsResolvers<ContextType>;
  AlgorandTransfers?: AlgorandTransfersResolvers<ContextType>;
  ArgumentName?: ArgumentNameResolvers<ContextType>;
  ArgumentNameValue?: ArgumentNameValueResolvers<ContextType>;
  ArgumentValue?: ArgumentValueResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  Binance?: BinanceResolvers<ContextType>;
  BinanceBlock?: BinanceBlockResolvers<ContextType>;
  BinanceCoinpath?: BinanceCoinpathResolvers<ContextType>;
  BinanceOrders?: BinanceOrdersResolvers<ContextType>;
  BinanceTrades?: BinanceTradesResolvers<ContextType>;
  BinanceTransactions?: BinanceTransactionsResolvers<ContextType>;
  BinanceTransfers?: BinanceTransfersResolvers<ContextType>;
  Bitcoin?: BitcoinResolvers<ContextType>;
  BitcoinBlock?: BitcoinBlockResolvers<ContextType>;
  BitcoinCoinpath?: BitcoinCoinpathResolvers<ContextType>;
  BitcoinOmniTransactiosn?: BitcoinOmniTransactiosnResolvers<ContextType>;
  BitcoinOmniTransfers?: BitcoinOmniTransfersResolvers<ContextType>;
  BitcoinTransaction?: BitcoinTransactionResolvers<ContextType>;
  BitcoinTransactionHashIndexValues?: BitcoinTransactionHashIndexValuesResolvers<ContextType>;
  BitcoinTransactionInput?: BitcoinTransactionInputResolvers<ContextType>;
  BitcoinTransactionOutput?: BitcoinTransactionOutputResolvers<ContextType>;
  Block?: BlockResolvers<ContextType>;
  BlockExtended?: BlockExtendedResolvers<ContextType>;
  BlockInfo?: BlockInfoResolvers<ContextType>;
  BlockchainNetwork?: BlockchainNetworkResolvers<ContextType>;
  CallElrond?: CallElrondResolvers<ContextType>;
  Cardano?: CardanoResolvers<ContextType>;
  CardanoAddressBalance?: CardanoAddressBalanceResolvers<ContextType>;
  CardanoAddressInfo?: CardanoAddressInfoResolvers<ContextType>;
  CardanoBlock?: CardanoBlockResolvers<ContextType>;
  CardanoCoinpath?: CardanoCoinpathResolvers<ContextType>;
  CardanoStakingAddress?: CardanoStakingAddressResolvers<ContextType>;
  CardanoTransaction?: CardanoTransactionResolvers<ContextType>;
  CardanoTransactionHashIndexValues?: CardanoTransactionHashIndexValuesResolvers<ContextType>;
  CardanoTransactionInput?: CardanoTransactionInputResolvers<ContextType>;
  CardanoTransactionMint?: CardanoTransactionMintResolvers<ContextType>;
  CardanoTransactionOutput?: CardanoTransactionOutputResolvers<ContextType>;
  CoinpathEntry?: CoinpathEntryResolvers<ContextType>;
  Conflux?: ConfluxResolvers<ContextType>;
  ConfluxBlocks?: ConfluxBlocksResolvers<ContextType>;
  ConfluxTransactions?: ConfluxTransactionsResolvers<ContextType>;
  CovidCountry?: CovidCountryResolvers<ContextType>;
  CovidFact?: CovidFactResolvers<ContextType>;
  CovidHistory?: CovidHistoryResolvers<ContextType>;
  CovidLocation?: CovidLocationResolvers<ContextType>;
  Currency?: CurrencyResolvers<ContextType>;
  Date?: DateResolvers<ContextType>;
  DateTime?: DateTimeResolvers<ContextType>;
  DecimalNumber?: GraphQLScalarType;
  DecimalNumberAsDiv?: GraphQLScalarType;
  Elrond?: ElrondResolvers<ContextType>;
  ElrondAddressHash?: ElrondAddressHashResolvers<ContextType>;
  ElrondArgument?: ElrondArgumentResolvers<ContextType>;
  ElrondBlock?: ElrondBlockResolvers<ContextType>;
  ElrondBlockDimension?: ElrondBlockDimensionResolvers<ContextType>;
  ElrondBlockValidator?: ElrondBlockValidatorResolvers<ContextType>;
  ElrondCall?: ElrondCallResolvers<ContextType>;
  ElrondCallResult?: ElrondCallResultResolvers<ContextType>;
  ElrondCoinpath?: ElrondCoinpathResolvers<ContextType>;
  ElrondMiniblock?: ElrondMiniblockResolvers<ContextType>;
  ElrondNotarizedBlock?: ElrondNotarizedBlockResolvers<ContextType>;
  ElrondTransaction?: ElrondTransactionResolvers<ContextType>;
  ElrondTransactionValueDimension?: ElrondTransactionValueDimensionResolvers<ContextType>;
  ElrondTransfer?: ElrondTransferResolvers<ContextType>;
  Entity?: EntityResolvers<ContextType>;
  Eos?: EosResolvers<ContextType>;
  EosAddressInfo?: EosAddressInfoResolvers<ContextType>;
  EosBlocks?: EosBlocksResolvers<ContextType>;
  EosCoinpath?: EosCoinpathResolvers<ContextType>;
  EosSmartContract?: EosSmartContractResolvers<ContextType>;
  EosSmartContractCalls?: EosSmartContractCallsResolvers<ContextType>;
  EosSmartContractInfo?: EosSmartContractInfoResolvers<ContextType>;
  EosTransactions?: EosTransactionsResolvers<ContextType>;
  EosTransfers?: EosTransfersResolvers<ContextType>;
  Ethereum?: EthereumResolvers<ContextType>;
  Ethereum2?: Ethereum2Resolvers<ContextType>;
  Ethereum2Attestation?: Ethereum2AttestationResolvers<ContextType>;
  Ethereum2AttestationFieldInfo?: Ethereum2AttestationFieldInfoResolvers<ContextType>;
  Ethereum2AttestationInfo?: Ethereum2AttestationInfoResolvers<ContextType>;
  Ethereum2AttesterSlashing?: Ethereum2AttesterSlashingResolvers<ContextType>;
  Ethereum2Blocks?: Ethereum2BlocksResolvers<ContextType>;
  Ethereum2Deposit?: Ethereum2DepositResolvers<ContextType>;
  Ethereum2Eth1Info?: Ethereum2Eth1InfoResolvers<ContextType>;
  Ethereum2ProposerSlashing?: Ethereum2ProposerSlashingResolvers<ContextType>;
  Ethereum2SlashingInfo?: Ethereum2SlashingInfoResolvers<ContextType>;
  Ethereum2ValidatorInfo?: Ethereum2ValidatorInfoResolvers<ContextType>;
  Ethereum2VoluntaryExit?: Ethereum2VoluntaryExitResolvers<ContextType>;
  EthereumAddressInfo?: EthereumAddressInfoResolvers<ContextType>;
  EthereumAddressInfoWithBalance?: EthereumAddressInfoWithBalanceResolvers<ContextType>;
  EthereumArguments?: EthereumArgumentsResolvers<ContextType>;
  EthereumBalance?: EthereumBalanceResolvers<ContextType>;
  EthereumBalanceChange?: EthereumBalanceChangeResolvers<ContextType>;
  EthereumBlocks?: EthereumBlocksResolvers<ContextType>;
  EthereumCoinpath?: EthereumCoinpathResolvers<ContextType>;
  EthereumDex?: EthereumDexResolvers<ContextType>;
  EthereumDexTrades?: EthereumDexTradesResolvers<ContextType>;
  EthereumSmartContract?: EthereumSmartContractResolvers<ContextType>;
  EthereumSmartContractCalls?: EthereumSmartContractCallsResolvers<ContextType>;
  EthereumSmartContractEvent?: EthereumSmartContractEventResolvers<ContextType>;
  EthereumSmartContractInfo?: EthereumSmartContractInfoResolvers<ContextType>;
  EthereumSmartContractInfoWithAttributes?: EthereumSmartContractInfoWithAttributesResolvers<ContextType>;
  EthereumTransactionInfo?: EthereumTransactionInfoResolvers<ContextType>;
  EthereumTransactionInfoExtended?: EthereumTransactionInfoExtendedResolvers<ContextType>;
  EthereumTransactions?: EthereumTransactionsResolvers<ContextType>;
  EthereumTransfers?: EthereumTransfersResolvers<ContextType>;
  Event?: EventResolvers<ContextType>;
  ExternalAction?: ExternalActionResolvers<ContextType>;
  Filecoin?: FilecoinResolvers<ContextType>;
  FilecoinBlock?: FilecoinBlockResolvers<ContextType>;
  FilecoinCalls?: FilecoinCallsResolvers<ContextType>;
  FilecoinCoinpath?: FilecoinCoinpathResolvers<ContextType>;
  FilecoinMessages?: FilecoinMessagesResolvers<ContextType>;
  FilecoinMinedBlock?: FilecoinMinedBlockResolvers<ContextType>;
  FilecoinTransfers?: FilecoinTransfersResolvers<ContextType>;
  Harmony?: HarmonyResolvers<ContextType>;
  HarmonyArguments?: HarmonyArgumentsResolvers<ContextType>;
  HarmonyBlocks?: HarmonyBlocksResolvers<ContextType>;
  HarmonySmartContractCalls?: HarmonySmartContractCallsResolvers<ContextType>;
  HarmonySmartContractEvents?: HarmonySmartContractEventsResolvers<ContextType>;
  HarmonyStakingTransactions?: HarmonyStakingTransactionsResolvers<ContextType>;
  HarmonyTransactions?: HarmonyTransactionsResolvers<ContextType>;
  HarmonyTransfers?: HarmonyTransfersResolvers<ContextType>;
  Hedera?: HederaResolvers<ContextType>;
  HederaArgument?: HederaArgumentResolvers<ContextType>;
  HederaCall?: HederaCallResolvers<ContextType>;
  HederaCoinpath?: HederaCoinpathResolvers<ContextType>;
  HederaInput?: HederaInputResolvers<ContextType>;
  HederaMessage?: HederaMessageResolvers<ContextType>;
  HederaOutput?: HederaOutputResolvers<ContextType>;
  HederaTransaction?: HederaTransactionResolvers<ContextType>;
  ISO8601Date?: GraphQLScalarType;
  ISO8601DateTime?: GraphQLScalarType;
  InputScript?: InputScriptResolvers<ContextType>;
  Libra?: LibraResolvers<ContextType>;
  LibraBlock?: LibraBlockResolvers<ContextType>;
  LibraCoinpath?: LibraCoinpathResolvers<ContextType>;
  LibraMints?: LibraMintsResolvers<ContextType>;
  LibraTransactionValue?: LibraTransactionValueResolvers<ContextType>;
  LibraTransactions?: LibraTransactionsResolvers<ContextType>;
  LibraTransfers?: LibraTransfersResolvers<ContextType>;
  Log?: LogResolvers<ContextType>;
  Method?: MethodResolvers<ContextType>;
  MiniblockElrond?: MiniblockElrondResolvers<ContextType>;
  NameWithId?: NameWithIdResolvers<ContextType>;
  Offchain?: OffchainResolvers<ContextType>;
  OutputScript?: OutputScriptResolvers<ContextType>;
  Program?: ProgramResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Receiver?: ReceiverResolvers<ContextType>;
  Result?: ResultResolvers<ContextType>;
  Ripple?: RippleResolvers<ContextType>;
  RippleAccountRoots?: RippleAccountRootsResolvers<ContextType>;
  RippleBalances?: RippleBalancesResolvers<ContextType>;
  RippleBlocks?: RippleBlocksResolvers<ContextType>;
  RippleChecks?: RippleChecksResolvers<ContextType>;
  RippleEscrows?: RippleEscrowsResolvers<ContextType>;
  RippleOffers?: RippleOffersResolvers<ContextType>;
  RipplePayments?: RipplePaymentsResolvers<ContextType>;
  RippleRippleStates?: RippleRippleStatesResolvers<ContextType>;
  RippleTransactions?: RippleTransactionsResolvers<ContextType>;
  RippleTransfers?: RippleTransfersResolvers<ContextType>;
  Sender?: SenderResolvers<ContextType>;
  Signature?: SignatureResolvers<ContextType>;
  SmartContract?: SmartContractResolvers<ContextType>;
  SmartContractReadonlyAttribute?: SmartContractReadonlyAttributeResolvers<ContextType>;
  Solana?: SolanaResolvers<ContextType>;
  SolanaBlockRewards?: SolanaBlockRewardsResolvers<ContextType>;
  SolanaBlocks?: SolanaBlocksResolvers<ContextType>;
  SolanaInstructions?: SolanaInstructionsResolvers<ContextType>;
  SolanaTransactions?: SolanaTransactionsResolvers<ContextType>;
  SolanaTransfers?: SolanaTransfersResolvers<ContextType>;
  Stellar?: StellarResolvers<ContextType>;
  StellarTransfers?: StellarTransfersResolvers<ContextType>;
  Subject?: SubjectResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  TimeInterval?: TimeIntervalResolvers<ContextType>;
  Timestamp?: TimestampResolvers<ContextType>;
  TransactionElrond?: TransactionElrondResolvers<ContextType>;
  TransactionHash?: TransactionHashResolvers<ContextType>;
  TransactionHashIndex?: TransactionHashIndexResolvers<ContextType>;
  TransactionHashValue?: TransactionHashValueResolvers<ContextType>;
  TransactionResult?: TransactionResultResolvers<ContextType>;
  TransactionSource?: TransactionSourceResolvers<ContextType>;
  Tron?: TronResolvers<ContextType>;
  TronAddressInfo?: TronAddressInfoResolvers<ContextType>;
  TronBlocks?: TronBlocksResolvers<ContextType>;
  TronCoinpath?: TronCoinpathResolvers<ContextType>;
  TronDex?: TronDexResolvers<ContextType>;
  TronDexTrades?: TronDexTradesResolvers<ContextType>;
  TronSmartContract?: TronSmartContractResolvers<ContextType>;
  TronSmartContractCalls?: TronSmartContractCallsResolvers<ContextType>;
  TronSmartContractEvents?: TronSmartContractEventsResolvers<ContextType>;
  TronSmartContractInfo?: TronSmartContractInfoResolvers<ContextType>;
  TronSmartContracts?: TronSmartContractsResolvers<ContextType>;
  TronTrades?: TronTradesResolvers<ContextType>;
  TronTransactionInfoExtended?: TronTransactionInfoExtendedResolvers<ContextType>;
  TronTransactions?: TronTransactionsResolvers<ContextType>;
  TronTransfers?: TronTransfersResolvers<ContextType>;
};

export type DirectiveResolvers<ContextType = any> = {
  union?: UnionDirectiveResolver<any, any, ContextType>;
  abstractEntity?: AbstractEntityDirectiveResolver<any, any, ContextType>;
  entity?: EntityDirectiveResolver<any, any, ContextType>;
  column?: ColumnDirectiveResolver<any, any, ContextType>;
  id?: IdDirectiveResolver<any, any, ContextType>;
  link?: LinkDirectiveResolver<any, any, ContextType>;
  embedded?: EmbeddedDirectiveResolver<any, any, ContextType>;
  map?: MapDirectiveResolver<any, any, ContextType>;
};

import { ObjectID } from 'mongodb';